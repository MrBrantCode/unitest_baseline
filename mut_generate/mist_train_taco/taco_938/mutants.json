{
  "task_id": "taco_938",
  "entry_point": "calculate_minimum_moves",
  "mutant_count": 103,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 * 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 * 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 + 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 + 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 -= [i % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 -= [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 -= [(i + 1) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 -= [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):",
      "mutated_line": "if sorted(collections.Counter(t1).items()) != sorted(collections.Counter(b).items()):",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) != sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):",
      "mutated_line": "if sorted(collections.Counter(t2).items()) != sorted(collections.Counter(b).items()):",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) != sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 11 ** 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 11 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 9 ** 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 9 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 0 ** 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 0 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 1 ** 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 1 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = -10 ** 20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = -10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 21",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 21\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 19",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 19\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 0\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 1\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** -20",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** -20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 2] / p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] / p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 2] + p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] + p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 2] ** p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] ** p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 2] / p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] / p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 2] + p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] + p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 2] ** p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] ** p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 1\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tr = 0",
      "mutated_line": "tr = -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = -1\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 1\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 1\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pi = 0",
      "mutated_line": "pi = -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = -1\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 1\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr -= abs(i - pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr -= abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "pi += 1",
      "mutated_line": "pi -= 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi -= 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 1\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tr = 0",
      "mutated_line": "tr = -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = -1\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 1\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 1\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pi = 0",
      "mutated_line": "pi = -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = -1\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 1\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr -= abs(i - pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr -= abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "pi += 1",
      "mutated_line": "pi -= 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi -= 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if r > tr:",
      "mutated_line": "if r >= tr:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r >= tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if r > tr:",
      "mutated_line": "if r <= tr:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r <= tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if r > tr:",
      "mutated_line": "if r != tr:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r != tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if t1[i] != 1:",
      "mutated_line": "if t1[i] == 1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] == 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] == 1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] == 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "pi += 1",
      "mutated_line": "pi -= 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi -= 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi += 1",
      "mutated_line": "pi += 2",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 2\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 0\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 0\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi += 1",
      "mutated_line": "pi += -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += -1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if t2[i] != 1:",
      "mutated_line": "if t2[i] == 1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] == 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] == 1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] == 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "pi += 1",
      "mutated_line": "pi -= 1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi -= 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi += 1",
      "mutated_line": "pi += 2",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 2\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 0\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 0\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi += 1",
      "mutated_line": "pi += -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += -1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i * 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i * 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i + 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i + 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) * 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) * 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [i + 1 + 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [i + 1 + 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if t1[i] != 1:",
      "mutated_line": "if t1[i] != 2:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 2:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if t1[i] != 1:",
      "mutated_line": "if t1[i] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 0:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if t1[i] != 1:",
      "mutated_line": "if t1[i] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 0:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if t1[i] != 1:",
      "mutated_line": "if t1[i] != -1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != -1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 2:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 2:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 0:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 0:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != -1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != -1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pi += 1",
      "mutated_line": "pi += 2",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 2\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 0\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 0\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pi += 1",
      "mutated_line": "pi += -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += -1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr += abs(i + pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i + pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr += abs(i * pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i * pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if t2[i] != 1:",
      "mutated_line": "if t2[i] != 2:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 2:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if t2[i] != 1:",
      "mutated_line": "if t2[i] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 0:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if t2[i] != 1:",
      "mutated_line": "if t2[i] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 0:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if t2[i] != 1:",
      "mutated_line": "if t2[i] != -1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != -1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 2:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 2:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 0:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != 0:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 0:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while b[pi] != 1:",
      "mutated_line": "while b[pi] != -1:",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != -1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pi += 1",
      "mutated_line": "pi += 2",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 2\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 0\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 0\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pi += 1",
      "mutated_line": "pi += -1",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += -1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr += abs(i + pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i + pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tr += abs(i - pi)",
      "mutated_line": "tr += abs(i * pi)",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i * pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 3] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 3] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 1] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 1] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 0] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 0] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % 1] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 1] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t1 += [i % 2] * p[i]",
      "mutated_line": "t1 += [i % -2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % -2] * p[i]\n        t2 += [(i + 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i - 1) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i - 1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [i * 1 % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [i * 1 % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 3] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 3] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 1] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 1] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 0] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 0] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % 1] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % 1] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 1) % -2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 1) % -2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 2) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 2) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 0) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 0) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + 0) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + 0) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t2 += [(i + 1) % 2] * p[i]",
      "mutated_line": "t2 += [(i + -1) % 2] * p[i]",
      "code": "import collections\n\ndef calculate_minimum_moves(n, m, b, p):\n    inf = 10 ** 20\n    r = inf\n    t1 = []\n    t2 = []\n    for i in range(m):\n        t1 += [i % 2] * p[i]\n        t2 += [(i + -1) % 2] * p[i]\n    if sorted(collections.Counter(t1).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t1[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        r = tr\n    if sorted(collections.Counter(t2).items()) == sorted(collections.Counter(b).items()):\n        tr = 0\n        pi = 0\n        for i in range(n):\n            if t2[i] != 1:\n                continue\n            while b[pi] != 1:\n                pi += 1\n            tr += abs(i - pi)\n            pi += 1\n        if r > tr:\n            r = tr\n    return r"
    }
  ]
}