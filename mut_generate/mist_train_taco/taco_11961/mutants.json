{
  "task_id": "taco_11961",
  "entry_point": "find_min_distances_to_capital",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {2: 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {2: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {0: 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {0: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {0: 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {0: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {-1: 0}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {-1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {1: 1}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 1}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {1: -1}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: -1}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dists = {1: 0}",
      "mutated_line": "dists = {1: 1}",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 1}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dists[node] == dist:",
      "mutated_line": "if dists[node] != dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] != dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if sol[fall_node] > dist:",
      "mutated_line": "if sol[fall_node] >= dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] >= dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if sol[fall_node] > dist:",
      "mutated_line": "if sol[fall_node] <= dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] <= dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if sol[fall_node] > dist:",
      "mutated_line": "if sol[fall_node] != dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] != dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (1, 1))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (1, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (-1, 1))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (-1, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (1, 1))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (1, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (0, 2))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 2))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (0, 0))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 0))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (0, 0))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 0))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heappush(Q, (0, 1))",
      "mutated_line": "heappush(Q, (0, -1))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, -1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dists[node] < dists[next_node]:",
      "mutated_line": "if dists[node] <= dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] <= dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dists[node] < dists[next_node]:",
      "mutated_line": "if dists[node] >= dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] >= dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dists[node] < dists[next_node]:",
      "mutated_line": "if dists[node] != dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] != dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists and dists[next_node] > dist + 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists and dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif dists[node] > dists[next_node]:",
      "mutated_line": "elif dists[node] >= dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] >= dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif dists[node] > dists[next_node]:",
      "mutated_line": "elif dists[node] <= dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] <= dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif dists[node] > dists[next_node]:",
      "mutated_line": "elif dists[node] != dists[next_node]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] != dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('')) for i in range(1, n + 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(2, n + 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(2, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(0, n + 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(0, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(0, n + 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(0, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(-1, n + 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(-1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n - 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n - 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n * 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n * 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node in dists or dists[next_node] > dist + 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] >= dist + 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] >= dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] <= dist + 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] <= dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] != dist + 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] != dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist - 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist - 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist * 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist * 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if sol[prev_node] > dist:",
      "mutated_line": "if sol[prev_node] >= dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] >= dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if sol[prev_node] > dist:",
      "mutated_line": "if sol[prev_node] <= dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] <= dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if sol[prev_node] > dist:",
      "mutated_line": "if sol[prev_node] != dist:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] != dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n + 2)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n + 0)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 0)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n + 0)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 0)]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return [sol.get(i, float('inf')) for i in range(1, n + 1)]",
      "mutated_line": "return [sol.get(i, float('inf')) for i in range(1, n + -1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + -1)]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist - 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist - 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist * 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist * 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist + 2",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 2\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist + 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 0\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist + 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 0\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[next_node] = dist + 1",
      "mutated_line": "dists[next_node] = dist + -1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + -1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist + 2:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 2:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist + 0:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 0:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist + 0:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 0:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if next_node not in dists or dists[next_node] > dist + 1:",
      "mutated_line": "if next_node not in dists or dists[next_node] > dist + -1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + -1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist - 1, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist - 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist * 1, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist * 1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist + 2, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 2, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist + 0, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 0, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist + 0, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + 0, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heappush(Q, (dist + 1, next_node))",
      "mutated_line": "heappush(Q, (dist + -1, next_node))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_min_distances_to_capital(n, m, roads):\n    neighbors = defaultdict(list)\n    for (u, v) in roads:\n        neighbors[u].append(v)\n    dists = {1: 0}\n    Q = []\n    heappush(Q, (0, 1))\n    while Q:\n        (dist, node) = heappop(Q)\n        if dists[node] == dist:\n            for next_node in neighbors[node]:\n                if next_node not in dists or dists[next_node] > dist + 1:\n                    dists[next_node] = dist + 1\n                    heappush(Q, (dist + -1, next_node))\n    sol = {k: v for (k, v) in dists.items()}\n    falls = []\n    climbs = defaultdict(list)\n    for (node, next_nodes) in neighbors.items():\n        for next_node in next_nodes:\n            if dists[node] < dists[next_node]:\n                climbs[next_node].append(node)\n            elif dists[node] > dists[next_node]:\n                falls.append((dists[next_node], node))\n    for (dist, fall_node) in sorted(falls):\n        if sol[fall_node] > dist:\n            sol[fall_node] = dist\n            Q = [fall_node]\n            while Q:\n                node = Q.pop()\n                for prev_node in climbs[node]:\n                    if sol[prev_node] > dist:\n                        sol[prev_node] = dist\n                        Q.append(prev_node)\n    return [sol.get(i, float('inf')) for i in range(1, n + 1)]"
    }
  ]
}