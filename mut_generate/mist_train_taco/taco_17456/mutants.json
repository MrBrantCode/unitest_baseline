{
  "task_id": "taco_17456",
  "entry_point": "calculate_euler_error",
  "mutant_count": 134,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t0 = 0",
      "mutated_line": "t0 = 1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 1\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t0 = 0",
      "mutated_line": "t0 = -1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = -1\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t0 = 0",
      "mutated_line": "t0 = 1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 1\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y0 = 1",
      "mutated_line": "y0 = 2",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 2\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y0 = 1",
      "mutated_line": "y0 = 0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 0\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y0 = 1",
      "mutated_line": "y0 = 0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 0\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y0 = 1",
      "mutated_line": "y0 = -1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = -1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "T = 1",
      "mutated_line": "T = 2",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 2\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "T = 1",
      "mutated_line": "T = 0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 0\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "T = 1",
      "mutated_line": "T = 0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 0\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "T = 1",
      "mutated_line": "T = -1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = -1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "h = T / float(n)",
      "mutated_line": "h = T * float(n)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T * float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "h = T / float(n)",
      "mutated_line": "h = T // float(n)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T // float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) * float(n + 1)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) * float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) // float(n + 1)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) // float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) * 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) * 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) // 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) // 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) + 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) + 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: (2 - exp(-4 * t)) * (2 * y)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: (2 - exp(-4 * t)) * (2 * y)\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for k in range(0, n):",
      "mutated_line": "for k in range(1, n):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(1, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for k in range(0, n):",
      "mutated_line": "for k in range(-1, n):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(-1, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for k in range(0, n):",
      "mutated_line": "for k in range(1, n):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(1, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(1, n + 1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(1, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(-1, n + 1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(-1, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(1, n + 1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(1, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n - 1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n - 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n * 1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n * 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) / 1000001.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000001.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) / 999999.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 999999.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) / 0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) / 1",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000000.0) / -1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / -1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 + exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 + exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 * exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 * exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 / y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 / y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - (2 + y)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - (2 + y)\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 ** y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 ** y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + 1) / h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) / h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append(k + 1 + h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append(k + 1 + h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + 1) ** h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) ** h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Y.append(Y[k] + h * F(X[k], Y[k]))",
      "mutated_line": "Y.append(Y[k] - h * F(X[k], Y[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] - h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Y.append(Y[k] + h * F(X[k], Y[k]))",
      "mutated_line": "Y.append(Y[k] * (h * F(X[k], Y[k])))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] * (h * F(X[k], Y[k])))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n + 2):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 2):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n + 0):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 0):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n + 0):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 0):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for k in range(0, n + 1):",
      "mutated_line": "for k in range(0, n + -1):",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + -1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) + 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) + 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append((1 + 0.5 * exp(-4 * X[k])) * (0.5 * exp(-2 * X[k])))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append((1 + 0.5 * exp(-4 * X[k])) * (0.5 * exp(-2 * X[k])))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "R.append(abs(Y[k] - Z[k]) / float(Z[k]))",
      "mutated_line": "R.append(abs(Y[k] - Z[k]) * float(Z[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) * float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "R.append(abs(Y[k] - Z[k]) / float(Z[k]))",
      "mutated_line": "R.append(abs(Y[k] - Z[k]) // float(Z[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) // float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n - 1)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n - 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n * 1)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n * 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error / 1000000.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error / 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error + 1000000.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error + 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error ** 1000000.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error ** 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 3 - exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 3 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 1 - exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 1 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 0 - exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 0 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 1 - exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 1 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: -2 - exp(-4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: -2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 3 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 3 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 1 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 1 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 0 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 0 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - 1 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 1 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 * t) - -2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - -2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k - 1) * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k - 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append(k * 1 * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append(k * 1 * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Y.append(Y[k] + h * F(X[k], Y[k]))",
      "mutated_line": "Y.append(Y[k] + h / F(X[k], Y[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h / F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Y.append(Y[k] + h * F(X[k], Y[k]))",
      "mutated_line": "Y.append(Y[k] + (h + F(X[k], Y[k])))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + (h + F(X[k], Y[k])))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Y.append(Y[k] + h * F(X[k], Y[k]))",
      "mutated_line": "Y.append(Y[k] + h ** F(X[k], Y[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h ** F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 - 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 - 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 * (0.5 * exp(-4 * X[k])) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 * (0.5 * exp(-4 * X[k])) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 / exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 / exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - (0.5 + exp(-2 * X[k])))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - (0.5 + exp(-2 * X[k])))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 ** exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 ** exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n + 2)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 2)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n + 0)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 0)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n + 0)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 0)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mean_error = sum(R) / float(n + 1)",
      "mutated_line": "mean_error = sum(R) / float(n + -1)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + -1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1000001.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000001.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 999999.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 999999.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * 1) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return floor(mean_error * 1000000.0) / 1000000.0",
      "mutated_line": "return floor(mean_error * -1000000.0) / 1000000.0",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * -1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 / t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 / t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-4 + t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 + t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp((-4) ** t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp((-4) ** t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + 2) * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 2) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + 0) * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 0) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + 0) * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 0) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "X.append((k + 1) * h)",
      "mutated_line": "X.append((k + -1) * h)",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + -1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(2 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(2 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(0 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(0 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(0 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(0 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(-1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(-1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 / exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 / exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + (0.5 + exp(-4 * X[k])) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + (0.5 + exp(-4 * X[k])) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 ** exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 ** exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 1.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 1.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - -0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - -0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 1 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 1 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - -0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - -0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "R.append(abs(Y[k] - Z[k]) / float(Z[k]))",
      "mutated_line": "R.append(abs(Y[k] + Z[k]) / float(Z[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] + Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "R.append(abs(Y[k] - Z[k]) / float(Z[k]))",
      "mutated_line": "R.append(abs(Y[k] * Z[k]) / float(Z[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] * Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(+4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(+4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 1.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 1.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + -0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + -0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 1 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 1 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + -0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + -0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 / X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 / X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 + X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 + X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp((-2) ** X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp((-2) ** X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-5 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-5 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-3 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-3 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-0 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-0 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(-1 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-1 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "F = lambda t, y: 2 - exp(-4 * t) - 2 * y",
      "mutated_line": "F = lambda t, y: 2 - exp(--4 * t) - 2 * y",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(--4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 / X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 / X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 + X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 + X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp((-4) ** X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp((-4) ** X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(+2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(+2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(+4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(+4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-3 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-3 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-1 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-1 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-0 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-0 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-1 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-1 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(--2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(--2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-5 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-5 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-3 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-3 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-0 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-0 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(-1 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(-1 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "mutated_line": "Z.append(1 + 0.5 * exp(--4 * X[k]) - 0.5 * exp(-2 * X[k]))",
      "code": "from math import floor, exp\n\ndef calculate_euler_error(n):\n    F = lambda t, y: 2 - exp(-4 * t) - 2 * y\n    t0 = 0\n    y0 = 1\n    T = 1\n    h = T / float(n)\n    X = [t0]\n    Y = [y0]\n    Z = []\n    R = []\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k], Y[k]))\n    for k in range(0, n + 1):\n        Z.append(1 + 0.5 * exp(--4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    mean_error = sum(R) / float(n + 1)\n    return floor(mean_error * 1000000.0) / 1000000.0"
    }
  ]
}