{
  "task_id": "taco_6985",
  "entry_point": "find_max_envelope_chain",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [1] / len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] / len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [1] + len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] + len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [1] ** len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] ** len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-1] / len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] / len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-1] + len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] + len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-1] ** len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] ** len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index == -1:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index == -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index != +1:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != +1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi / hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi / hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi + hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi + hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi ** hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi ** hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i - 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i - 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i * 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i * 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w or hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w or hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (1, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0, []",
      "mutated_line": "return (-1, [])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (-1, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (1, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [2] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [2] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [0] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [0] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [0] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [0] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "chain_lengths = [1] * len(valid_envelopes)",
      "mutated_line": "chain_lengths = [-1] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [-1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [+1] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [+1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] or valid_envelopes[i][1] > valid_envelopes[j][1] or chain_lengths[j] + 1 > chain_lengths[i]:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] or valid_envelopes[i][1] > valid_envelopes[j][1] or chain_lengths[j] + 1 > chain_lengths[i]:\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index != -2:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -2:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index != -0:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -0:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index != -0:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -0:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while max_index != -1:",
      "mutated_line": "while max_index != --1:",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != --1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 2) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 2) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 0) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 0) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 0) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 0) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + -1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + -1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi >= w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi >= w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi <= w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi <= w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi != w and hi > h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi != w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi >= h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi >= h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi <= h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi <= h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for i, (wi, hi) in enumerate(envelopes) if wi > w and hi > h]",
      "mutated_line": "valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi != h]",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi != h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-2] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-2] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-0] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-0] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [-0] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-0] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "back_pointers = [-1] * len(valid_envelopes)",
      "mutated_line": "back_pointers = [--1] * len(valid_envelopes)",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [--1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] >= valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] >= valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] <= valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] <= valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] != valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] != valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] >= valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] >= valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] <= valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] <= valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] != valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] != valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 >= chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 >= chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 <= chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 <= chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 != chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 != chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] - 1",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] - 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] * 1",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] * 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "chain_indices.append(valid_envelopes[max_index][3])",
      "mutated_line": "chain_indices.append(valid_envelopes[max_index][4])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][4])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "chain_indices.append(valid_envelopes[max_index][3])",
      "mutated_line": "chain_indices.append(valid_envelopes[max_index][2])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][2])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "chain_indices.append(valid_envelopes[max_index][3])",
      "mutated_line": "chain_indices.append(valid_envelopes[max_index][0])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][0])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "chain_indices.append(valid_envelopes[max_index][3])",
      "mutated_line": "chain_indices.append(valid_envelopes[max_index][1])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][1])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "chain_indices.append(valid_envelopes[max_index][3])",
      "mutated_line": "chain_indices.append(valid_envelopes[max_index][-3])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][-3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "valid_envelopes.sort(key=lambda x: x[2])",
      "mutated_line": "valid_envelopes.sort(key=lambda x: x[3])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[3])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "valid_envelopes.sort(key=lambda x: x[2])",
      "mutated_line": "valid_envelopes.sort(key=lambda x: x[1])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[1])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "valid_envelopes.sort(key=lambda x: x[2])",
      "mutated_line": "valid_envelopes.sort(key=lambda x: x[0])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[0])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "valid_envelopes.sort(key=lambda x: x[2])",
      "mutated_line": "valid_envelopes.sort(key=lambda x: x[1])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[1])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "valid_envelopes.sort(key=lambda x: x[2])",
      "mutated_line": "valid_envelopes.sort(key=lambda x: x[-2])",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[-2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] - 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] - 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] * 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] * 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] + 2",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 2\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] + 0",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 0\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] + 0",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 0\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "chain_lengths[i] = chain_lengths[j] + 1",
      "mutated_line": "chain_lengths[i] = chain_lengths[j] + -1",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + -1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][-1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][-1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][1] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][-1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][-1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (valid_envelopes[i][0] > valid_envelopes[j][0] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][1] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][2] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][2] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][0] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][0] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][0] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][0] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][-1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][-1] > valid_envelopes[j][1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][2] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][2] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][0] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][0] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][0] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][0] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "valid_envelopes[i][1] > valid_envelopes[j][1] and",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][-1] and (chain_lengths[j] + 1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][-1] and (chain_lengths[j] + 1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 2 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 2 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 0 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 0 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 0 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + 0 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "chain_lengths[j] + 1 > chain_lengths[i]):",
      "mutated_line": "if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + -1 > chain_lengths[i]):",
      "code": "def find_max_envelope_chain(n, w, h, envelopes):\n    valid_envelopes = [(wi, hi, wi * hi, i + 1) for (i, (wi, hi)) in enumerate(envelopes) if wi > w and hi > h]\n    if not valid_envelopes:\n        return (0, [])\n    valid_envelopes.sort(key=lambda x: x[2])\n    chain_lengths = [1] * len(valid_envelopes)\n    back_pointers = [-1] * len(valid_envelopes)\n    for i in range(len(valid_envelopes)):\n        for j in range(i):\n            if valid_envelopes[i][0] > valid_envelopes[j][0] and valid_envelopes[i][1] > valid_envelopes[j][1] and (chain_lengths[j] + -1 > chain_lengths[i]):\n                chain_lengths[i] = chain_lengths[j] + 1\n                back_pointers[i] = j\n    max_chain_length = max(chain_lengths)\n    max_index = chain_lengths.index(max_chain_length)\n    chain_indices = []\n    while max_index != -1:\n        chain_indices.append(valid_envelopes[max_index][3])\n        max_index = back_pointers[max_index]\n    chain_indices.reverse()\n    return (max_chain_length, chain_indices)"
    }
  ]
}