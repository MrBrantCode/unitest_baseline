{
  "task_id": "taco_4517",
  "entry_point": "count_non_decreasing_sequences",
  "mutant_count": 129,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 - 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 - 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 * 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 * 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 * 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 * 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 + 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 + 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 4):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 4):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 2):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 2):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 0):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 0):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 1):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 1):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + -3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + -3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "cl = [1]",
      "mutated_line": "cl = [2]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [2]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "cl = [1]",
      "mutated_line": "cl = [0]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [0]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "cl = [1]",
      "mutated_line": "cl = [0]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [0]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "cl = [1]",
      "mutated_line": "cl = [-1]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [-1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > len(cl):",
      "mutated_line": "if n >= len(cl):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n >= len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > len(cl):",
      "mutated_line": "if n <= len(cl):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n <= len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > len(cl):",
      "mutated_line": "if n != len(cl):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n != len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n > mod and k > mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod and k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k and k == 0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k and k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return a * b * c * mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c * mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return a * b * c + mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c + mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) - 1) * p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) * p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return select7(m + n, n, p) - 1 + p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return select7(m + n, n, p) - 1 + p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R - L - 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L - 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, (R - L) * 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, (R - L) * 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=11 ** 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=11 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=9 ** 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=9 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=0 ** 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=0 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=1 ** 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=1 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=-10 ** 6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=-10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 7 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 7 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 5 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 5 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 0 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 0 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 1 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 1 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_non_decreasing_sequences(N, L, R, mod=10**6 + 3):",
      "mutated_line": "def count_non_decreasing_sequences(N, L, R, mod=10 ** -6 + 3):",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** -6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n + 1]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n + 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n * 1]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n * 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n >= mod or k > mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n >= mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n <= mod or k > mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n <= mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n != mod or k > mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n != mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n > mod or k >= mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k >= mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n > mod or k <= mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k <= mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n > mod or k > mod:",
      "mutated_line": "if n > mod or k != mod:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k != mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 < k1 and n0 < k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 and n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return select7(n1, k1, mod) * select7(n0, k0, mod)",
      "mutated_line": "return select7(n1, k1, mod) / select7(n0, k0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) / select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return select7(n1, k1, mod) * select7(n0, k0, mod)",
      "mutated_line": "return select7(n1, k1, mod) + select7(n0, k0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) + select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return select7(n1, k1, mod) * select7(n0, k0, mod)",
      "mutated_line": "return select7(n1, k1, mod) ** select7(n0, k0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) ** select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n != k or k == 0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n != k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k != 0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k != 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 2\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 0\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 0\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return -1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod + 2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod + 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod * 2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod * 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "c = factorial2(n - k, mod)",
      "mutated_line": "c = factorial2(n + k, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n + k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "c = factorial2(n - k, mod)",
      "mutated_line": "c = factorial2(n * k, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n * k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod + 2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod + 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod * 2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod * 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return a * b / c % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b / c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return (a * b + c) % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return (a * b + c) % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return (a * b) ** c % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return (a * b) ** c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) + 1) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) + 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return select7(m + n, n, p) * 1 % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return select7(m + n, n, p) * 1 % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R + L + 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R + L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R * L + 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R * L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R - L + 2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 2, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R - L + 0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 0, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R - L + 0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 0, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solve2(N, R - L + 1, mod)",
      "mutated_line": "return solve2(N, R - L + -1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + -1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n - 2]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 2]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n - 0]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 0]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n - 0]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 0]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return cl[n - 1]",
      "mutated_line": "return cl[n - -1]",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - -1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(n1, k1) = (n // mod, k // mod)",
      "mutated_line": "(n1, k1) = (n / mod, k // mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n / mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(n1, k1) = (n // mod, k // mod)",
      "mutated_line": "(n1, k1) = (n * mod, k // mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n * mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(n1, k1) = (n // mod, k // mod)",
      "mutated_line": "(n1, k1) = (n // mod, k / mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k / mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(n1, k1) = (n // mod, k // mod)",
      "mutated_line": "(n1, k1) = (n // mod, k * mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k * mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(n0, k0) = (n % mod, k % mod)",
      "mutated_line": "(n0, k0) = (n * mod, k % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n * mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(n0, k0) = (n % mod, k % mod)",
      "mutated_line": "(n0, k0) = (n + mod, k % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n + mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(n0, k0) = (n % mod, k % mod)",
      "mutated_line": "(n0, k0) = (n % mod, k * mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k * mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(n0, k0) = (n % mod, k % mod)",
      "mutated_line": "(n0, k0) = (n % mod, k + mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k + mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 <= k1 or n0 < k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 <= k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 >= k1 or n0 < k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 >= k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 != k1 or n0 < k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 != k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 < k1 or n0 <= k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 <= k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 < k1 or n0 >= k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 >= k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n1 < k1 or n0 < k0:",
      "mutated_line": "if n1 < k1 or n0 != k0:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 != k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 1\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return -1\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 1\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == 1:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 1:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == -1:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == -1:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == 1:",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 1:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod - 3, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 3, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod - 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 1, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod - 0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 0, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod - 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 1, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "b = pow(b, mod - 2, mod)",
      "mutated_line": "b = pow(b, mod - -2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - -2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod - 3, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 3, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod - 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 1, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod - 0, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 0, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod - 1, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 1, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = pow(c, mod - 2, mod)",
      "mutated_line": "c = pow(c, mod - -2, mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - -2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return a / b * c % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a / b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return (a + b) * c % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return (a + b) * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return a * b * c % mod",
      "mutated_line": "return a ** b * c % mod",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a ** b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) - 2) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 2) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) - 0) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 0) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) - 0) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 0) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m + n, n, p) - -1) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - -1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - 1] * mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] * mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - 1] + mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] + mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m - n, n, p) - 1) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m - n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return (select7(m + n, n, p) - 1) % p",
      "mutated_line": "return (select7(m * n, n, p) - 1) % p",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m * n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) / cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) / cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1 + cl[i - 1]) % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1 + cl[i - 1]) % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) ** cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) ** cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i - 1) * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i - 1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append(i * 1 * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append(i * 1 * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 2) * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 2) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 0) * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 0) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 0) * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 0) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + -1) * cl[i - 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + -1) * cl[i - 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i + 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i + 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i * 1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i * 1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - 2] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 2] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - 0] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 0] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - 0] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - 0] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cl.append((i + 1) * cl[i - 1] % mod)",
      "mutated_line": "cl.append((i + 1) * cl[i - -1] % mod)",
      "code": "def count_non_decreasing_sequences(N, L, R, mod=10 ** 6 + 3):\n    cl = [1]\n\n    def factorial2(n, mod):\n        if n > len(cl):\n            for i in range(len(cl), n):\n                cl.append((i + 1) * cl[i - -1] % mod)\n        return cl[n - 1]\n\n    def select7(n, k, mod):\n        if n > mod or k > mod:\n            (n1, k1) = (n // mod, k // mod)\n            (n0, k0) = (n % mod, k % mod)\n            if n1 < k1 or n0 < k0:\n                return 0\n            return select7(n1, k1, mod) * select7(n0, k0, mod)\n        if n == k or k == 0:\n            return 1\n        a = factorial2(n, mod)\n        b = factorial2(k, mod)\n        b = pow(b, mod - 2, mod)\n        c = factorial2(n - k, mod)\n        c = pow(c, mod - 2, mod)\n        return a * b * c % mod\n\n    def solve2(n, m, p):\n        return (select7(m + n, n, p) - 1) % p\n    return solve2(N, R - L + 1, mod)"
    }
  ]
}