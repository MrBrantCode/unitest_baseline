{
  "task_id": "taco_5584",
  "entry_point": "generate_lexicographic_combinations",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for combination in combinations[1:]:",
      "mutated_line": "for combination in combinations[2:]:",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[2:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for combination in combinations[1:]:",
      "mutated_line": "for combination in combinations[0:]:",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[0:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for combination in combinations[1:]:",
      "mutated_line": "for combination in combinations[0:]:",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[0:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for combination in combinations[1:]:",
      "mutated_line": "for combination in combinations[-1:]:",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[-1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j | 1] for i in range(2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j | 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 * len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 * len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 + len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 + len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result.append(''.join(combination))",
      "mutated_line": "result.append('MUTATED'.join(combination))",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append('MUTATED'.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 2] for i in range(2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 2] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 0] for i in range(2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 0] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 0] for i in range(2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 0] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & -1] for i in range(2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & -1] for i in range(2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(3 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(3 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(1 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(1 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(0 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(0 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(1 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(1 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(2 ** len(set(x)))]",
      "mutated_line": "return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(-2 ** len(set(x)))]",
      "code": "def generate_lexicographic_combinations(S: str, N: int) -> list:\n\n    def generate_combinations(x: str):\n        return [[y for (j, y) in enumerate(set(x)) if i >> j & 1] for i in range(-2 ** len(set(x)))]\n    combinations = generate_combinations(S)\n    for combination in combinations:\n        combination.sort()\n    combinations.sort()\n    result = []\n    for combination in combinations[1:]:\n        result.append(''.join(combination))\n    return result"
    }
  ]
}