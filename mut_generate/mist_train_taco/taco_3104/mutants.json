{
  "task_id": "taco_3104",
  "entry_point": "calculate_valid_decision_probability",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulo = 998244353",
      "mutated_line": "modulo = 998244354",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244354\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulo = 998244353",
      "mutated_line": "modulo = 998244352",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244352\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulo = 998244353",
      "mutated_line": "modulo = 0",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 0\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulo = 998244353",
      "mutated_line": "modulo = 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 1\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulo = 998244353",
      "mutated_line": "modulo = -998244353",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = -998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] / (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] / (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] + (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] + (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] ** (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] ** (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nom = 0",
      "mutated_line": "nom = 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 1\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nom = 0",
      "mutated_line": "nom = -1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = -1\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nom = 0",
      "mutated_line": "nom = 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 1\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a * invMod(b) % modulo",
      "mutated_line": "return a * invMod(b) * modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) * modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a * invMod(b) % modulo",
      "mutated_line": "return a * invMod(b) + modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) + modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 - 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 - 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 * 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 * 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "wanted[present] += 1",
      "mutated_line": "wanted[present] -= 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] -= 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "denom = pow(n, 2, modulo)",
      "mutated_line": "denom = pow(n, 3, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 3, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "denom = pow(n, 2, modulo)",
      "mutated_line": "denom = pow(n, 1, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 1, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "denom = pow(n, 2, modulo)",
      "mutated_line": "denom = pow(n, 0, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 0, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "denom = pow(n, 2, modulo)",
      "mutated_line": "denom = pow(n, 1, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 1, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "denom = pow(n, 2, modulo)",
      "mutated_line": "denom = pow(n, -2, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, -2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "add = 0",
      "mutated_line": "add = 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 1\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "add = 0",
      "mutated_line": "add = -1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = -1\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "add = 0",
      "mutated_line": "add = 1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 1\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "add += wanted[present]",
      "mutated_line": "add -= wanted[present]",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add -= wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = (nom + add * invK) * modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) * modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = nom + add * invK + modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = nom + add * invK + modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo + 2, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo + 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo * 2, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo * 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a * invMod(b) % modulo",
      "mutated_line": "return a / invMod(b) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a / invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a * invMod(b) % modulo",
      "mutated_line": "return (a + invMod(b)) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return (a + invMod(b)) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a * invMod(b) % modulo",
      "mutated_line": "return a ** invMod(b) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a ** invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [1] * (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [1] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [-1] * (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [-1] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [1] * (10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [1] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 * 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 * 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 + 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 + 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 + 3)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 3)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 + 1)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 1)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 + 0)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 0)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 + 1)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 1)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 6 + -2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + -2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "wanted[present] += 1",
      "mutated_line": "wanted[present] += 2",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 2\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "wanted[present] += 1",
      "mutated_line": "wanted[present] += 0",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 0\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "wanted[present] += 1",
      "mutated_line": "wanted[present] += 0",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 0\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "wanted[present] += 1",
      "mutated_line": "wanted[present] += -1",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += -1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = wish[0]",
      "mutated_line": "k = wish[1]",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[1]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = wish[0]",
      "mutated_line": "k = wish[-1]",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[-1]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = wish[0]",
      "mutated_line": "k = wish[1]",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[1]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = (nom - add * invK) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom - add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = nom * (add * invK) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = nom * (add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo - 3, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 3, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo - 1, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 1, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo - 0, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 0, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo - 1, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 1, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, modulo - 2, modulo)",
      "mutated_line": "return pow(n, modulo - -2, modulo)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - -2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (11 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (11 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (9 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (9 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (0 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (0 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (1 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (1 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (-10 ** 6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (-10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 7 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 7 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 5 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 5 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 0 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 0 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** 1 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 1 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "wanted = [0] * (10 ** 6 + 2)",
      "mutated_line": "wanted = [0] * (10 ** -6 + 2)",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** -6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[2:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[2:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[0:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[0:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[0:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[0:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[-1:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[-1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[2:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[2:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[0:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[0:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[0:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[0:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for present in wish[1:]:",
      "mutated_line": "for present in wish[-1:]:",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[-1:]:\n            add += wanted[present]\n        nom = (nom + add * invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = (nom + add / invK) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add / invK) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = (nom + (add + invK)) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + (add + invK)) % modulo\n    return fracMod(nom, denom)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nom = (nom + add * invK) % modulo",
      "mutated_line": "nom = (nom + add ** invK) % modulo",
      "code": "def calculate_valid_decision_probability(n, wish_lists):\n    modulo = 998244353\n\n    def invMod(n):\n        return pow(n, modulo - 2, modulo)\n\n    def fracMod(a, b):\n        return a * invMod(b) % modulo\n    wanted = [0] * (10 ** 6 + 2)\n    for wish in wish_lists:\n        for present in wish[1:]:\n            wanted[present] += 1\n    denom = pow(n, 2, modulo)\n    nom = 0\n    for wish in wish_lists:\n        k = wish[0]\n        invK = invMod(k)\n        add = 0\n        for present in wish[1:]:\n            add += wanted[present]\n        nom = (nom + add ** invK) % modulo\n    return fracMod(nom, denom)"
    }
  ]
}