{
  "task_id": "taco_14714",
  "entry_point": "is_robot_objective_achievable",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "initial_y = 0",
      "mutated_line": "initial_y = 1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 1\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "initial_y = 0",
      "mutated_line": "initial_y = -1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = -1\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "initial_y = 0",
      "mutated_line": "initial_y = 1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 1\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)",
      "mutated_line": "return can_reach(initial_x, x, xs) or can_reach(initial_y, y, ys)",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) or can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = s.split('T')",
      "mutated_line": "for (i, e) in enumerate(s):",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(0) if xs else 1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 1\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(0) if xs else -1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else -1\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(0) if xs else 1",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 1\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return start == target",
      "mutated_line": "return start != target",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start != target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "xs = s[::2]",
      "mutated_line": "xs = s[::3]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::3]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "xs = s[::2]",
      "mutated_line": "xs = s[::1]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::1]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "xs = s[::2]",
      "mutated_line": "xs = s[::0]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::0]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "xs = s[::2]",
      "mutated_line": "xs = s[::1]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::1]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "xs = s[::2]",
      "mutated_line": "xs = s[::-2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::-2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[2::2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[2::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[0::2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[0::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[0::2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[0::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[-1::2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[-1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[1::3]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::3]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[1::1]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::1]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[1::0]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::0]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[1::1]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::1]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ys = s[1::2]",
      "mutated_line": "ys = s[1::-2]",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::-2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(1) if xs else 0",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(1) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(-1) if xs else 0",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(-1) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "initial_x = xs.pop(0) if xs else 0",
      "mutated_line": "initial_x = xs.pop(1) if xs else 0",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(1) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "xs.sort(reverse=True)",
      "mutated_line": "xs.sort(reverse=False)",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=False)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ys.sort(reverse=True)",
      "mutated_line": "ys.sort(reverse=False)",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=False)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if start <= target:",
      "mutated_line": "if start < target:",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start < target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if start <= target:",
      "mutated_line": "if start > target:",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start > target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if start <= target:",
      "mutated_line": "if start == target:",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start == target:\n                start += move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "start += move",
      "mutated_line": "start -= move",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start -= move\n            else:\n                start -= move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "start -= move",
      "mutated_line": "start += move",
      "code": "def is_robot_objective_achievable(s: str, x: int, y: int) -> bool:\n    s = s.split('T')\n    for (i, e) in enumerate(s):\n        s[i] = len(e)\n    xs = s[::2]\n    ys = s[1::2]\n    initial_x = xs.pop(0) if xs else 0\n    initial_y = 0\n    xs.sort(reverse=True)\n    ys.sort(reverse=True)\n\n    def can_reach(start, target, movements):\n        for move in movements:\n            if start <= target:\n                start += move\n            else:\n                start += move\n        return start == target\n    return can_reach(initial_x, x, xs) and can_reach(initial_y, y, ys)"
    }
  ]
}