{
  "task_id": "taco_7031",
  "entry_point": "find_shortest_route",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 9] / n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] / n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 9] + n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] + n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 9] ** n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] ** n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cost[s] = 0",
      "mutated_line": "cost[s] = 1",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 1\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cost[s] = 0",
      "mutated_line": "cost[s] = -1",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = -1\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cost[s] = 0",
      "mutated_line": "cost[s] = 1",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 1\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-1] / n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] / n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-1] + n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] + n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-1] ** n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] ** n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] != -1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] != -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while False:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if ans == []:",
      "mutated_line": "if ans != []:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans != []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if to == g:",
      "mutated_line": "if to != g:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to != g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if cost[to] < d:",
      "mutated_line": "if cost[to] <= d:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] <= d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if cost[to] < d:",
      "mutated_line": "if cost[to] >= d:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] >= d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if cost[to] < d:",
      "mutated_line": "if cost[to] != d:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] != d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] == +1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == +1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s and cur == -1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s and cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i - 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i * 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) * 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) * 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = (x_i - x_j) ** 2 + (y_i - y_j) ** 2 + 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = (x_i - x_j) ** 2 + (y_i - y_j) ** 2 + 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d < 50:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d < 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d > 50:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d > 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d == 50:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d == 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s + 1, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s + 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s * 1, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s * 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g + 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g + 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g * 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g * 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 * 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 * 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 + 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 + 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [+1] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [+1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (1, s))",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (1, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (-1, s))",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (-1, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (1, s))",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (1, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nd = d + dist",
      "mutated_line": "nd = d - dist",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d - dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nd = d + dist",
      "mutated_line": "nd = d * dist",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d * dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost[n] > nd:",
      "mutated_line": "if cost[n] >= nd:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] >= nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost[n] > nd:",
      "mutated_line": "if cost[n] <= nd:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] <= nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost[n] > nd:",
      "mutated_line": "if cost[n] != nd:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] != nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] == -2:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -2:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] == -0:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -0:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] == -0:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -0:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if pre[g] == -1:",
      "mutated_line": "if pre[g] == --1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == --1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur != s or cur == -1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur != s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur != -1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur != -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return ans[::-1]",
      "mutated_line": "return ans[::+1]",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::+1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 2, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 0, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 0, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + -1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 - (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 - (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 * (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 * (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 1.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 1.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** -0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** -0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 1",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 1\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** -0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** -0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d <= 51:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 51:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d <= 49:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 49:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d <= 0:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 0:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d <= 1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 1:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d <= 50:",
      "mutated_line": "if d <= -50:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= -50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 2, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 2, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 0, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 0, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 0, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 0, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - -1, g - 1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - -1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g - 2, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 2, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g - 0, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 0, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g - 0, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 0, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = dijkstra(G, s - 1, g - 1, n)",
      "mutated_line": "ans = dijkstra(G, s - 1, g - -1, n)",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - -1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "results.append('NA')",
      "mutated_line": "results.append('')",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [11 ** 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [11 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [9 ** 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [9 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [0 ** 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [0 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [1 ** 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [1 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [-10 ** 9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [-10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 10] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 10] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 8] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 8] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 0] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 0] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** 1] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 1] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cost = [10 ** 9] * n",
      "mutated_line": "cost = [10 ** -9] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** -9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-2] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-2] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-0] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-0] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [-0] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-0] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre = [-1] * n",
      "mutated_line": "pre = [--1] * n",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [--1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur == +1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == +1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return ans[::-1]",
      "mutated_line": "return ans[::-2]",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-2]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return ans[::-1]",
      "mutated_line": "return ans[::-0]",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-0]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return ans[::-1]",
      "mutated_line": "return ans[::-0]",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-0]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return ans[::-1]",
      "mutated_line": "return ans[::--1]",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::--1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) * 2 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) * 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = (x_i - x_j + 2 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = (x_i - x_j + 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) * 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) * 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j + 2)) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j + 2)) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i - 1 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i - 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i * 1 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i * 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur == -2:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -2:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur == -0:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -0:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur == -0:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -0:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cur == s or cur == -1:",
      "mutated_line": "if cur == s or cur == --1:",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == --1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i + x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i + x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i * x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i * x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 3 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 3 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 1 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 1 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 0 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 0 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 1 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 1 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** -2 + (y_i - y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** -2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i + y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i + y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i * y_j) ** 2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i * y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 3) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 3) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 1) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 1) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 0) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 0) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 1) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 1) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5",
      "mutated_line": "d = ((x_i - x_j) ** 2 + (y_i - y_j) ** -2) ** 0.5",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** -2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 1 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i + 2 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 2 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i + 0 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 0 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i + 0 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + 0 for i in ans])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append([i + 1 for i in ans])",
      "mutated_line": "results.append([i + -1 for i in ans])",
      "code": "import heapq\n\ndef find_shortest_route(buildings, queries):\n\n    def dijkstra(G, s, g, n):\n        cost = [10 ** 9] * n\n        cost[s] = 0\n        pre = [-1] * n\n        q = []\n        heapq.heappush(q, (0, s))\n        while q:\n            (d, to) = heapq.heappop(q)\n            if to == g:\n                break\n            if cost[to] < d:\n                continue\n            for (n, dist) in G[to]:\n                nd = d + dist\n                if cost[n] > nd:\n                    cost[n] = nd\n                    heapq.heappush(q, (nd, n))\n                    pre[n] = to\n        if pre[g] == -1:\n            return []\n        ans = [g]\n        cur = g\n        while True:\n            ans.append(pre[cur])\n            cur = pre[cur]\n            if cur == s or cur == -1:\n                break\n        return ans[::-1]\n    n = len(buildings)\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        (x_i, y_i) = buildings[i]\n        for j in range(i + 1, n):\n            (x_j, y_j) = buildings[j]\n            d = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if d <= 50:\n                G[i].append((j, d))\n                G[j].append((i, d))\n    results = []\n    for (s, g) in queries:\n        ans = dijkstra(G, s - 1, g - 1, n)\n        if ans == []:\n            results.append('NA')\n        else:\n            results.append([i + -1 for i in ans])\n    return results"
    }
  ]
}