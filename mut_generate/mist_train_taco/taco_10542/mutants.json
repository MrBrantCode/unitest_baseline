{
  "task_id": "taco_10542",
  "entry_point": "minimum_inversions",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "one_count = 0",
      "mutated_line": "one_count = 1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 1\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "one_count = 0",
      "mutated_line": "one_count = -1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = -1\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "one_count = 0",
      "mutated_line": "one_count = 1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 1\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inversion_count = 0",
      "mutated_line": "inversion_count = 1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 1\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inversion_count = 0",
      "mutated_line": "inversion_count = -1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = -1\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inversion_count = 0",
      "mutated_line": "inversion_count = 1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 1\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if char == '1':",
      "mutated_line": "if char != '1':",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char != '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "one_count += 1",
      "mutated_line": "one_count -= 1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count -= 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "inversion_count += one_count",
      "mutated_line": "inversion_count -= one_count",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count -= one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "concatenated_string = ''.join(s for _, s in ones_count_and_strings)",
      "mutated_line": "concatenated_string = 'MUTATED'.join((s for (_, s) in ones_count_and_strings))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = 'MUTATED'.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if char == '1':",
      "mutated_line": "if char == '':",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "one_count += 1",
      "mutated_line": "one_count += 2",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 2\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "one_count += 1",
      "mutated_line": "one_count += 0",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 0\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "one_count += 1",
      "mutated_line": "one_count += 0",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 0\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "one_count += 1",
      "mutated_line": "one_count += -1",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += -1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((2 for ele in s if ele == '1'))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((2 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((0 for ele in s if ele == '1'))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((0 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((0 for ele in s if ele == '1'))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((0 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((-1 for ele in s if ele == '1'))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((-1 for ele in s if ele == '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((1 for ele in s if ele != '1'))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele != '1'))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return sum(1 for ele in s if ele == '1')",
      "mutated_line": "return sum((1 for ele in s if ele == ''))",
      "code": "def minimum_inversions(N, M, binary_strings):\n\n    def count_ones(s):\n        return sum((1 for ele in s if ele == ''))\n    ones_count_and_strings = [(count_ones(s), s) for s in binary_strings]\n    ones_count_and_strings.sort()\n    concatenated_string = ''.join((s for (_, s) in ones_count_and_strings))\n    one_count = 0\n    inversion_count = 0\n    for char in concatenated_string:\n        if char == '1':\n            one_count += 1\n        else:\n            inversion_count += one_count\n    return inversion_count"
    }
  ]
}