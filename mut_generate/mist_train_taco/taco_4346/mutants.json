{
  "task_id": "taco_4346",
  "entry_point": "determine_game_outcome",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cycle = False",
      "mutated_line": "cycle = True",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = True\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) >= 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) >= 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) <= 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) <= 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) != 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) != 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 1:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > -1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > -1:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 1:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color != 2:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color != 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(2, n + 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(2, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(0, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(0, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(-1, n + 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(-1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n - 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n - 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n * 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n * 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 0 or mk.get((v, 1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 or mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while cur != (start, 0):",
      "mutated_line": "while cur == (start, 0):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur == (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 1, -1, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 1, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, -1, -1, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, -1, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 1, -1, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 1, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, +1, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, +1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -1, 2)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 2)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -1, 0)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 0)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -1, 0)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 0)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -1, -1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, -1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color == 3:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 3:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 1:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color == 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 0:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 1:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if color == 2:",
      "mutated_line": "if color == -2:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == -2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][1] != 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] != 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mk[v, player] = (prev, 1)",
      "mutated_line": "mk[v, player] = (prev, 2)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 2)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mk[v, player] = (prev, 1)",
      "mutated_line": "mk[v, player] = (prev, 0)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 0)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mk[v, player] = (prev, 1)",
      "mutated_line": "mk[v, player] = (prev, 0)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 0)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mk[v, player] = (prev, 1)",
      "mutated_line": "mk[v, player] = (prev, -1)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, -1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 2):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 2):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 0):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 0):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + -1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + -1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) != 0 and mk.get((v, 1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) != 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cur = (sol, 1)",
      "mutated_line": "cur = (sol, 2)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 2)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cur = (sol, 1)",
      "mutated_line": "cur = (sol, 0)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 0)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cur = (sol, 1)",
      "mutated_line": "cur = (sol, 0)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 0)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cur = (sol, 1)",
      "mutated_line": "cur = (sol, -1)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, -1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('', path[::-1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -2, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -2, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -0, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -0, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, -0, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -0, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "queue = [(start, 0, -1, 1)]",
      "mutated_line": "queue = [(start, 0, --1, 1)]",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, --1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mk[v, player] = (prev, 2)",
      "mutated_line": "mk[v, player] = (prev, 3)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 3)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mk[v, player] = (prev, 2)",
      "mutated_line": "mk[v, player] = (prev, 1)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 1)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mk[v, player] = (prev, 2)",
      "mutated_line": "mk[v, player] = (prev, 0)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 0)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mk[v, player] = (prev, 2)",
      "mutated_line": "mk[v, player] = (prev, 1)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 1)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mk[v, player] = (prev, 2)",
      "mutated_line": "mk[v, player] = (prev, -2)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, -2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][1] == 2:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 2:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][1] == 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 0:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][1] == 0:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 0:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][1] == -1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == -1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = True",
      "mutated_line": "cycle = False",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = False\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((v, player, prev, 2))",
      "mutated_line": "queue.append((v, player, prev, 3))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 3))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((v, player, prev, 2))",
      "mutated_line": "queue.append((v, player, prev, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 1))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((v, player, prev, 2))",
      "mutated_line": "queue.append((v, player, prev, 0))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 0))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((v, player, prev, 2))",
      "mutated_line": "queue.append((v, player, prev, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 1))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((v, player, prev, 2))",
      "mutated_line": "queue.append((v, player, prev, -2))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, -2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 1 and mk.get((v, 1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 1 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == -1 and mk.get((v, 1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == -1 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 1 and mk.get((v, 1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 1 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while cur != (start, 0):",
      "mutated_line": "while cur != (start, 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 1):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while cur != (start, 0):",
      "mutated_line": "while cur != (start, -1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, -1):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while cur != (start, 0):",
      "mutated_line": "while cur != (start, 1):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 1):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 + cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 + cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 * cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 * cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"Draw\", None)",
      "mutated_line": "return ('', None)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (\"Lose\", None)",
      "mutated_line": "return ('', None)",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][2] == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][2] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][0] == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][0] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][0] == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][0] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if mk[v, player][1] == 1:",
      "mutated_line": "if mk[v, player][-1] == 1:",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][-1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 + player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 + player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 * player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 * player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 - player, v, 2))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 2))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 - player, v, 0))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 0))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 - player, v, 0))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 0))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 1 - player, v, -1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, -1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 2), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 2), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 0), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 0), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 0), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 0), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):",
      "mutated_line": "if len(graph.get(v, [])) == 0 and mk.get((v, -1), None):",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, -1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[1], 1 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[1], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[-1], 1 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[-1], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[1], 1 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[1], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 2 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 2 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 0 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 0 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 0 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 0 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], -1 - cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], -1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path.append(cur[0])",
      "mutated_line": "path.append(cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[1])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path.append(cur[0])",
      "mutated_line": "path.append(cur[-1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[-1])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path.append(cur[0])",
      "mutated_line": "path.append(cur[1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[1])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('Win', path[::+1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::+1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 2 - player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 2 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 0 - player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 0 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, 0 - player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 0 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((w, 1 - player, v, 1))",
      "mutated_line": "queue.append((w, -1 - player, v, 1))",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, -1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 - cur[2])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[2])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 - cur[0])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[0])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 - cur[0])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[0])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur = (mk.get(cur)[0], 1 - cur[1])",
      "mutated_line": "cur = (mk.get(cur)[0], 1 - cur[-1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[-1])\n            path.append(cur[0])\n        return ('Win', path[::-1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('Win', path[::-2])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-2])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('Win', path[::-0])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-0])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('Win', path[::-0])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::-0])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Win\", path[::-1])",
      "mutated_line": "return ('Win', path[::--1])",
      "code": "def determine_game_outcome(n, m, graph, start):\n    mk = {}\n    queue = [(start, 0, -1, 1)]\n    cycle = False\n    while len(queue) > 0:\n        (v, player, prev, color) = queue.pop()\n        if color == 2:\n            mk[v, player] = (prev, 2)\n            continue\n        if mk.get((v, player), None):\n            if mk[v, player][1] == 1:\n                cycle = True\n            continue\n        mk[v, player] = (prev, 1)\n        queue.append((v, player, prev, 2))\n        for w in graph.get(v, []):\n            queue.append((w, 1 - player, v, 1))\n    sol = None\n    for v in range(1, n + 1):\n        if len(graph.get(v, [])) == 0 and mk.get((v, 1), None):\n            sol = v\n            break\n    if sol:\n        path = [sol]\n        cur = (sol, 1)\n        while cur != (start, 0):\n            cur = (mk.get(cur)[0], 1 - cur[1])\n            path.append(cur[0])\n        return ('Win', path[::--1])\n    elif cycle:\n        return ('Draw', None)\n    else:\n        return ('Lose', None)"
    }
  ]
}