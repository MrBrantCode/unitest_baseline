{
  "task_id": "taco_15800",
  "entry_point": "minimal_illumination_cost",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 or blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 or blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-1] / n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] / n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-1] + n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] + n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-1] ** n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] ** n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "MAX_COST = 10000000000000.0",
      "mutated_line": "MAX_COST = 10000000000001.0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000001.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "MAX_COST = 10000000000000.0",
      "mutated_line": "MAX_COST = 9999999999999.0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 9999999999999.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "MAX_COST = 10000000000000.0",
      "mutated_line": "MAX_COST = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "MAX_COST = 10000000000000.0",
      "mutated_line": "MAX_COST = 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 1\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "MAX_COST = 10000000000000.0",
      "mutated_line": "MAX_COST = -10000000000000.0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = -10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_inr = 0",
      "mutated_line": "max_inr = 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 1\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_inr = 0",
      "mutated_line": "max_inr = -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = -1\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_inr = 0",
      "mutated_line": "max_inr = 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 1\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m >= 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m >= 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m <= 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m <= 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m != 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m != 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m >= 0 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m >= 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m <= 0 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m <= 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m != 0 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m != 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[0] != 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] != 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return +1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] != -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] != -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m > 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 1:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m > -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > -1:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m > 0:",
      "mutated_line": "if m > 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 1:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inr = 1",
      "mutated_line": "inr = 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 2\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inr = 1",
      "mutated_line": "inr = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 0\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inr = 1",
      "mutated_line": "inr = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 0\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inr = 1",
      "mutated_line": "inr = -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = -1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr >= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr >= max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr <= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr <= max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr != max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr != max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i < max_inr:",
      "mutated_line": "if i <= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i <= max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i < max_inr:",
      "mutated_line": "if i >= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i >= max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i < max_inr:",
      "mutated_line": "if i != max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i != max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if best_cost[test] >= min_cost:",
      "mutated_line": "if best_cost[test] > min_cost:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] > min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if best_cost[test] >= min_cost:",
      "mutated_line": "if best_cost[test] < min_cost:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] < min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if best_cost[test] >= min_cost:",
      "mutated_line": "if best_cost[test] == min_cost:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] == min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test - 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test - 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test * 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test * 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 1\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pos = 0",
      "mutated_line": "pos = -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = -1\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 1\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 2\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 0\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 0\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = -1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while pos < n:",
      "mutated_line": "while pos <= n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos <= n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while pos < n:",
      "mutated_line": "while pos >= n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos >= n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while pos < n:",
      "mutated_line": "while pos != n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos != n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count -= 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost <= MAX_COST else -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost <= MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost >= MAX_COST else -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost >= MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost != MAX_COST else -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost != MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost < MAX_COST else +1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else +1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 1 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 1 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > -1 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > -1 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 1 and blocked_positions[0] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 1 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[0] == 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 1:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[0] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == -1:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[0] == 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 1:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -2\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -0\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -0\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return --1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [+1] * n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [+1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] == +1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == +1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos + 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos + 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos * 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos * 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prev = blocked_positions[0]",
      "mutated_line": "prev = blocked_positions[1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[1]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prev = blocked_positions[0]",
      "mutated_line": "prev = blocked_positions[-1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[-1]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prev = blocked_positions[0]",
      "mutated_line": "prev = blocked_positions[1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[1]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(2, m):",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(2, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(0, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(0, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(-1, m):",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(-1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] != prev + 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] != prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "inr += 1",
      "mutated_line": "inr -= 1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr -= 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test + 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 2\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test + 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 0\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test + 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 0\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t_size = test + 1",
      "mutated_line": "t_size = test + -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + -1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_pos = pos + t_size",
      "mutated_line": "new_pos = pos - t_size",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos - t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_pos = pos + t_size",
      "mutated_line": "new_pos = pos * t_size",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos * t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if new_pos >= n:",
      "mutated_line": "if new_pos > n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos > n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if new_pos >= n:",
      "mutated_line": "if new_pos < n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos < n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if new_pos >= n:",
      "mutated_line": "if new_pos == n:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos == n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] == -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 2\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 0\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 0\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += -1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_cost = min(min_cost, lamp_costs[test] * count)",
      "mutated_line": "min_cost = min(min_cost, lamp_costs[test] / count)",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] / count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_cost = min(min_cost, lamp_costs[test] * count)",
      "mutated_line": "min_cost = min(min_cost, lamp_costs[test] + count)",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] + count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_cost = min(min_cost, lamp_costs[test] * count)",
      "mutated_line": "min_cost = min(min_cost, lamp_costs[test] ** count)",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] ** count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost < MAX_COST else -2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -2"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost < MAX_COST else -0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost < MAX_COST else -0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return min_cost if min_cost < MAX_COST else -1",
      "mutated_line": "return min_cost if min_cost < MAX_COST else --1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else --1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[1] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[1] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[-1] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[-1] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m > 0 and blocked_positions[0] == 0:",
      "mutated_line": "if m > 0 and blocked_positions[1] == 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[1] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-2] * n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-2] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-0] * n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-0] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [-0] * n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-0] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "block = [-1] * n",
      "mutated_line": "block = [--1] * n",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [--1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos + 1] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos + 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos * 1] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos * 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] == -2:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -2:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] == -0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -0:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] == -0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -0:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 1] == --1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == --1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos - 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 2\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos - 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 0\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos - 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 0\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "block[pos] = pos - 1",
      "mutated_line": "block[pos] = pos - -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - -1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos + 1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos + 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos * 1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos * 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev - 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev - 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev * 1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev * 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inr += 1",
      "mutated_line": "inr += 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 2\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inr += 1",
      "mutated_line": "inr += 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 0\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inr += 1",
      "mutated_line": "inr += 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 0\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inr += 1",
      "mutated_line": "inr += -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += -1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr >= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr >= max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr <= max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr <= max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if inr > max_inr:",
      "mutated_line": "if inr != max_inr:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr != max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inr = 1",
      "mutated_line": "inr = 2",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 2\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inr = 1",
      "mutated_line": "inr = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 0\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inr = 1",
      "mutated_line": "inr = 0",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 0\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inr = 1",
      "mutated_line": "inr = -1",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = -1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] / -(-n // (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] / -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] + -(-n // (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] + -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] ** (-(-n // (i + 1))))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] ** (-(-n // (i + 1))))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] != +1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != +1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if block[new_pos] <= pos:",
      "mutated_line": "if block[new_pos] < pos:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] < pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if block[new_pos] <= pos:",
      "mutated_line": "if block[new_pos] > pos:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] > pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if block[new_pos] <= pos:",
      "mutated_line": "if block[new_pos] == pos:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] == pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 2] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 2] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 0] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 0] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - 0] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 0] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if block[pos - 1] == -1:",
      "mutated_line": "if block[pos - -1] == -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - -1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos - 2]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 2]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos - 0]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 0]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos - 0]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 0]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "block[pos] = block[pos - 1]",
      "mutated_line": "block[pos] = block[pos - -1]",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - -1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev + 2:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 2:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev + 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 0:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev + 0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 0:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if blocked_positions[i] == prev + 1:",
      "mutated_line": "if blocked_positions[i] == prev + -1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + -1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * +(-n // (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * +(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] != -2:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -2:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] != -0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -0:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] != -0:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -0:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if block[new_pos] != -1:",
      "mutated_line": "if block[new_pos] != --1:",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != --1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n / (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n / (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n * (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n * (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "raise Exception('smth went wrong')",
      "mutated_line": "raise Exception('')",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(+n // (i + 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(+n // (i + 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i - 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i - 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i * 1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i * 1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 2)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 2)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 0)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 0)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 0)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + 0)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "best_cost.append(lamp_costs[i] * -(-n // (i + 1)))",
      "mutated_line": "best_cost.append(lamp_costs[i] * -(-n // (i + -1)))",
      "code": "def minimal_illumination_cost(n, m, k, blocked_positions, lamp_costs):\n    if m > 0 and blocked_positions[0] == 0:\n        return -1\n    block = [-1] * n\n    for pos in blocked_positions:\n        if block[pos - 1] == -1:\n            block[pos] = pos - 1\n        else:\n            block[pos] = block[pos - 1]\n    MAX_COST = 10000000000000.0\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = blocked_positions[0]\n        for i in range(1, m):\n            if blocked_positions[i] == prev + 1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = blocked_positions[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(lamp_costs[i] * -(-n // (i + -1)))\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i\n        if best_cost[test] >= min_cost:\n            continue\n        t_size = test + 1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, lamp_costs[test] * count)\n    return min_cost if min_cost < MAX_COST else -1"
    }
  ]
}