{
  "task_id": "taco_7418",
  "entry_point": "min_operations_for_mex",
  "mutant_count": 163,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] / (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] / (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] + (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] + (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] ** (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] ** (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "buc[a[i]] += 1",
      "mutated_line": "buc[a[i]] -= 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] -= 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[0] != 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] != 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] > 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] > 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] < 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] < 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] == 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] == 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] > 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] > 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] < 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] < 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] == 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] == 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 1\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost = 0",
      "mutated_line": "cost = -1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = -1\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 1\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n - 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n - 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n * 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n * 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "buc[a[i]] += 1",
      "mutated_line": "buc[a[i]] += 2",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 2\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "buc[a[i]] += 1",
      "mutated_line": "buc[a[i]] += 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 0\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "buc[a[i]] += 1",
      "mutated_line": "buc[a[i]] += 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 0\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "buc[a[i]] += 1",
      "mutated_line": "buc[a[i]] += -1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += -1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[0] == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 1:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[0] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == -1:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[0] == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 1:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] >= 3:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 3:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 1:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] >= 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 0:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 1:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[0] >= -2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= -2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] >= 3:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 3:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 1:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] >= 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 0:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 1:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[1] >= -2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= -2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(3, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(1, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(0, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(1, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(-2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n - 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n * 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] != -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] != -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] > 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] > 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] < 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] < 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] == 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] == 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [1] * (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [1] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [-1] * (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [-1] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [1] * (n + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [1] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n + 2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 2)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n + 0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 0)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n + 0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 0)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "buc = [0] * (n + 1)",
      "mutated_line": "buc = [0] * (n + -1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + -1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = [buc[0]]",
      "mutated_line": "ans = [buc[1]]",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[1]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = [buc[0]]",
      "mutated_line": "ans = [buc[-1]]",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[-1]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = [buc[0]]",
      "mutated_line": "ans = [buc[1]]",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[1]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[1] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[-1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[-1] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if buc[0] == 0:",
      "mutated_line": "if buc[1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[1] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(+1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(+1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[1] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[1] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[-1] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[-1] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if buc[0] >= 2:",
      "mutated_line": "if buc[1] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[1] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(tw, 0)",
      "mutated_line": "heapq.heappush(tw, 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 1)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(tw, 0)",
      "mutated_line": "heapq.heappush(tw, -1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, -1)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(tw, 0)",
      "mutated_line": "heapq.heappush(tw, 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 1)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[2] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[2] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[0] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[0] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[0] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[0] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if buc[1] >= 2:",
      "mutated_line": "if buc[-1] >= 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[-1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "heapq.heappush(tw, -1)",
      "mutated_line": "heapq.heappush(tw, +1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, +1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 2):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 0):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 0):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + -1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] == +1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == +1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 1] != 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] != 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "buc[now] -= 1",
      "mutated_line": "buc[now] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] += 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 1] -= 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] -= 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost -= abs(now - i + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost -= abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] >= 3:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 3:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 1:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] >= 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 0:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 1:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if buc[i] >= 2:",
      "mutated_line": "if buc[i] >= -2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= -2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans.append(cost + buc[i])",
      "mutated_line": "ans.append(cost - buc[i])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost - buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans.append(cost + buc[i])",
      "mutated_line": "ans.append(cost * buc[i])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost * buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-2)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-0)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-0)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(--1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(--1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append(buc[1])",
      "mutated_line": "ans.append(buc[2])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[2])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append(buc[1])",
      "mutated_line": "ans.append(buc[0])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[0])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append(buc[1])",
      "mutated_line": "ans.append(buc[0])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[0])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append(buc[1])",
      "mutated_line": "ans.append(buc[-1])",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[-1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "heapq.heappush(tw, -1)",
      "mutated_line": "heapq.heappush(tw, -2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -2)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "heapq.heappush(tw, -1)",
      "mutated_line": "heapq.heappush(tw, -0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -0)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "heapq.heappush(tw, -1)",
      "mutated_line": "heapq.heappush(tw, -0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -0)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "heapq.heappush(tw, -1)",
      "mutated_line": "heapq.heappush(tw, --1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, --1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[+1] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[+1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] == -2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -2:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] == -0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -0:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] == -0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -0:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-1] == --1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == --1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(+1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(+1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 1] == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 1:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 1] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == -1:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 1] == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 1:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(tw) == 0:",
      "mutated_line": "if len(tw) != 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) != 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "now = -now",
      "mutated_line": "now = +now",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = +now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "buc[now] -= 1",
      "mutated_line": "buc[now] -= 2",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 2\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "buc[now] -= 1",
      "mutated_line": "buc[now] -= 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 0\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "buc[now] -= 1",
      "mutated_line": "buc[now] -= 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 0\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "buc[now] -= 1",
      "mutated_line": "buc[now] -= -1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= -1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 1] += 2",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 2\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 1] += 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 0\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 1] += 0",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 0\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 1] += -1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += -1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] > 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] > 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] < 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] < 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] == 2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] == 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "heapq.heappush(tw, -i)",
      "mutated_line": "heapq.heappush(tw, +i)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, +i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-2] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-2] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-0] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-0] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[-0] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-0] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if ans[-1] == -1:",
      "mutated_line": "if ans[--1] == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[--1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-2)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-0)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-0)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(--1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(--1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i + 1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i + 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i * 1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i * 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(tw) == 0:",
      "mutated_line": "if len(tw) == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 1:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(tw) == 0:",
      "mutated_line": "if len(tw) == -1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == -1:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(tw) == 0:",
      "mutated_line": "if len(tw) == 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 1:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i + 1] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i + 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i * 1] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i * 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now - i - 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i - 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs((now - i) * 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs((now - i) * 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] >= 3:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 3:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 1:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] >= 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 0:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] >= 1:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 1:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if buc[now] >= 2:",
      "mutated_line": "if buc[now] >= -2:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= -2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 2] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 2] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 0] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 0] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - 0] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 0] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif buc[i - 1] == 0:",
      "mutated_line": "elif buc[i - -1] == 0:",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - -1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(+1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(+1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 2] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 2] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 0] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 0] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - 0] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 0] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "buc[i - 1] += 1",
      "mutated_line": "buc[i - -1] += 1",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - -1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now + i + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now + i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now * i + 1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now * i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now - i + 2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 2)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now - i + 0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 0)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now - i + 0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 0)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cost += abs(now - i + 1)",
      "mutated_line": "cost += abs(now - i + -1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + -1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "heapq.heappush(tw, -now)",
      "mutated_line": "heapq.heappush(tw, +now)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, +now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-2)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-2)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-0)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(-0)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(--1)",
      "code": "def min_operations_for_mex(n, a):\n    \"\"\"\n    Calculate the minimum number of operations required to make the MEX of the array equal to each value from 0 to n.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of non-negative integers.\n\n    Returns:\n    list of int: A list of integers where the i-th element represents the minimum number of operations\n                required to make the MEX of the array equal to i, or -1 if it is not possible.\n    \"\"\"\n    buc = [0] * (n + 1)\n    for i in range(n):\n        buc[a[i]] += 1\n    ans = [buc[0]]\n    tw = []\n    if buc[0] == 0:\n        ans.append(-1)\n    else:\n        ans.append(buc[1])\n    if buc[0] >= 2:\n        heapq.heappush(tw, 0)\n    if buc[1] >= 2:\n        heapq.heappush(tw, -1)\n    cost = 0\n    for i in range(2, n + 1):\n        if ans[-1] == -1:\n            ans.append(-1)\n            continue\n        elif buc[i - 1] == 0:\n            if len(tw) == 0:\n                ans.append(--1)\n                continue\n            now = heapq.heappop(tw)\n            now = -now\n            buc[now] -= 1\n            buc[i - 1] += 1\n            cost += abs(now - i + 1)\n            if buc[now] >= 2:\n                heapq.heappush(tw, -now)\n        if buc[i] >= 2:\n            heapq.heappush(tw, -i)\n        ans.append(cost + buc[i])\n    return ans"
    }
  ]
}