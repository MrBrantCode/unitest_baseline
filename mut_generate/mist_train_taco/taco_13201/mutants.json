{
  "task_id": "taco_13201",
  "entry_point": "calculate_max_total_friendships",
  "mutant_count": 103,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "res += lost * cur",
      "mutated_line": "res -= lost * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res -= lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lost = 0",
      "mutated_line": "lost = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 1\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lost = 0",
      "mutated_line": "lost = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = -1\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lost = 0",
      "mutated_line": "lost = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 1\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u += 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v += 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "no = 1",
      "mutated_line": "no = 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 2\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "no = 1",
      "mutated_line": "no = 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 0\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "no = 1",
      "mutated_line": "no = 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 0\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "no = 1",
      "mutated_line": "no = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = -1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 1\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = -1\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 1\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 1\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "cur = 0",
      "mutated_line": "cur = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = -1\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 1\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res -= grow(v) + (v - 1) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res -= grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur -= v * (v - 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur -= v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += lost * cur",
      "mutated_line": "res += lost / cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost / cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += lost * cur",
      "mutated_line": "res += lost + cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost + cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += lost * cur",
      "mutated_line": "res += lost ** cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost ** cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 1\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = -1\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 1\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res -= i * (i + 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res -= i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x is not z:",
      "mutated_line": "if x is z:",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "while z and type(z) == list:",
      "mutated_line": "while z or type(z) == list:",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z or type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x is not z:",
      "mutated_line": "if x is z:",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 2\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 0\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 0\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= -1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 2\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 0\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 0\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= -1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if mu is not mv:",
      "mutated_line": "if mu is mv:",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "lost += 1",
      "mutated_line": "lost -= 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost -= 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "no += 1",
      "mutated_line": "no -= 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no -= 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "dic[z] += 1",
      "mutated_line": "dic[z] -= 1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] -= 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) - (v - 1) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) - (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) * ((v - 1) * cur)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) * ((v - 1) * cur)\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v / (v - 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v / (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v + (v - 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v + (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v ** (v - 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v ** (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(2, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(0, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(0, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(-1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i / (i + 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i / (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i + (i + 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i + (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i ** (i + 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i ** (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while z and type(z) == list:",
      "mutated_line": "while z and type(z) != list:",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) != list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lost += 1",
      "mutated_line": "lost += 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 2\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lost += 1",
      "mutated_line": "lost += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 0\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lost += 1",
      "mutated_line": "lost += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 0\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lost += 1",
      "mutated_line": "lost += -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += -1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "no += 1",
      "mutated_line": "no += 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 2\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "no += 1",
      "mutated_line": "no += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 0\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "no += 1",
      "mutated_line": "no += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 0\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "no += 1",
      "mutated_line": "no += -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += -1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dic[z] = 1",
      "mutated_line": "dic[z] = 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 2\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dic[z] = 1",
      "mutated_line": "dic[z] = 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 0\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dic[z] = 1",
      "mutated_line": "dic[z] = 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 0\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dic[z] = 1",
      "mutated_line": "dic[z] = -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = -1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dic[z] += 1",
      "mutated_line": "dic[z] += 2",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 2\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dic[z] += 1",
      "mutated_line": "dic[z] += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 0\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dic[z] += 1",
      "mutated_line": "dic[z] += 0",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 0\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dic[z] += 1",
      "mutated_line": "dic[z] += -1",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += -1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for v in sorted(dic.values(), reverse=True):",
      "mutated_line": "for v in sorted(dic.values(), reverse=False):",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=False):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 1) / cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) / cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 1 + cur)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1 + cur)\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 1) ** cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) ** cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v + 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v + 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v * 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v * 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i - 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i - 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i * 1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i * 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[1]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[-1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[-1]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[1]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[0] = z",
      "mutated_line": "x[1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[1] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[0] = z",
      "mutated_line": "x[-1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[-1] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[0] = z",
      "mutated_line": "x[1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[1] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[1]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[-1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[-1]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "z = z[0]",
      "mutated_line": "z = z[1]",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[1]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x[0] = z",
      "mutated_line": "x[1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[1] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x[0] = z",
      "mutated_line": "x[-1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[-1] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x[0] = z",
      "mutated_line": "x[1] = z",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[1] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v + 1) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v + 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + v * 1 * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + v * 1 * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v - 2)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 2)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v - 0)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 0)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v - 0)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 0)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "cur += v * (v - 1)",
      "mutated_line": "cur += v * (v - -1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - -1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i + 2)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 2)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i + 0)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 0)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i + 0)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 0)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res += i * (i + 1)",
      "mutated_line": "res += i * (i + -1)",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + -1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 2) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 2) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 0) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 0) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - 0) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - 0) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "res += grow(v) + (v - 1) * cur",
      "mutated_line": "res += grow(v) + (v - -1) * cur",
      "code": "def calculate_max_total_friendships(n, m, friendships):\n\n    def grow(n):\n        res = 0\n        for i in range(1, n):\n            res += i * (i + 1)\n        return res\n\n    def mark(x):\n        z = x\n        while z:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n\n    def mark2(x):\n        z = x\n        while z and type(z) == list:\n            z = z[0]\n        if x is not z:\n            x[0] = z\n        return z\n    work = [[] for i in range(n)]\n    lost = 0\n    for (u, v) in friendships:\n        u -= 1\n        v -= 1\n        mu = mark(work[u])\n        mv = mark(work[v])\n        if mu is not mv:\n            mu.append(mv)\n        else:\n            lost += 1\n    no = 1\n    dic = {}\n    for i in range(n):\n        z = mark2(work[i])\n        if not z:\n            z.append(no)\n            z = no\n            no += 1\n            dic[z] = 1\n        else:\n            dic[z] += 1\n    res = 0\n    cur = 0\n    for v in sorted(dic.values(), reverse=True):\n        res += grow(v) + (v - -1) * cur\n        cur += v * (v - 1)\n    res += lost * cur\n    return res"
    }
  ]
}