{
  "task_id": "taco_14000",
  "entry_point": "find_lexicographically_smallest_permutation",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [-1] - a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] - a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [-1] * a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] * a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = False\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] / (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] / (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] + (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] + (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] ** (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] ** (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edges = 0",
      "mutated_line": "edges = 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 1\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edges = 0",
      "mutated_line": "edges = -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = -1\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edges = 0",
      "mutated_line": "edges = 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 1\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] / (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] / (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] + (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] + (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] ** (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] ** (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 2\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 0\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 0\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = -1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p -= 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges >= 0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges >= 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges <= 0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges <= 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges != 0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges != 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n - 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n - 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n * 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n * 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(2, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(0, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(0, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(-1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n - 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n * 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] != -1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] != -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return +1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n - 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n - 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n * 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n * 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 2\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 0\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 0\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += -1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "indegs[nxt] -= 1",
      "mutated_line": "indegs[nxt] += 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] += 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "edges -= 1",
      "mutated_line": "edges += 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges += 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges > 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 1:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges > -1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > -1:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if edges > 0:",
      "mutated_line": "if edges > 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 1:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return +1\n    return res[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [+1] + a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [+1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [1] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [-1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [-1] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [1] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n + 2)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 2)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n + 0)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 0)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n + 0)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 0)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "indegs = [0] * (n + 1)",
      "mutated_line": "indegs = [0] * (n + -1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + -1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 2):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 0):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 0):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + -1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] == +1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == +1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif a[i] >= i:",
      "mutated_line": "elif a[i] > i:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] > i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif a[i] >= i:",
      "mutated_line": "elif a[i] < i:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] < i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif a[i] >= i:",
      "mutated_line": "elif a[i] == i:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] == i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -2\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -0\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -0\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return --1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 1) if indegs[i] != 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] != 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [1] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [-1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [-1] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [1] * (n + 1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [1] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n + 2)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 2)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n + 0)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 0)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n + 0)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 0)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = [0] * (n + 1)",
      "mutated_line": "res = [0] * (n + -1)",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + -1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "indegs[nxt] -= 1",
      "mutated_line": "indegs[nxt] -= 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 2\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "indegs[nxt] -= 1",
      "mutated_line": "indegs[nxt] -= 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 0\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "indegs[nxt] -= 1",
      "mutated_line": "indegs[nxt] -= 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 0\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "indegs[nxt] -= 1",
      "mutated_line": "indegs[nxt] -= -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= -1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "edges -= 1",
      "mutated_line": "edges -= 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 2\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "edges -= 1",
      "mutated_line": "edges -= 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 0\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "edges -= 1",
      "mutated_line": "edges -= 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 0\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "edges -= 1",
      "mutated_line": "edges -= -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= -1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if indegs[nxt] == 0:",
      "mutated_line": "if indegs[nxt] != 0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] != 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -2\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -0\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -0\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return --1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return res[1:]",
      "mutated_line": "return res[2:]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return res[1:]",
      "mutated_line": "return res[0:]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return res[1:]",
      "mutated_line": "return res[0:]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return res[1:]",
      "mutated_line": "return res[-1:]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[-1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [-2] + a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-2] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [-0] + a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-0] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [-0] + a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-0] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = [-1] + a  # Adjusting the array to be 1-indexed",
      "mutated_line": "a = [--1] + a",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [--1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n - 1)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n - 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n * 1)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n * 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] == -2:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -2:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] == -0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -0:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] == -0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -0:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if a[i] == -1:",
      "mutated_line": "if a[i] == --1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == --1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = True\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif a[i] != 0:",
      "mutated_line": "elif a[i] == 0:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] == 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "indegs[a[i]] += 1",
      "mutated_line": "indegs[a[i]] -= 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] -= 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "edges += 1",
      "mutated_line": "edges -= 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges -= 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(2, n + 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(2, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(0, n + 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(0, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(0, n + 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(0, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(-1, n + 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(-1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n - 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n - 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n * 1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n * 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 1]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 1]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 1) if indegs[i] == -1]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == -1]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 1]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 1]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if indegs[nxt] == 0:",
      "mutated_line": "if indegs[nxt] == 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 1:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if indegs[nxt] == 0:",
      "mutated_line": "if indegs[nxt] == -1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == -1:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if indegs[nxt] == 0:",
      "mutated_line": "if indegs[nxt] == 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 1:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n + 2)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 2)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 0)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 0)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "g = [[] for _ in range(n + -1)]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + -1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[i] != 0:",
      "mutated_line": "elif a[i] != 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 1:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[i] != 0:",
      "mutated_line": "elif a[i] != -1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != -1:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[i] != 0:",
      "mutated_line": "elif a[i] != 1:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 1:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegs[a[i]] += 1",
      "mutated_line": "indegs[a[i]] += 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 2\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegs[a[i]] += 1",
      "mutated_line": "indegs[a[i]] += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 0\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegs[a[i]] += 1",
      "mutated_line": "indegs[a[i]] += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 0\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegs[a[i]] += 1",
      "mutated_line": "indegs[a[i]] += -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += -1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += 1",
      "mutated_line": "edges += 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 2\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += 1",
      "mutated_line": "edges += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 0\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += 1",
      "mutated_line": "edges += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 0\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += 1",
      "mutated_line": "edges += -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += -1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts or pts[-1] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts or pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "indegs[i] += 1",
      "mutated_line": "indegs[i] -= 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] -= 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "edges += 1",
      "mutated_line": "edges -= 1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges -= 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 2) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 2) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 0) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 0) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + 0) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 0) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [i for i in range(1, n + 1) if indegs[i] == 0]",
      "mutated_line": "hq = [i for i in range(1, n + -1) if indegs[i] == 0]",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + -1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-1] >= a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] >= a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-1] <= a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] <= a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-1] != a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] != a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "indegs[i] += 1",
      "mutated_line": "indegs[i] += 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 2\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "indegs[i] += 1",
      "mutated_line": "indegs[i] += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 0\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "indegs[i] += 1",
      "mutated_line": "indegs[i] += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 0\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "indegs[i] += 1",
      "mutated_line": "indegs[i] += -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += -1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges += 1",
      "mutated_line": "edges += 2",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 2\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges += 1",
      "mutated_line": "edges += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 0\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges += 1",
      "mutated_line": "edges += 0",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 0\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges += 1",
      "mutated_line": "edges += -1",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += -1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[+1] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[+1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-2] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-2] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-0] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-0] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[-0] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[-0] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while pts and pts[-1] > a[i]:",
      "mutated_line": "while pts and pts[--1] > a[i]:",
      "code": "import heapq\n\ndef find_lexicographically_smallest_permutation(n, a):\n    a = [-1] + a\n    g = [[] for _ in range(n + 1)]\n    found = True\n    pts = []\n    indegs = [0] * (n + 1)\n    edges = 0\n    for i in range(1, n + 1):\n        if a[i] == -1:\n            continue\n        elif a[i] >= i:\n            found = False\n            break\n        elif a[i] != 0:\n            g[i].append(a[i])\n            indegs[a[i]] += 1\n            edges += 1\n            while pts and pts[--1] > a[i]:\n                j = pts.pop()\n                g[j].append(i)\n                indegs[i] += 1\n                edges += 1\n        pts.append(i)\n    if not found:\n        return -1\n    hq = [i for i in range(1, n + 1) if indegs[i] == 0]\n    res = [0] * (n + 1)\n    p = 1\n    while hq:\n        cur = heapq.heappop(hq)\n        res[cur] = p\n        p += 1\n        for nxt in g[cur]:\n            indegs[nxt] -= 1\n            edges -= 1\n            if indegs[nxt] == 0:\n                heapq.heappush(hq, nxt)\n    if edges > 0:\n        return -1\n    return res[1:]"
    }
  ]
}