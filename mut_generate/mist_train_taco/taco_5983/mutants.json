{
  "task_id": "taco_5983",
  "entry_point": "password_cracker",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "_end = '_end_'",
      "mutated_line": "_end = ''",
      "code": "class Trie:\n    _end = ''\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = ''",
      "mutated_line": "ans = 'MUTATED'",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = 'MUTATED'\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "ans += letter",
      "mutated_line": "ans -= letter",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans -= letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "store = [None] * len(loginattempt)",
      "mutated_line": "store = [None] / len(loginattempt)",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] / len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "store = [None] * len(loginattempt)",
      "mutated_line": "store = [None] + len(loginattempt)",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] + len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "store = [None] * len(loginattempt)",
      "mutated_line": "store = [None] ** len(loginattempt)",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] ** len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if letter not in current_dict:",
      "mutated_line": "if letter in current_dict:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if letter not in current_dict:",
      "mutated_line": "if letter in current_dict:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if self._end in current_dict:",
      "mutated_line": "if self._end not in current_dict:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end not in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if store[0]:",
      "mutated_line": "if store[1]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[1]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if store[0]:",
      "mutated_line": "if store[-1]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[-1]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if store[0]:",
      "mutated_line": "if store[1]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[1]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 'WRONG PASSWORD'",
      "mutated_line": "return ''",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return ''\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j = i + len(word)",
      "mutated_line": "j = i - len(word)",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i - len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "j = i + len(word)",
      "mutated_line": "j = i * len(word)",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i * len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if j < len(loginattempt) and store[j]:",
      "mutated_line": "if j < len(loginattempt) or store[j]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) or store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return store[0]",
      "mutated_line": "return store[1]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[1]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return store[0]",
      "mutated_line": "return store[-1]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[-1]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return store[0]",
      "mutated_line": "return store[1]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[1]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if j < len(loginattempt) and store[j]:",
      "mutated_line": "if j <= len(loginattempt) and store[j]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j <= len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if j < len(loginattempt) and store[j]:",
      "mutated_line": "if j >= len(loginattempt) and store[j]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j >= len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if j < len(loginattempt) and store[j]:",
      "mutated_line": "if j != len(loginattempt) and store[j]:",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j != len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "store[i] = word + ' ' + store[j]",
      "mutated_line": "store[i] = word + ' ' - store[j]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' - store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "store[i] = word + ' ' + store[j]",
      "mutated_line": "store[i] = (word + ' ') * store[j]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = (word + ' ') * store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif j == len(loginattempt):",
      "mutated_line": "elif j != len(loginattempt):",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + ' ' + store[j]\n                    break\n                elif j != len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "store[i] = word + ' ' + store[j]",
      "mutated_line": "store[i] = word - ' ' + store[j]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word - ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "store[i] = word + ' ' + store[j]",
      "mutated_line": "store[i] = word * ' ' + store[j]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word * ' ' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "store[i] = word + ' ' + store[j]",
      "mutated_line": "store[i] = word + '' + store[j]",
      "code": "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.answer = []\n\n    def insert(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n        current_dict[self._end] = self._end\n\n    def find(self, word):\n        current_dict = self.root\n        ans = ''\n        for letter in word:\n            if letter not in current_dict:\n                return\n            ans += letter\n            current_dict = current_dict[letter]\n            if self._end in current_dict:\n                yield ans\n\n    def solve(self, loginattempt):\n        store = [None] * len(loginattempt)\n        for i in reversed(range(len(loginattempt))):\n            for word in self.find(loginattempt[i:]):\n                j = i + len(word)\n                if j < len(loginattempt) and store[j]:\n                    store[i] = word + '' + store[j]\n                    break\n                elif j == len(loginattempt):\n                    store[i] = word\n                    break\n        if store[0]:\n            return store[0]\n        else:\n            return 'WRONG PASSWORD'\n\ndef password_cracker(passwords, login_attempt):\n    trie = Trie()\n    for word in passwords:\n        trie.insert(word)\n    return trie.solve(login_attempt)"
    }
  ]
}