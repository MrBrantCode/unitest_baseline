{
  "task_id": "taco_7618",
  "entry_point": "solve_tree_problem",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot - 1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot - 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot * 1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot * 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "depSpec = -1",
      "mutated_line": "depSpec = +1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = +1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if root in isSpecial:",
      "mutated_line": "if root not in isSpecial:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root not in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] == -1:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] == -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "isSpecial = {node: True for node in special_nodes}",
      "mutated_line": "isSpecial = {node: False for node in special_nodes}",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: False for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [+1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [+1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [+1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [+1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [1 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [-1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [-1 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [1 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [+1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [+1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, +1, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, +1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, +1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, +1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, +1, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, +1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, +1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, +1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot + 2",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 2\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot + 0",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 0\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot + 0",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 0\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[root] = distanceFromRoot + 1",
      "mutated_line": "dist[root] = distanceFromRoot + -1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + -1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dep = int(10000000000.0)",
      "mutated_line": "dep = int(10000000001.0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000001.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dep = int(10000000000.0)",
      "mutated_line": "dep = int(9999999999.0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(9999999999.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dep = int(10000000000.0)",
      "mutated_line": "dep = int(0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dep = int(10000000000.0)",
      "mutated_line": "dep = int(1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(1)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dep = int(10000000000.0)",
      "mutated_line": "dep = int(-10000000000.0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(-10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "depSpec = -1",
      "mutated_line": "depSpec = -2",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -2\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "depSpec = -1",
      "mutated_line": "depSpec = -0",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -0\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "depSpec = -1",
      "mutated_line": "depSpec = -0",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -0\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "depSpec = -1",
      "mutated_line": "depSpec = --1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = --1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dep = 0",
      "mutated_line": "dep = 1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 1\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dep = 0",
      "mutated_line": "dep = -1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = -1\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dep = 0",
      "mutated_line": "dep = 1",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 1\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if par != node:",
      "mutated_line": "if par == node:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par == node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep - 1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep - 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep * 1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep * 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] != +1:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != +1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 2 * dist[specAnc] + dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] + dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 2 * dist[specAnc] * dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] * dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if par != node:",
      "mutated_line": "if par == node:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par == node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-2 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-2 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-0 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-0 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [--1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [--1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-2 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-2 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-0 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-0 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [--1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [--1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-2 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-2 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-0 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-0 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-0 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [--1 for _ in range(n + 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [--1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -2, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -2, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -0, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -0, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -0, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -0, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, --1, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, --1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -2)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -2)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -0)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -0)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)",
      "mutated_line": "markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, --1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, --1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -2, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -2, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -0, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -0, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -0, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -0, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, --1, -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, --1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -2)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -2)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -0)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -0)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)",
      "mutated_line": "dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, --1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, --1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_values = objective[1:]",
      "mutated_line": "max_values = objective[2:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[2:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_values = objective[1:]",
      "mutated_line": "max_values = objective[0:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[0:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_values = objective[1:]",
      "mutated_line": "max_values = objective[0:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[0:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_values = objective[1:]",
      "mutated_line": "max_values = objective[-1:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[-1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "special_nodes_result = myspec[1:]",
      "mutated_line": "special_nodes_result = myspec[2:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[2:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "special_nodes_result = myspec[1:]",
      "mutated_line": "special_nodes_result = myspec[0:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[0:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "special_nodes_result = myspec[1:]",
      "mutated_line": "special_nodes_result = myspec[0:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[0:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "special_nodes_result = myspec[1:]",
      "mutated_line": "special_nodes_result = myspec[-1:]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[-1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dep > tempDep:",
      "mutated_line": "if dep >= tempDep:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep >= tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dep > tempDep:",
      "mutated_line": "if dep <= tempDep:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep <= tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dep > tempDep:",
      "mutated_line": "if dep != tempDep:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep != tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep + 2)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 2)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep + 0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 0)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep + 0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 0)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return (parentOfSpec[root], dep + 1)",
      "mutated_line": "return (parentOfSpec[root], dep + -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + -1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] != -2:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -2:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] != -0:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -0:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] != -0:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -0:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if parentOfSpec[root] != -1:",
      "mutated_line": "if parentOfSpec[root] != --1:",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != --1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 2 / dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 / dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 2 + dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 + dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 2 ** dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 ** dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n - 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n - 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n * 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n * 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n - 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n - 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n * 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n * 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n - 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n - 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n * 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n * 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n - 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n - 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n * 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n * 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n - 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n - 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n * 1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n * 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot - 1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot - 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot * 1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot * 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 3 * dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 3 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 1 * dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 1 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 0 * dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 0 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = 1 * dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 1 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "objective[root] = 2 * dist[specAnc] - dist[root]",
      "mutated_line": "objective[root] = -2 * dist[specAnc] - dist[root]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = -2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n + 2)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 2)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 0)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 0)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "tree = [[] for _ in range(n + -1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + -1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 2)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 2)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 0)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 0)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + -1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + -1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n + 2)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 2)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 0)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 0)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "objective = [-1 for _ in range(n + 1)]",
      "mutated_line": "objective = [-1 for _ in range(n + -1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + -1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n + 2)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 2)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 0)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 0)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parentOfSpec = [0 for _ in range(n + 1)]",
      "mutated_line": "parentOfSpec = [0 for _ in range(n + -1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + -1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n + 2)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 2)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 0)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n + 0)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 0)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "myspec = [-1 for _ in range(n + 1)]",
      "mutated_line": "myspec = [-1 for _ in range(n + -1)]",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + -1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 2)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 2)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 0)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 0)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 0)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)",
      "mutated_line": "(specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + -1)",
      "code": "def solve_tree_problem(n, k, a, special_nodes, edges):\n    isSpecial = {node: True for node in special_nodes}\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for (x, y) in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    max_values = objective[1:]\n    special_nodes_result = myspec[1:]\n    return (max_values, special_nodes_result)\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + -1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)"
    }
  ]
}