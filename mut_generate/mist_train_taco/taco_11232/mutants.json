{
  "task_id": "taco_11232",
  "entry_point": "heuristic",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 1\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return -1\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 1\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "return -1  # In case no path is found, though the problem guarantees a path exists",
      "mutated_line": "return +1",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if cur_pos == (r2, c2):",
      "mutated_line": "if cur_pos != (r2, c2):",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos != (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r >= 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r >= 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r <= 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r <= 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r != 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r != 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c >= 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c >= 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c <= 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c <= 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c != 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c != 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r <= len(board) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r <= len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r >= len(board) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r >= len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r != len(board) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r != len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c <= len(board[0]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c <= len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c >= len(board[0]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c >= len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c != len(board[0]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c != len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1  # In case no path is found, though the problem guarantees a path exists",
      "mutated_line": "return -2",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1  # In case no path is found, though the problem guarantees a path exists",
      "mutated_line": "return -0",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1  # In case no path is found, though the problem guarantees a path exists",
      "mutated_line": "return -0",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1  # In case no path is found, though the problem guarantees a path exists",
      "mutated_line": "return --1",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}",
      "mutated_line": "open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] - heuristic(board, r1, c1, r2, c2))}",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] - heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}",
      "mutated_line": "open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] * heuristic(board, r1, c1, r2, c2))}",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] * heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r > 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 1:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r > -1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > -1:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r > 0:",
      "mutated_line": "if r > 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 1:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c > 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 1:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c > -1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > -1:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c > 0:",
      "mutated_line": "if c > 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 1:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) + 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) + 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) * 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) * 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) + 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) + 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) * 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) * 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cost = cur_cost + board[r][c]",
      "mutated_line": "cost = cur_cost - board[r][c]",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost - board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cost = cur_cost + board[r][c]",
      "mutated_line": "cost = cur_cost * board[r][c]",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost * board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "est = cost + heuristic(board, r, c, r2, c2)",
      "mutated_line": "est = cost - heuristic(board, r, c, r2, c2)",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost - heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "est = cost + heuristic(board, r, c, r2, c2)",
      "mutated_line": "est = cost * heuristic(board, r, c, r2, c2)",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost * heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if nb_pos in closed_nodes:",
      "mutated_line": "if nb_pos not in closed_nodes:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos not in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes or open_nodes[nb_pos][0] <= cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes or open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) - 2:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 2:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) - 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 0:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) - 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 0:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r < len(board) - 1:",
      "mutated_line": "if r < len(board) - -1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - -1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) - 2:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 2:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) - 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 0:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) - 0:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 0:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[0]) - -1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - -1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos not in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos not in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] < cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] < cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] > cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] > cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] == cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] == cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r + 1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r + 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r * 1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r * 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c + 1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c + 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c * 1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c * 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r - 1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r - 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r * 1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r * 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c - 1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c - 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c * 1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c * 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r - 2, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 2, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r - 0, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 0, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r - 0, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 0, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "neighbours.append((r - 1, c))",
      "mutated_line": "neighbours.append((r - -1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - -1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c - 2))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 2))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c - 0))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 0))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c - 0))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 0))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "neighbours.append((r, c - 1))",
      "mutated_line": "neighbours.append((r, c - -1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - -1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r + 2, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 2, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r + 0, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 0, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r + 0, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 0, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "neighbours.append((r + 1, c))",
      "mutated_line": "neighbours.append((r + -1, c))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + -1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[1]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[1]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[-1]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[-1]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if c < len(board[0]) - 1:",
      "mutated_line": "if c < len(board[1]) - 1:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[1]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c + 2))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 2))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c + 0))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 0))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c + 0))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 0))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "neighbours.append((r, c + 1))",
      "mutated_line": "neighbours.append((r, c + -1))",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + -1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][1] <= cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][1] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][-1] <= cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][-1] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if nb_pos in open_nodes and open_nodes[nb_pos][0] <= cost:",
      "mutated_line": "if nb_pos in open_nodes and open_nodes[nb_pos][1] <= cost:",
      "code": "def heuristic(board, r1, c1, r2, c2):\n    return 0\n\ndef find_min_path_weight(board, r1, c1, r2, c2):\n    open_nodes = {(r1, c1): (board[r1][c1], board[r1][c1] + heuristic(board, r1, c1, r2, c2))}\n    closed_nodes = set()\n    while open_nodes:\n        (cur_est, cur_pos, cur_cost) = min(((est, pos, cost) for (pos, (cost, est)) in open_nodes.items()))\n        del open_nodes[cur_pos]\n        if cur_pos == (r2, c2):\n            return cur_cost\n        (r, c) = cur_pos\n        neighbours = []\n        if r > 0:\n            neighbours.append((r - 1, c))\n        if c > 0:\n            neighbours.append((r, c - 1))\n        if r < len(board) - 1:\n            neighbours.append((r + 1, c))\n        if c < len(board[0]) - 1:\n            neighbours.append((r, c + 1))\n        for nb_pos in neighbours:\n            (r, c) = nb_pos\n            cost = cur_cost + board[r][c]\n            est = cost + heuristic(board, r, c, r2, c2)\n            if nb_pos in closed_nodes:\n                continue\n            if nb_pos in open_nodes and open_nodes[nb_pos][1] <= cost:\n                continue\n            open_nodes[nb_pos] = (cost, est)\n        closed_nodes.add(cur_pos)\n    return -1"
    }
  ]
}