{
  "task_id": "taco_4744",
  "entry_point": "minimize_malware_spread",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "best_remove = initial[0]",
      "mutated_line": "best_remove = initial[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[1]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "best_remove = initial[0]",
      "mutated_line": "best_remove = initial[-1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[-1]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "best_remove = initial[0]",
      "mutated_line": "best_remove = initial[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[1]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "initial_removed = initial - {remove_node}",
      "mutated_line": "initial_removed = initial + {remove_node}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial + {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "initial_removed = initial - {remove_node}",
      "mutated_line": "initial_removed = initial * {remove_node}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial * {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best and (node_result == best and best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best and (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result <= best or (node_result == best and best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result <= best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result >= best or (node_result == best and best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result >= best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result != best or (node_result == best and best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result != best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best or (node_result == best or best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best or best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == 0 and next_node in visited and (next_node == removed):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 and next_node in visited and (next_node == removed):\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best or (node_result != best and best_remove > remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result != best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best or (node_result == best and best_remove >= remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove >= remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best or (node_result == best and best_remove <= remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove <= remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if node_result < best or (node_result == best and best_remove > remove_node):",
      "mutated_line": "if node_result < best or (node_result == best and best_remove != remove_node):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove != remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] != 0 or next_node in visited or next_node == removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] != 0 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == 0 or next_node not in visited or next_node == removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node not in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == 0 or next_node in visited or next_node != removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 0 or next_node in visited or next_node != removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == 1 or next_node in visited or next_node == removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 1 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == -1 or next_node in visited or next_node == removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == -1 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if graph[node][next_node] == 0 or next_node in visited or next_node == removed:",
      "mutated_line": "if graph[node][next_node] == 1 or next_node in visited or next_node == removed:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimize_malware_spread(graph: List[List[int]], initial: List[int]) -> int:\n\n    def bfs(graph, seed, removed):\n        queue = deque(seed)\n        visited = seed\n        while queue:\n            node = queue.popleft()\n            for next_node in range(len(graph[node])):\n                if graph[node][next_node] == 1 or next_node in visited or next_node == removed:\n                    continue\n                visited.add(next_node)\n                queue.append(next_node)\n        return len(visited)\n    best = len(graph)\n    best_remove = initial[0]\n    initial = set(initial)\n    for remove_node in initial:\n        initial_removed = initial - {remove_node}\n        node_result = bfs(graph, initial_removed, remove_node)\n        if node_result < best or (node_result == best and best_remove > remove_node):\n            best = node_result\n            best_remove = remove_node\n    return best_remove"
    }
  ]
}