{
  "task_id": "taco_17640",
  "entry_point": "min_ignored_instructions",
  "mutant_count": 288,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 * 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 * 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 + 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 + 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 11 ** 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 11 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 9 ** 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 9 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 0 ** 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 0 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 1 ** 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 1 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = -10 ** 20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = -10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 21",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 21\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 19",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 19\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 0\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 1\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** -20",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** -20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d[s] = 0",
      "mutated_line": "d[s] = 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d[s] = 0",
      "mutated_line": "d[s] = -1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = -1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d[s] = 0",
      "mutated_line": "d[s] = 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -1 if r is not None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is not None else r"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return +1 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return +1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(-1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(-1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 2), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 2), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 0), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 0), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 0), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 0), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, -1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, -1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (2, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (2, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (-1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (-1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, -1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, -1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (2, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (2, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (-1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (-1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, +1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, +1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (-1, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (-1, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, +1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, +1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (+1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (+1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, +1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, +1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (+1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (+1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, -1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, -1), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (1, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (1, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, -1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, -1)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(-1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(-1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(1, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 2), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 2), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 0), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 0), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 0), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 0), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, -1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, -1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (2, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (2, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (-1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (-1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 2), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 2), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 0), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 0), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 0), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 0), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, -1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, -1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (2, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (2, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (0, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (0, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (0, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (0, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (-1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (-1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 1), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 1), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 1), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 1), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (1, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (1, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (-1, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (-1, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (1, -1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (1, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, +1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, +1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (+1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (+1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 1), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 1), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, -1), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, -1), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 1), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 1), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (+1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (+1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 2), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 2), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 0), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 0), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, -1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (-1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (-1, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 1)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, -1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, -1)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 1)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 1)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s = tuple(list(s) + [0])",
      "mutated_line": "s = tuple(list(s) - [0])",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) - [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s = tuple(list(s) + [0])",
      "mutated_line": "s = tuple(list(s) * [0])",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) * [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[0], u[1]) != g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) != g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v[u] = True",
      "mutated_line": "v[u] = False",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = False\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) * 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) * 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = u[2] + 1 + 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = u[2] + 1 + 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k or abs(uv[0]) <= lx or abs(uv[1]) <= ly or ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k or abs(uv[0]) <= lx or abs(uv[1]) <= ly or ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k - 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k - 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k * 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k * 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -2 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -2 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -0 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -0 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return -0 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -0 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1 if r is None else r",
      "mutated_line": "return --1 if r is None else r",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return --1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -2), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -2), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, --1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, --1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -2), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -2), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, --1), (-1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, --1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-2, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-2, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (--1, -1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (--1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -2), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -2), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, --1), (-1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, --1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-2, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-2, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]",
      "mutated_line": "dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (--1, 0), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (--1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -2), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -2), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -0), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -0), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -0), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -0), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, --1), (-1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, --1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-2, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-2, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-0, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-0, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-0, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-0, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (--1, 0), (-1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (--1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-2, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-2, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-0, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-0, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-0, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-0, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]",
      "mutated_line": "dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (--1, 1), (0, 0)]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (--1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (1, s))",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (1, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (-1, s))",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (-1, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(q, (0, s))",
      "mutated_line": "heapq.heappush(q, (1, s))",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (1, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 != 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 != 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 1 if u[0] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 1 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = -1 if u[0] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = -1 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 1 if u[0] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 1 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 0 else 2",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 2\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 0 else 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 0\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 0 else 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 0\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 0 else -1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else -1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) * 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) * 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) + 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) + 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] - 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] - 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = u[2] * 1 % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = u[2] * 1 % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) % 7",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 7\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) % 5",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 5\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) % 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 0\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) % 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 1\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 1) % -6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % -6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] - di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] - di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] * di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] * di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[1] - dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] - dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[1] * dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] * dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] >= k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] >= k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] <= k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] <= k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] != k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] != k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) < lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) < lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) > lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) > lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) == lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) == lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) < ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) < ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) > ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) > ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) == ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) == ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k + 2",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 2\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k + 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 0\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k + 0",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 0\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd = k + 1",
      "mutated_line": "vd = k + -1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + -1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] and abs(uv[0]) > lx and (abs(uv[1]) > ly) and ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] and abs(uv[0]) > lx and (abs(uv[1]) > ly) and ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] >= vd:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] >= vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] <= vd:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] <= vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if d[uv] > vd:",
      "mutated_line": "if d[uv] != vd:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] != vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = tuple(list(s) + [0])",
      "mutated_line": "s = tuple(list(s) + [1])",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [1])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = tuple(list(s) + [0])",
      "mutated_line": "s = tuple(list(s) + [-1])",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [-1])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = tuple(list(s) + [0])",
      "mutated_line": "s = tuple(list(s) + [1])",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [1])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] * 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] * 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] + 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] + 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 1 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 1 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == -1 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == -1 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 2 == 1 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 1 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 7]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 7]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 5]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 5]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 0]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 0]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 1]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 1]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % -6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % -6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 2) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 2) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 0) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 0) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + 0) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 0) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[2] + -1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + -1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] - di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] - di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] * di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] * di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[1] - dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] - dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[1] * dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] * dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) >= lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) >= lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) <= lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) <= lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) != lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) != lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) >= ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) >= ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) <= ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) <= ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) != ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) != ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) not in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[1], u[1]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[1], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[-1], u[1]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[-1], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[1], u[1]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[1], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[0], u[2]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[2]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[0], u[0]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[0]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[0], u[0]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[0]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (u[0], u[1]) == g:",
      "mutated_line": "if (u[0], u[-1]) == g:",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[-1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 3 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 3 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 1 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 1 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 0 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 0 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % 1 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 1 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[0] % -2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % -2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] / u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] / u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] + u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] + u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs((u[0] * u[1]) ** u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs((u[0] * u[1]) ** u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[3] + 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[3] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[1] + 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[1] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[0] + 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[0] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[1] + 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[1] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nu = (u[2] + 1) % 6",
      "mutated_line": "nu = (u[-2] + 1) % 6",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[-2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[1] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[-1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[-1] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[1] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[2] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[2] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[0] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[0] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[0] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[0] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[-1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[-1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[1] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[1] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[-1] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[-1] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ddi = 0 if u[0] % 2 == 0 else 1",
      "mutated_line": "ddi = 0 if u[1] % 2 == 0 else 1",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[1] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] / u[1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] / u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs((u[0] + u[1]) * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs((u[0] + u[1]) * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] ** u[1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] ** u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[-1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[-1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[1]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[2]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[2]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[0]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[0]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[0]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[0]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[-1]) <= ly) and ((uv[0], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[-1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[1], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[1], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[-1], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[-1], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[1], uv[1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[1], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[2]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[2]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[0]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[0]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[0]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[0]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and (uv[0], uv[1]) not in fs:",
      "mutated_line": "if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[-1]) not in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[-1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[1] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[-1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[-1] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[1] + di, u[1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[1] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[2] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[2] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[0] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[0] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[0] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[0] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "uv = (u[0] + di, u[1] + dj, nu)",
      "mutated_line": "uv = (u[0] + di, u[-1] + dj, nu)",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[-1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[3]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[3]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[1]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[1]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[0]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[0]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[1]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[1]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[-2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[-2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[-1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[-1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[1]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[2]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[2]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[0]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[0]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[0]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[0]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[-1]) > ly or ((uv[0], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[-1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[1], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[1], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[-1], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[-1], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[1], uv[1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[1], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[2]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[2]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[0]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[0]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[0]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[0]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0], uv[1]) in fs:",
      "mutated_line": "if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[-1]) in fs):",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[-1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[1] * u[1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[1] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[-1] * u[1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[-1] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[1] * u[1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[1] * u[1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[2] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[2] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[0] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[0] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[0] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[0] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(di, dj) = dd[ddi][abs(u[0] * u[1] * u[2]) % 6]",
      "mutated_line": "(di, dj) = dd[ddi][abs(u[0] * u[-1] * u[2]) % 6]",
      "code": "import heapq\nimport collections\n\ndef min_ignored_instructions(sx, sy, gx, gy, n, furniture, lx, ly):\n    inf = 10 ** 20\n    dd0 = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\n    dd1 = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (0, 0)]\n    dd = [dd0, dd1]\n    fs = set(furniture)\n\n    def search(s, g):\n        d = collections.defaultdict(lambda : inf)\n        s = tuple(list(s) + [0])\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while q:\n            (k, u) = heapq.heappop(q)\n            if v[u]:\n                continue\n            if (u[0], u[1]) == g:\n                return k\n            v[u] = True\n            ddi = 0 if u[0] % 2 == 0 else 1\n            (di, dj) = dd[ddi][abs(u[0] * u[-1] * u[2]) % 6]\n            nu = (u[2] + 1) % 6\n            uv = (u[0] + di, u[1] + dj, nu)\n            if d[uv] > k and abs(uv[0]) <= lx and (abs(uv[1]) <= ly) and ((uv[0], uv[1]) not in fs):\n                d[uv] = k\n                heapq.heappush(q, (k, uv))\n            vd = k + 1\n            for (di, dj) in dd[ddi]:\n                uv = (u[0] + di, u[1] + dj, nu)\n                if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or ((uv[0], uv[1]) in fs):\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n        return None\n    r = search((sx, sy), (gx, gy))\n    return -1 if r is None else r"
    }
  ]
}