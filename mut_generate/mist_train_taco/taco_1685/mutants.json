{
  "task_id": "taco_1685",
  "entry_point": "find_tree_diameter",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maxv = 0",
      "mutated_line": "maxv = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 1\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maxv = 0",
      "mutated_line": "maxv = -1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = -1\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maxv = 0",
      "mutated_line": "maxv = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 1\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tgt = 0",
      "mutated_line": "tgt = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 1\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tgt = 0",
      "mutated_line": "tgt = -1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = -1\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tgt = 0",
      "mutated_line": "tgt = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 1\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [INF] * n",
      "mutated_line": "D = [INF] / n",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] / n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [INF] * n",
      "mutated_line": "D = [INF] + n",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] + n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [INF] * n",
      "mutated_line": "D = [INF] ** n",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] ** n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D[s] = 0",
      "mutated_line": "D[s] = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 1\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D[s] = 0",
      "mutated_line": "D[s] = -1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = -1\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D[s] = 0",
      "mutated_line": "D[s] = 1",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 1\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "D = bfs(0)",
      "mutated_line": "D = bfs(1)",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(1)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "D = bfs(0)",
      "mutated_line": "D = bfs(-1)",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(-1)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "D = bfs(0)",
      "mutated_line": "D = bfs(1)",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(1)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if maxv < D[i]:",
      "mutated_line": "if maxv <= D[i]:",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv <= D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if maxv < D[i]:",
      "mutated_line": "if maxv >= D[i]:",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv >= D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if maxv < D[i]:",
      "mutated_line": "if maxv != D[i]:",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] + w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv != D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "D[v] = D[u] + w",
      "mutated_line": "D[v] = D[u] - w",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] - w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "D[v] = D[u] + w",
      "mutated_line": "D[v] = D[u] * w",
      "code": "from collections import deque\nfrom math import isinf\n\ndef find_tree_diameter(n, edges):\n    INF = float('inf')\n    G = [[] for _ in range(n)]\n    for (s, t, w) in edges:\n        G[s].append([t, w])\n        G[t].append([s, w])\n\n    def bfs(s):\n        D = [INF] * n\n        dq = deque([s])\n        D[s] = 0\n        while dq:\n            u = dq.popleft()\n            for (v, w) in G[u]:\n                if isinf(D[v]):\n                    D[v] = D[u] * w\n                    dq.append(v)\n        return D\n    D = bfs(0)\n    maxv = 0\n    tgt = 0\n    for i in range(n):\n        if isinf(D[i]):\n            continue\n        if maxv < D[i]:\n            maxv = D[i]\n            tgt = i\n    D = bfs(tgt)\n    return max((D[i] for i in range(n) if not isinf(D[i])))"
    }
  ]
}