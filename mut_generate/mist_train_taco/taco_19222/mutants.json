{
  "task_id": "taco_19222",
  "entry_point": "triple_tree_decomposition",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 0) != 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) != 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) != 3:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) != 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 0) == 2:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 2:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 0) == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 0:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 0) == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 0:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 0) == -1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == -1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v == p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) == 4:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 4:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) == 2:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 2:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 0:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 1:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(l) == 3:",
      "mutated_line": "if len(l) == -3:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == -3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(2, 0) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(2, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(0, 0) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(0, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(0, 0) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(0, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(-1, 0) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(-1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 1) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 1) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, -1) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, -1) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if dfs(1, 0) == 1:",
      "mutated_line": "if dfs(1, 1) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 1) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return True, out",
      "mutated_line": "return (False, out)",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (False, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return False, []",
      "mutated_line": "return (True, [])",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (True, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r != 2:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r != 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if r == 1:",
      "mutated_line": "if r != 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r != 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "out.append(l + [p])",
      "mutated_line": "out.append(l - [p])",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l - [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "out.append(l + [p])",
      "mutated_line": "out.append(l * [p])",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l * [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r == 3:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 3:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 1:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 0:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 1:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if r == 2:",
      "mutated_line": "if r == -2:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == -2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 3\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 1\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 0\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 1\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return -2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if r == 1:",
      "mutated_line": "if r == 2:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 2:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if r == 1:",
      "mutated_line": "if r == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 0:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if r == 1:",
      "mutated_line": "if r == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 0:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if r == 1:",
      "mutated_line": "if r == -1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == -1:\n                    l.append(v)\n                    if len(l) == 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) != 4:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) != 4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) == 5:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 5:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) == 3:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 3:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) == 0:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 0:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) == 1:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == 1:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(l) == 4:",
      "mutated_line": "if len(l) == -4:",
      "code": "def triple_tree_decomposition(n, edges):\n    from collections import defaultdict\n\n    def dfs(u, p):\n        l = [u]\n        for v in g[u]:\n            if v != p:\n                r = dfs(v, u)\n                if r == 2:\n                    return 2\n                if r == 1:\n                    l.append(v)\n                    if len(l) == -4:\n                        out.append(l)\n                        l = [u]\n        if len(l) == 3:\n            out.append(l + [p])\n        return len(l)\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    out = []\n    if dfs(1, 0) == 1:\n        return (True, out)\n    else:\n        return (False, [])"
    }
  ]
}