{
  "task_id": "taco_13107",
  "entry_point": "find_headturns",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "minimum = 0",
      "mutated_line": "minimum = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 1\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "minimum = 0",
      "mutated_line": "minimum = -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = -1\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "minimum = 0",
      "mutated_line": "minimum = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 1\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "aux = 0",
      "mutated_line": "aux = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 1\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "aux = 0",
      "mutated_line": "aux = -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = -1\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "aux = 0",
      "mutated_line": "aux = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 1\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "maximum = 0",
      "mutated_line": "maximum = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 1\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "maximum = 0",
      "mutated_line": "maximum = -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = -1\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "maximum = 0",
      "mutated_line": "maximum = 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 1\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t = True",
      "mutated_line": "t = False",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = False\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "aux += 1",
      "mutated_line": "aux -= 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux -= 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "base = 1",
      "mutated_line": "base = 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 2\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "base = 1",
      "mutated_line": "base = 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 0\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "base = 1",
      "mutated_line": "base = 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 0\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "base = 1",
      "mutated_line": "base = -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = -1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux += 1",
      "mutated_line": "aux += 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 2\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux += 1",
      "mutated_line": "aux += 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 0\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux += 1",
      "mutated_line": "aux += 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 0\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux += 1",
      "mutated_line": "aux += -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += -1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t = False",
      "mutated_line": "t = True",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = True\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n + 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n + 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n * 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n * 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i > 0:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i > 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i < 0:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i < 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i == 0:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i == 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i += 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if not minimum <= k <= maximum:",
      "mutated_line": "if not minimum < k <= maximum:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum < k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if not minimum <= k <= maximum:",
      "mutated_line": "if not minimum > k <= maximum:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum > k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if not minimum <= k <= maximum:",
      "mutated_line": "if not minimum == k <= maximum:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum == k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return +1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(0, minimum):",
      "mutated_line": "for i in range(1, minimum):",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(1, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(0, minimum):",
      "mutated_line": "for i in range(-1, minimum):",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(-1, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(0, minimum):",
      "mutated_line": "for i in range(1, minimum):",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(1, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n - 3",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 3\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n - 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 1\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n - 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 0\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n - 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 1\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = n - 2",
      "mutated_line": "i = n - -2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - -2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 1:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= -1:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= -1:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 1:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' or word[i + 1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' or word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "maximum += 1",
      "mutated_line": "maximum -= 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum -= 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i += 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 2\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 0\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 0\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= -1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -2\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -0\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -0\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return --1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if maximum == k:",
      "mutated_line": "if maximum != k:",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum != k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k += 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum += 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum += 1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum += 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] != 'R' and word[i + 1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] != 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + 1] != 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] != 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maximum += 1",
      "mutated_line": "maximum += 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 2\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maximum += 1",
      "mutated_line": "maximum += 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 0\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maximum += 1",
      "mutated_line": "maximum += 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 0\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maximum += 1",
      "mutated_line": "maximum += -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += -1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = True",
      "mutated_line": "t = False",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = False\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 2\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 0\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 0\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= -1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 2\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 0\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 0\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= -1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 2\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 0\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 0\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= -1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 2",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 2\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 0\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= 0",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 0\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "maximum -= 1",
      "mutated_line": "maximum -= -1",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= -1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == '' and word[i + 1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == '' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + 1] == '':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == '':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i - 1)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i - 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i * 1)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i * 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i - 1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i - 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i * 1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i * 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i + 2)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 2)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i + 0)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 0)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i + 0)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 0)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mov.append(i + 1)",
      "mutated_line": "mov.append(i + -1)",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + -1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i - 1]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i - 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i * 1]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i * 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i - 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i - 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i * 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i * 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + 2] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 2] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + 0] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 0] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + 0] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 0] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if word[i] == 'R' and word[i + 1] == 'L':",
      "mutated_line": "if word[i] == 'R' and word[i + -1] == 'L':",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + -1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 2]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 2]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 0]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 0]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 0]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 0]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + -1]) = (word[i + 1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + -1]) = (word[i + 1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i + 2], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 2], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i + 0], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 0], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i + 0], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + 0], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "word[i], word[i + 1] = word[i + 1], word[i]",
      "mutated_line": "(word[i], word[i + 1]) = (word[i + -1], word[i])",
      "code": "def find_headturns(n, k, arrangement):\n    word = list(arrangement)\n    minimum = 0\n    aux = 0\n    maximum = 0\n    complete = []\n    mov = []\n    t = True\n    while t:\n        aux += 1\n        t = False\n        i = n - 2\n        while i >= 0:\n            if word[i] == 'R' and word[i + 1] == 'L':\n                maximum += 1\n                mov.append(i + 1)\n                minimum = max(minimum, aux)\n                (word[i], word[i + 1]) = (word[i + -1], word[i])\n                t = True\n                i -= 1\n            i -= 1\n        complete.append(mov)\n        mov = []\n    if not minimum <= k <= maximum:\n        return -1\n    base = 1\n    ans = []\n    k2 = k\n    for i in range(0, minimum):\n        complete_aux = []\n        for j in range(len(complete[i])):\n            if maximum == k:\n                complete_aux.append(complete[i][j])\n                ans.append(complete_aux)\n                complete_aux = []\n                k -= 1\n                maximum -= 1\n            else:\n                complete_aux.append(complete[i][j])\n                maximum -= 1\n        if len(complete_aux):\n            ans.append(complete_aux)\n            k -= 1\n    return ans"
    }
  ]
}