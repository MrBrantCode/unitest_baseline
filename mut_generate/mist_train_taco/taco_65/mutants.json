{
  "task_id": "taco_65",
  "entry_point": "shortest_path_with_obstacles",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k > m + n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k > m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k < m + n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k < m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k == m + n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k == m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n + 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n + 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= (m + n) * 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= (m + n) * 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n + 2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n + 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return (m + n) * 2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return (m + n) * 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 or col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 or col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m - n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m - n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m * n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m * n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n - 3:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 3:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 1:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n - 0:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 0:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 1:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= m + n - 2:",
      "mutated_line": "if k >= m + n - -2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - -2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m - n - 2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m - n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m * n - 2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m * n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n - 3",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 3\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n - 1",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 1\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n - 0",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 0\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n - 1",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 1\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return m + n - 2",
      "mutated_line": "return m + n - -2",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - -2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row != m - 1 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row != m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col != n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col != n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m or 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m or 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(mat), len(mat[0])",
      "mutated_line": "(m, n) = (len(mat), len(mat[1]))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[1]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(mat), len(mat[0])",
      "mutated_line": "(m, n) = (len(mat), len(mat[-1]))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[-1]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(mat), len(mat[0])",
      "mutated_line": "(m, n) = (len(mat), len(mat[1]))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[1]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(1, 0, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(1, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(-1, 0, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(-1, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(1, 0, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(1, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, 1, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 1, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, -1, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, -1, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, 1, k, 0)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 1, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, 0, k, 1)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 1)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, 0, k, -1)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, -1)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = deque([(0, 0, k, 0)])  # (row, col, remaining_k, steps)",
      "mutated_line": "q = deque([(0, 0, k, 1)])",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 1)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m + 1 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m + 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m * 1 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m * 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n + 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n + 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n * 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n * 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col - 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col - 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col * 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col * 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row - 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row - 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row * 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row * 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row + 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row + 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row * 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row * 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col + 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col + 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col * 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col * 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 < r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 < r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 > r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 > r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 == r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 == r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and 0 < c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 < c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and 0 > c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 > c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and 0 == c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 == c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "k_rem = obstacles - mat[r][c]",
      "mutated_line": "k_rem = obstacles + mat[r][c]",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles + mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "k_rem = obstacles - mat[r][c]",
      "mutated_line": "k_rem = obstacles * mat[r][c]",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles * mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 or k_rem >= 0 or (r, c, k_rem) not in visited:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 or k_rem >= 0 or (r, c, k_rem) not in visited:\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 2 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 2 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 0 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 0 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 0 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 0 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - -1 and col == n - 1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - -1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n - 2:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 2:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n - 0:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 0:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n - 0:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 0:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row == m - 1 and col == n - 1:",
      "mutated_line": "if row == m - 1 and col == n - -1:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - -1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 2), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 2), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 0), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 0), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 0), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 0), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + -1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + -1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 2, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 2, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 0, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 0, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 0, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 0, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + -1, col), (row - 1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + -1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 2, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 2, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 0, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 0, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 0, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 0, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - -1, col), (row, col - 1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - -1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 2)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 2)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 0)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 0)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 0)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 0)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for r, c in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):",
      "mutated_line": "for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - -1)):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - -1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 1 <= r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 1 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if -1 <= r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if -1 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 1 <= r < m and 0 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 1 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and 1 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 1 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and -1 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and -1 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= r < m and 0 <= c < n:",
      "mutated_line": "if 0 <= r < m and 1 <= c < n:",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 1 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] > 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] > 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] < 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] < 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] == 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] == 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem > 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem > 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem < 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem < 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem == 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem == 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 1 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 1 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= -1 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= -1 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 1 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 1 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem >= 1 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 1 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem >= -1 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= -1 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):",
      "mutated_line": "if mat[r][c] >= 0 and k_rem >= 1 and ((r, c, k_rem) not in visited):",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 1 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps - 1))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps - 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps * 1))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps * 1))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps + 2))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 2))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps + 0))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 0))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps + 0))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + 0))\n                    visited.add((r, c, k_rem))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((r, c, k_rem, steps + 1))",
      "mutated_line": "q.append((r, c, k_rem, steps + -1))",
      "code": "from collections import deque\n\ndef shortest_path_with_obstacles(mat, k):\n    (m, n) = (len(mat), len(mat[0]))\n    q = deque([(0, 0, k, 0)])\n    visited = set()\n    if k >= m + n - 2:\n        return m + n - 2\n    while q:\n        (row, col, obstacles, steps) = q.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for (r, c) in ((row, col + 1), (row + 1, col), (row - 1, col), (row, col - 1)):\n            if 0 <= r < m and 0 <= c < n:\n                k_rem = obstacles - mat[r][c]\n                if mat[r][c] >= 0 and k_rem >= 0 and ((r, c, k_rem) not in visited):\n                    q.append((r, c, k_rem, steps + -1))\n                    visited.add((r, c, k_rem))\n    return -1"
    }
  ]
}