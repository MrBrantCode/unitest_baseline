{
  "task_id": "taco_16265",
  "entry_point": "count_inversions",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 1\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = -1\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 1\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i < len(a) or j < len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) or j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j -= 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return i == len(a)",
      "mutated_line": "return i != len(a)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i != len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "brand_new = True",
      "mutated_line": "brand_new = False",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = False\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best_perms = 0",
      "mutated_line": "best_perms = 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 1\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best_perms = 0",
      "mutated_line": "best_perms = -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = -1\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best_perms = 0",
      "mutated_line": "best_perms = 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 1\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "best_ind = -1",
      "mutated_line": "best_ind = +1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = +1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (1, 0)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (1, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (-1, 0)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (-1, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (1, 0)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (1, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, 1)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 1)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, -1)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, -1)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, 1)",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 1)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i <= len(a) and j < len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i <= len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i >= len(a) and j < len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i >= len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i != len(a) and j < len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i != len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i < len(a) and j <= len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j <= len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i < len(a) and j >= len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j >= len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(a) and j < len(b):",
      "mutated_line": "while i < len(a) and j != len(b):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j != len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if a[i] == b[j]:",
      "mutated_line": "if a[i] != b[j]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] != b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i -= 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 2\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 0\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 0\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += -1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best_ind = -1",
      "mutated_line": "best_ind = -2",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -2\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best_ind = -1",
      "mutated_line": "best_ind = -0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -0\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best_ind = -1",
      "mutated_line": "best_ind = -0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -0\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best_ind = -1",
      "mutated_line": "best_ind = --1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = --1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return \"Brand new problem!\"",
      "mutated_line": "return ''",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) + 1):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) + 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) * 1):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) * 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] >= tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] >= tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] <= tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] <= tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] != tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] != tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "result += 1",
      "mutated_line": "result -= 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result -= 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 2\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 0\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 0\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += -1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind - 1, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind - 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind * 1, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind * 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + '|' * best_perms - ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms - ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, ('[:' + '|' * best_perms) * ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, ('[:' + '|' * best_perms) * ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) - 2):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 2):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) - 0):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 0):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) - 0):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 0):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(len(tmp) - 1):",
      "mutated_line": "for j in range(len(tmp) - -1):",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - -1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result += 1",
      "mutated_line": "result += 2",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 2\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result += 1",
      "mutated_line": "result += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 0\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result += 1",
      "mutated_line": "result += 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 0\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result += 1",
      "mutated_line": "result += -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += -1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "brand_new = False",
      "mutated_line": "brand_new = True",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = True\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 - inversions - 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions - 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = (n * (n - 1) // 2 - inversions) * 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = (n * (n - 1) // 2 - inversions) * 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if best_perms < similarity:",
      "mutated_line": "if best_perms <= similarity:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms <= similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if best_perms < similarity:",
      "mutated_line": "if best_perms >= similarity:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms >= similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if best_perms < similarity:",
      "mutated_line": "if best_perms != similarity:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms != similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 2, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 2, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 0, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 0, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 0, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 0, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + -1, '[:' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + -1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' - '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' - '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' * ('|' * best_perms) + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' * ('|' * best_perms) + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + '|' * best_perms + '')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + '')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][1] > tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][1] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][-1] > tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][-1] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][1] > tmp[j + 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][1] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 1][1]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][1]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 1][-1]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][-1]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 1][1]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][1]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 + inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 + inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 * inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 * inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 - inversions + 2",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 2\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 - inversions + 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 0\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 - inversions + 0",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 0\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 2 - inversions + -1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + -1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '' + '|' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + '|' / best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' / best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + ('|' + best_perms) + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + ('|' + best_perms) + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + '|' ** best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' ** best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j - 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j - 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j * 1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j * 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j - 1]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j - 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j * 1]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j * 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j - 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j - 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j * 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j * 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) / 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) / 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) * 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) * 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return (best_ind + 1, '[:' + '|' * best_perms + ':]')",
      "mutated_line": "return (best_ind + 1, '[:' + '' * best_perms + ':]')",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 2][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 2][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 0][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 0][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + 0][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 0][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tmp[j][0] > tmp[j + 1][0]:",
      "mutated_line": "if tmp[j][0] > tmp[j + -1][0]:",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + -1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 2]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 2]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 0]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 0]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 0]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 0]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + -1]) = (tmp[j + 1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + -1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 2], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 2], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 0], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 0], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 0], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 0], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])",
      "mutated_line": "(tmp[j], tmp[j + 1]) = (tmp[j + -1], tmp[j])",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + -1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n / (n - 1) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n / (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = (n + (n - 1)) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = (n + (n - 1)) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n ** (n - 1) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n ** (n - 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 3 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 3 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 1 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 1 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 0 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 0 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // 1 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // 1 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 1) // -2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 1) // -2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n + 1) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n + 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n * 1) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n * 1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 2) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 2) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 0) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 0) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - 0) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - 0) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "similarity = n * (n - 1) // 2 - inversions + 1",
      "mutated_line": "similarity = n * (n - -1) // 2 - inversions + 1",
      "code": "import itertools\n\ndef count_inversions(enumerate_seq):\n    tmp = list(enumerate_seq[:])\n    result = 0\n    for i in range(len(tmp)):\n        for j in range(len(tmp) - 1):\n            if tmp[j][0] > tmp[j + 1][0]:\n                result += 1\n                (tmp[j], tmp[j + 1]) = (tmp[j + 1], tmp[j])\n    return result\n\ndef sub_seq(a, b):\n    (i, j) = (0, 0)\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return i == len(a)\n\ndef determine_problem_similarity(n, lesha_problem, m, archive_problems):\n    brand_new = True\n    best_perms = 0\n    best_seq = []\n    best_ind = -1\n    for (i, b) in enumerate(archive_problems):\n        for tmp in itertools.permutations(enumerate(lesha_problem)):\n            if sub_seq([x for (y, x) in tmp], b):\n                brand_new = False\n                inversions = count_inversions(tmp)\n                similarity = n * (n - -1) // 2 - inversions + 1\n                if best_perms < similarity:\n                    best_perms = similarity\n                    best_seq = [x for (y, x) in tmp]\n                    best_ind = i\n    if not brand_new:\n        return (best_ind + 1, '[:' + '|' * best_perms + ':]')\n    else:\n        return 'Brand new problem!'"
    }
  ]
}