{
  "task_id": "taco_5897",
  "entry_point": "encode",
  "mutant_count": 229,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) + 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) + 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) * 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) * 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P -= [(0, 0, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P -= [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) - 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 2\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) - 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 0\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) - 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 0\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 10) - -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - -1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a == b == c == d:",
      "mutated_line": "if a != b == c == d:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a != b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] / (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] / (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] + (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] + (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] ** (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] ** (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 1\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = 0",
      "mutated_line": "answer = -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = -1\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 1\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "counter[bottom] -= 1",
      "mutated_line": "counter[bottom] += 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] += 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "counter[top] -= 1",
      "mutated_line": "counter[top] += 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] += 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "counter[bottom] += 1",
      "mutated_line": "counter[bottom] -= 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] -= 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "counter[top] += 1",
      "mutated_line": "counter[top] -= 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] -= 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "answer //= 3",
      "mutated_line": "answer //= 4",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 4\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "answer //= 3",
      "mutated_line": "answer //= 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "answer //= 3",
      "mutated_line": "answer //= 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 0\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "answer //= 3",
      "mutated_line": "answer //= 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "answer //= 3",
      "mutated_line": "answer //= -3",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= -3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (2 << 10) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (2 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (0 << 10) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (0 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (0 << 10) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (0 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (-1 << 10) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (-1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 11) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 11) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 9) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 9) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 0) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 0) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << 1) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 1) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mask = (1 << 10) - 1",
      "mutated_line": "mask = (1 << -10) - 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << -10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 2 << 40",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 2 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 0 << 40",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 0 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 0 << 40",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 0 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = -1 << 40",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = -1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 1 << 41",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 41\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 1 << 39",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 39\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 1 << 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 0\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 1 << 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 1\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t = 1 << 40",
      "mutated_line": "t = 1 << -40",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << -40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) - (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) - (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = (x + (y << 10) + (z << 20)) * (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = (x + (y << 10) + (z << 20)) * (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if t > u:",
      "mutated_line": "if t >= u:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t >= u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if t > u:",
      "mutated_line": "if t <= u:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t <= u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if t > u:",
      "mutated_line": "if t != u:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t != u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "symmetry[t] = 4",
      "mutated_line": "symmetry[t] = 5",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 5\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "symmetry[t] = 4",
      "mutated_line": "symmetry[t] = 3",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 3\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "symmetry[t] = 4",
      "mutated_line": "symmetry[t] = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 0\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "symmetry[t] = 4",
      "mutated_line": "symmetry[t] = 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 1\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "symmetry[t] = 4",
      "mutated_line": "symmetry[t] = -4",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = -4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "elif a == c and b == d:",
      "mutated_line": "elif a == c or b == d:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c or b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n | mask for n in [0, 10, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n | mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N - 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N - 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N * 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N * 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 2):",
      "mutated_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 3):",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 3):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 2):",
      "mutated_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 1):",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 1):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 2):",
      "mutated_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 0):",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 0):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 2):",
      "mutated_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 1):",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 1):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for (bottom, top) in itertools.combinations(encoded_tiles, 2):",
      "mutated_line": "for (bottom, top) in itertools.combinations(encoded_tiles, -2):",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, -2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter[bottom] -= 1",
      "mutated_line": "counter[bottom] -= 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 2\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter[bottom] -= 1",
      "mutated_line": "counter[bottom] -= 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 0\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter[bottom] -= 1",
      "mutated_line": "counter[bottom] -= 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 0\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter[bottom] -= 1",
      "mutated_line": "counter[bottom] -= -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= -1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter[top] -= 1",
      "mutated_line": "counter[top] -= 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 2\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter[top] -= 1",
      "mutated_line": "counter[top] -= 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 0\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter[top] -= 1",
      "mutated_line": "counter[top] -= 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 0\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter[top] -= 1",
      "mutated_line": "counter[top] -= -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= -1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "answer += x",
      "mutated_line": "answer -= x",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer -= x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "counter[bottom] += 1",
      "mutated_line": "counter[bottom] += 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 2\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "counter[bottom] += 1",
      "mutated_line": "counter[bottom] += 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 0\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "counter[bottom] += 1",
      "mutated_line": "counter[bottom] += 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 0\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "counter[bottom] += 1",
      "mutated_line": "counter[bottom] += -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += -1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "counter[top] += 1",
      "mutated_line": "counter[top] += 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 2\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "counter[top] += 1",
      "mutated_line": "counter[top] += 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 0\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "counter[top] += 1",
      "mutated_line": "counter[top] += 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 0\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "counter[top] += 1",
      "mutated_line": "counter[top] += -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += -1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) - (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) - (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = (x + (y << 10)) * (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = (x + (y << 10)) * (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif a == c and b == d:",
      "mutated_line": "elif a != c and b == d:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a != c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif a == c and b == d:",
      "mutated_line": "elif a == c and b != d:",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b != d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "symmetry[t] = 2",
      "mutated_line": "symmetry[t] = 3",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 3\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "symmetry[t] = 2",
      "mutated_line": "symmetry[t] = 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 1\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "symmetry[t] = 2",
      "mutated_line": "symmetry[t] = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 0\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "symmetry[t] = 2",
      "mutated_line": "symmetry[t] = 1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 1\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "symmetry[t] = 2",
      "mutated_line": "symmetry[t] = -2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = -2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "symmetry[t] = 1",
      "mutated_line": "symmetry[t] = 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 2\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "symmetry[t] = 1",
      "mutated_line": "symmetry[t] = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 0\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "symmetry[t] = 1",
      "mutated_line": "symmetry[t] = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 0\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "symmetry[t] = 1",
      "mutated_line": "symmetry[t] = -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = -1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(2, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(2, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(0, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(0, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(0, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(0, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(-1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(-1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n / (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n / (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n + (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n + (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n ** (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n ** (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) / (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) / (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) + (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) + (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), (n * (n - 1)) ** (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), (n * (n - 1)) ** (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) / (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) / (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) + (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) + (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1) * (n - 2)) ** (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1) * (n - 2)) ** (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N + 2)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 2)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N + 0)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 0)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N + 0)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 0)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 0)] * (N + -1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + -1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n * e for e in range(5)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n * e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n + e for e in range(5)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n + e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 2\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 0\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 0\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = -1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "x *= P[counter[tile]][cnt]",
      "mutated_line": "x /= P[counter[tile]][cnt]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x /= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "x *= power[symmetry[tile]][cnt]",
      "mutated_line": "x /= power[symmetry[tile]][cnt]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x /= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x - (y << 10) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x - (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x * (y << 10) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x * (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) + (w << 31)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 31)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) + (w << 29)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 29)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) + (w << 0)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 0)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) + (w << 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 1)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 20) + (w << -30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << -30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [1, 10, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [1, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [-1, 10, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [-1, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [1, 10, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [1, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 11, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 11, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 9, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 9, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 0, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 0, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 1, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 1, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, -10, 20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, -10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 21, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 21, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 19, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 19, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 0, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 0, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 1, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 1, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, -20, 30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, -20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 20, 31]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 31]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 20, 29]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 29]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 20, 0]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 0]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 20, 1]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 1]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return [x >> n & mask for n in [0, 10, 20, 30]]",
      "mutated_line": "return [x >> n & mask for n in [0, 10, 20, -30]]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, -30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n + 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n + 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n * 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n * 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n / (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n / (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), (n + (n - 1)) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), (n + (n - 1)) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n ** (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n ** (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n + 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n + 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n * 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n * 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) / (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) / (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1) + (n - 2)) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1) + (n - 2)) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1)) ** (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n * (n - 1)) ** (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n + 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n + 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n * 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n * 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N - 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N - 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N * 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N * 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(1, 0, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(1, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(-1, 0, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(-1, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(1, 0, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(1, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 1, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 1, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, -1, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, -1, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 1, 0, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 1, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 1, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 1, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, -1, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, -1, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 1, 0, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 1, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 1, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 1, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, -1, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, -1, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 1, 0)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 1, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 1)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 1)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, -1)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, -1)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P += [(0, 0, 0, 0, 0)] * (N + 1)",
      "mutated_line": "P += [(0, 0, 0, 0, 1)] * (N + 1)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 1)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(5)] for n in range(6)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(6)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(5)] for n in range(4)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(4)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(5)] for n in range(0)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(0)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(5)] for n in range(1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(1)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(5)] for n in range(-5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(-5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 21) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 21) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 19) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 19) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 0) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 0) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << 1) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 1) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 10) + (z << -20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << -20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 2), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 2), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 0), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 0), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 0), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 0), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - -1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - -1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n + 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n + 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n * 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n * 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 3), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 3), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 1), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 1), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 0), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 0), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 1), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 1), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - -2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - -2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n / (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n / (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n + (n - 1)) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), (n + (n - 1)) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n ** (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n ** (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n + 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n + 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n * 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n * 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 4)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 4)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 2)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 2)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 0)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 0)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 1)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 1)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - -3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - -3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 2)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 2)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 0)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 0)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 0)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 0)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + -1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + -1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(6)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(6)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(4)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(4)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(0)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(0)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(1)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(1)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "power = [[n ** e for e in range(5)] for n in range(5)]",
      "mutated_line": "power = [[n ** e for e in range(-5)] for n in range(5)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(-5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 11) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 11) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 9) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 9) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 0) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 0) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << 1) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 1) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u = x + (y << 10) + (z << 20) + (w << 30)",
      "mutated_line": "u = x + (y << -10) + (z << 20) + (w << 30)",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << -10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 2) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 2) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 0) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 0) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 0) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 0) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - -1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - -1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n + 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n + 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n * 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n * 1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 3) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 3) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 1) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 1) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 0) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 0) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 1) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 1) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - -2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - -2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 2) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 2) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 0) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 0) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 0) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 0) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - 1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "mutated_line": "P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - -1) * (n - 2) * (n - 3)) for n in range(N + 1)]",
      "code": "from collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\nmask = (1 << 10) - 1\nsymmetry = defaultdict(int)\n\ndef encode(a, b, c, d):\n    t = 1 << 40\n    for (x, y, z, w) in [(a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [x >> n & mask for n in [0, 10, 20, 30]]\n\ndef count_possible_cubes(N, tiles):\n    encoded_tiles = [encode(a, b, c, d) for (a, b, c, d) in tiles]\n    counter = Counter(encoded_tiles)\n    P = [(1, n, n * (n - 1), n * (n - 1) * (n - 2), n * (n - -1) * (n - 2) * (n - 3)) for n in range(N + 1)]\n    P += [(0, 0, 0, 0, 0)] * (N + 1)\n    power = [[n ** e for e in range(5)] for n in range(5)]\n    answer = 0\n    for (bottom, top) in itertools.combinations(encoded_tiles, 2):\n        counter[bottom] -= 1\n        counter[top] -= 1\n        (a, b, c, d) = decode(bottom)\n        (e, f, g, h) = decode(top)\n        for (x, y, z, w) in [(e, f, g, h), (f, g, h, e), (g, h, e, f), (h, e, f, g)]:\n            encoded_tiles = [encode(p, q, r, s) for (p, q, r, s) in [(b, a, x, w), (c, b, w, z), (d, c, z, y), (a, d, y, x)]]\n            need = Counter(encoded_tiles)\n            x = 1\n            for (tile, cnt) in need.items():\n                x *= P[counter[tile]][cnt]\n                x *= power[symmetry[tile]][cnt]\n            answer += x\n        counter[bottom] += 1\n        counter[top] += 1\n    answer //= 3\n    return answer"
    }
  ]
}