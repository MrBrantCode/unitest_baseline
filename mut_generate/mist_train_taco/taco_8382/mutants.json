{
  "task_id": "taco_8382",
  "entry_point": "find_shortest_cycle_length",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 1000000000",
      "mutated_line": "inf = 1000000001",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000001\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 1000000000",
      "mutated_line": "inf = 999999999",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 999999999\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 1000000000",
      "mutated_line": "inf = 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 0\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 1000000000",
      "mutated_line": "inf = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 1000000000",
      "mutated_line": "inf = -1000000000",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = -1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = 0",
      "mutated_line": "mat = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 1\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = 0",
      "mutated_line": "mat = -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = -1\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = 0",
      "mutated_line": "mat = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 1\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [0] / n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] / n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [0] + n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] + n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [0] ** n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] ** n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 1\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = -1\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 1\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x += 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y += 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "deg[x] += 1",
      "mutated_line": "deg[x] -= 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] -= 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "deg[y] += 1",
      "mutated_line": "deg[y] -= 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] -= 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "sum_weights += w",
      "mutated_line": "sum_weights -= w",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights -= w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum_weights + answer",
      "mutated_line": "return sum_weights - answer",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights - answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum_weights + answer",
      "mutated_line": "return sum_weights * answer",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights * answer"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(v) == 0:",
      "mutated_line": "if len(v) != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) != 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 1\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = -1\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 1\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(v):",
      "mutated_line": "while i <= len(v):",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i <= len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(v):",
      "mutated_line": "while i >= len(v):",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i >= len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < len(v):",
      "mutated_line": "while i != len(v):",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i != len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "mat += graph[se][end]",
      "mutated_line": "mat -= graph[se][end]",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat -= graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "mat -= graph[se][end]",
      "mutated_line": "mat += graph[se][end]",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat += graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i -= 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph = [[inf] * n for _ in range(n)]",
      "mutated_line": "graph = [[inf] / n for _ in range(n)]",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] / n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph = [[inf] * n for _ in range(n)]",
      "mutated_line": "graph = [[inf] + n for _ in range(n)]",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] + n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph = [[inf] * n for _ in range(n)]",
      "mutated_line": "graph = [[inf] ** n for _ in range(n)]",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] ** n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "graph[i][i] = 0",
      "mutated_line": "graph[i][i] = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 1\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "graph[i][i] = 0",
      "mutated_line": "graph[i][i] = -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = -1\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "graph[i][i] = 0",
      "mutated_line": "graph[i][i] = 1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 1\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 2\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 0\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 0\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= -1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 2\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 0\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 0\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= -1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "deg[x] += 1",
      "mutated_line": "deg[x] += 2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 2\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "deg[x] += 1",
      "mutated_line": "deg[x] += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 0\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "deg[x] += 1",
      "mutated_line": "deg[x] += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 0\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "deg[x] += 1",
      "mutated_line": "deg[x] += -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += -1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "deg[y] += 1",
      "mutated_line": "deg[y] += 2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 2\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "deg[y] += 1",
      "mutated_line": "deg[y] += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 0\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "deg[y] += 1",
      "mutated_line": "deg[y] += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 0\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "deg[y] += 1",
      "mutated_line": "deg[y] += -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += -1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf or deg[i] > 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf or deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 2 == 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 == 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(v) == 0:",
      "mutated_line": "if len(v) == 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 1:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(v) == 0:",
      "mutated_line": "if len(v) == -1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == -1:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(v) == 0:",
      "mutated_line": "if len(v) == 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 1:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 2\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 0\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 0\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += -1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [1] * n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [1] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [-1] * n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [-1] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deg = [0] * n",
      "mutated_line": "deg = [1] * n",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [1] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] != inf and deg[i] > 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] != inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] >= 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] >= 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] <= 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] <= 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] != 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return +1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] * 2 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] * 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] + 2 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] + 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 2 != 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 1:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 2 != -1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != -1:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 2 != 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 1:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] > 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 1:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] > -1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > -1:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[0][i] == inf and deg[i] > 1:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 1:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -2\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -0\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -0\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return --1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 3 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 3 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 1 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 1 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 0 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 0 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % 1 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 1 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if deg[i] % 2 != 0:",
      "mutated_line": "if deg[i] % -2 != 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % -2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])",
      "mutated_line": "graph[j][k] = min(graph[j][k], graph[j][i] - graph[i][k])",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] - graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])",
      "mutated_line": "graph[j][k] = min(graph[j][k], graph[j][i] * graph[i][k])",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] * graph[i][k])\n    for i in range(n):\n        if graph[0][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[1][i] == inf and deg[i] > 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[1][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[-1][i] == inf and deg[i] > 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[-1][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if graph[0][i] == inf and deg[i] > 0:",
      "mutated_line": "if graph[1][i] == inf and deg[i] > 0:",
      "code": "import math\n\ndef find_shortest_cycle_length(n, m, edges):\n    inf = 1000000000\n    answer = inf\n    mat = 0\n\n    def Get_Cycle_Length(v, graph):\n        nonlocal mat, answer\n        if len(v) == 0:\n            answer = min(answer, mat)\n            return\n        end = v.pop()\n        i = 0\n        while i < len(v):\n            se = v.pop(i)\n            mat += graph[se][end]\n            Get_Cycle_Length(v, graph)\n            mat -= graph[se][end]\n            v.insert(i, se)\n            i += 1\n        v.append(end)\n    graph = [[inf] * n for _ in range(n)]\n    deg = [0] * n\n    sum_weights = 0\n    for i in range(n):\n        graph[i][i] = 0\n    for (x, y, w) in edges:\n        x -= 1\n        y -= 1\n        deg[x] += 1\n        deg[y] += 1\n        graph[x][y] = min(graph[x][y], w)\n        graph[y][x] = min(graph[y][x], w)\n        sum_weights += w\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])\n    for i in range(n):\n        if graph[1][i] == inf and deg[i] > 0:\n            return -1\n    v = []\n    for i in range(n):\n        if deg[i] % 2 != 0:\n            v.append(i)\n    Get_Cycle_Length(v, graph)\n    return sum_weights + answer"
    }
  ]
}