{
  "task_id": "taco_3588",
  "entry_point": "minimum_operations_to_sort_permutation",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] / (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] / (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] + (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] + (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] ** (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] ** (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans = N - max(L)",
      "mutated_line": "ans = N + max(L)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N + max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans = N - max(L)",
      "mutated_line": "ans = N * max(L)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N * max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N - 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N - 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N * 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N * 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N or L[P[i] + 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N or L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if L[P[i]] == 1:",
      "mutated_line": "if L[P[i]] != 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] != 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [2] * (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [2] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [0] * (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [0] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [0] * (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [0] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [-1] * (N + 1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [-1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N + 2)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 2)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N + 0)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 0)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N + 0)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 0)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = [1] * (N + 1)",
      "mutated_line": "L = [1] * (N + -1)",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + -1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] <= N and L[P[i] + 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] <= N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] >= N and L[P[i] + 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] >= N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] != N and L[P[i] + 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] != N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 1] != 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] != 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] - 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] - 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] * 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] * 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if L[P[i]] == 1:",
      "mutated_line": "if L[P[i]] == 2:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 2:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if L[P[i]] == 1:",
      "mutated_line": "if L[P[i]] == 0:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 0:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if L[P[i]] == 1:",
      "mutated_line": "if L[P[i]] == 0:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 0:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if L[P[i]] == 1:",
      "mutated_line": "if L[P[i]] == -1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == -1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L[P[i]] = 0",
      "mutated_line": "L[P[i]] = 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 1\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L[P[i]] = 0",
      "mutated_line": "L[P[i]] = -1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = -1\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L[P[i]] = 0",
      "mutated_line": "L[P[i]] = 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 1\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 1] == 2:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 2:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 1] == 0:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 0:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 1] == 0:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 0:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 1] == -1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == -1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] - 1] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] - 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] * 1] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] * 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] + 2",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 2\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] + 0",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 0\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] + 0",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 0\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 1] = L[P[i]] + -1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 1] = L[P[i]] + -1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] - 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] - 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] * 1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] * 1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 2] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 2] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 0] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 0] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + 0] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + 0] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "L[P[i] + 1] = L[P[i]] + 1",
      "mutated_line": "L[P[i] + -1] = L[P[i]] + 1",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 1] == 1:\n            L[P[i] + -1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 2] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 2] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 0] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 0] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + 0] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + 0] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if P[i] < N and L[P[i] + 1] == 1:",
      "mutated_line": "if P[i] < N and L[P[i] + -1] == 1:",
      "code": "def minimum_operations_to_sort_permutation(P):\n    N = len(P)\n    L = [1] * (N + 1)\n    for i in range(N):\n        if P[i] < N and L[P[i] + -1] == 1:\n            L[P[i] + 1] = L[P[i]] + 1\n        if L[P[i]] == 1:\n            L[P[i]] = 0\n    ans = N - max(L)\n    return ans"
    }
  ]
}