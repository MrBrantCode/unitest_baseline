{
  "task_id": "taco_15942",
  "entry_point": "fib_mod",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n < 2:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n < 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n > 2:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n > 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n == 2:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n == 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mask = 4",
      "mutated_line": "mask = 5",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 5\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mask = 4",
      "mutated_line": "mask = 3",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 3\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mask = 4",
      "mutated_line": "mask = 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 0\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mask = 4",
      "mutated_line": "mask = 1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mask = 4",
      "mutated_line": "mask = -4",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = -4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while mask <= n:",
      "mutated_line": "while mask < n:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask < n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while mask <= n:",
      "mutated_line": "while mask > n:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask > n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while mask <= n:",
      "mutated_line": "while mask == n:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask == n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mask >>= 2",
      "mutated_line": "mask >>= 3",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 3\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mask >>= 2",
      "mutated_line": "mask >>= 1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 1\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mask >>= 2",
      "mutated_line": "mask >>= 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 0\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mask >>= 2",
      "mutated_line": "mask >>= 1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 1\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mask >>= 2",
      "mutated_line": "mask >>= -2",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= -2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 - 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 - 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 * 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 * 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 3:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 3:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 1:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 0:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 0:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 1:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= -2:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= -2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mask <<= 1",
      "mutated_line": "mask <<= 2",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 2\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mask <<= 1",
      "mutated_line": "mask <<= 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 0\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mask <<= 1",
      "mutated_line": "mask <<= 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 0\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mask <<= 1",
      "mutated_line": "mask <<= -1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= -1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (2, 1)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (2, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (0, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (0, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (-1, 1)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (-1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 2)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 2)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 0)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 0)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, -1)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, -1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if mask & n:",
      "mutated_line": "if mask | n:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask | n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mask >>= 1",
      "mutated_line": "mask >>= 2",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 2\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mask >>= 1",
      "mutated_line": "mask >>= 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 0\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mask >>= 1",
      "mutated_line": "mask >>= 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 0\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mask >>= 1",
      "mutated_line": "mask >>= -1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= -1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 * 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 * 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 + 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 + 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 8):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 8):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 6):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 6):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 0):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 0):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 1):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 1):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + -7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + -7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 2\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 0\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 0\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = -1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) * mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) * mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) + mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) + mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) * mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) * mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) + mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) + mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=11 ** 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=11 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=9 ** 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=9 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=0 ** 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=0 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=1 ** 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=1 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=-10 ** 9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=-10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 10 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 10 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 8 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 8 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 0 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 0 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** 1 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 1 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10**9 + 7):",
      "mutated_line": "def compute_lcm_of_fibonacci(N, indices, MOD=10 ** -9 + 7):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** -9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans * fib_mod(c, MOD)[0] * MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] * MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans * fib_mod(c, MOD)[0] + MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] + MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "t = 1",
      "mutated_line": "t = 2",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 2\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 0\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 0\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "t = 1",
      "mutated_line": "t = -1",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = -1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 2, MOD) * MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) * MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 2, MOD) + MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) + MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) * mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) * mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = (a * a + b * b + mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = (a * a + b * b + mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) * mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) * mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) + mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) + mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) * mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) * mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) + mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) + mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) * mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) * mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, a * a + b * b + mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, a * a + b * b + mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i - 1, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i - 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i * 1, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i * 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] % seq[i] != 0:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] != 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans / fib_mod(c, MOD)[0] % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans / fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = (ans + fib_mod(c, MOD)[0]) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = (ans + fib_mod(c, MOD)[0]) % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans ** fib_mod(c, MOD)[0] % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans ** fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans / pow(k, MOD - 2, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans / pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = (ans + pow(k, MOD - 2, MOD)) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = (ans + pow(k, MOD - 2, MOD)) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans ** pow(k, MOD - 2, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans ** pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n - 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n - 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n * 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n * 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 2) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 2) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 0) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 0) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 0) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 0) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> -1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> -1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n - 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n - 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n * 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n * 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 2) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 2) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 0) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 0) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 0) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 0) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 2 >> -1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> -1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a - b * b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a - b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = (a * a * (b * b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = (a * a * (b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b / ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b / ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, (b + ((a << 1) + b)) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, (b + ((a << 1) + b)) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b ** ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b ** ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a / ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a / ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = ((a + ((b << 1) - a)) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = ((a + ((b << 1) - a)) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a ** ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a ** ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a - b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a - b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, a * a * (b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, a * a * (b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i + 2, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 2, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i + 0, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 0, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i + 0, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 0, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(seq)):",
      "mutated_line": "for j in range(i + -1, len(seq)):",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + -1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] * seq[i] == 0:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] * seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] + seq[i] == 0:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] + seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] % seq[i] == 1:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 1:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] % seq[i] == -1:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == -1:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if seq[j] % seq[i] == 0:",
      "mutated_line": "if seq[j] % seq[i] == 1:",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 1:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 2 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 2 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 0 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 0 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 0 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 0 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + -1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + -1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 3 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 3 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 1 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 1 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 0 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 0 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + 1 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 1 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)",
      "mutated_line": "return ((n + 1 >> 1) % mod, (n + -2 >> 1) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + -2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a / a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a / a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a + a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a + a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a ** a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a ** a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b / b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b / b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + (b + b)) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + (b + b)) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b ** b) % mod, b * ((a << 1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b ** b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) - b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) - b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) * b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) + a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) + a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) * a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) * a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a / a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a / a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a + a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a + a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a ** a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a ** a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b / b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b / b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + (b + b)) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + (b + b)) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b ** b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b ** b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans * fib_mod(c, MOD)[1] % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[1] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans * fib_mod(c, MOD)[-1] % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[-1] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = ans * fib_mod(c, MOD)[0] % MOD",
      "mutated_line": "ans = ans * fib_mod(c, MOD)[1] % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[1] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD + 2, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD + 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD * 2, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD * 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 3, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 3, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 1, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 1, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 0, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 0, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - 1, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 1, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = ans * pow(k, MOD - 2, MOD) % MOD",
      "mutated_line": "ans = ans * pow(k, MOD - -2, MOD) % MOD",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - -2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 2) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 2) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 0) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 0) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 0) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 0) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)",
      "mutated_line": "(a, b) = ((a * a + b * b) % mod, b * ((a << -1) + b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << -1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 2) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 2) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 0) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 0) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << 0) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << 0) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(a, b) = (a * ((b << 1) - a) % mod, (a * a + b * b) % mod)",
      "mutated_line": "(a, b) = (a * ((b << -1) - a) % mod, (a * a + b * b) % mod)",
      "code": "import sys\nfrom math import gcd\n\ndef fib_mod(n, mod):\n    if n <= 2:\n        return ((n + 1 >> 1) % mod, (n + 2 >> 1) % mod)\n    mask = 4\n    while mask <= n:\n        mask <<= 1\n    mask >>= 2\n    (a, b) = (1, 1)\n    while mask:\n        if mask & n:\n            (a, b) = ((a * a + b * b) % mod, b * ((a << 1) + b) % mod)\n        else:\n            (a, b) = (a * ((b << -1) - a) % mod, (a * a + b * b) % mod)\n        mask >>= 1\n    return (a, b)\n\ndef compute_lcm_of_fibonacci(N, indices, MOD=10 ** 9 + 7):\n\n    def solve(seq):\n        seq = sorted(seq)\n        next = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                if seq[j] % seq[i] == 0:\n                    break\n            else:\n                next.append(seq[i])\n        seq = next[:]\n        ans = 1\n        for i in range(len(seq)):\n            c = seq[i]\n            ans = ans * fib_mod(c, MOD)[0] % MOD\n            t = 1\n            s = set()\n            for g in seq[:i]:\n                s.add(gcd(g, c))\n            s = list(sorted(s))\n            k = solve(s)\n            ans = ans * pow(k, MOD - 2, MOD) % MOD\n        return ans\n    return solve(indices)"
    }
  ]
}