{
  "task_id": "taco_3028",
  "entry_point": "count_recoverable_permutations",
  "mutant_count": 252,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 - 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 * 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ct = 0",
      "mutated_line": "ct = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 1\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ct = 0",
      "mutated_line": "ct = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = -1\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ct = 0",
      "mutated_line": "ct = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 1\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] / 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] / 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] + 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] + 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] ** 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] ** 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] / 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] / 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] + 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] + 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] ** 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] ** 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ct2 = 0",
      "mutated_line": "ct2 = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 1\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ct2 = 0",
      "mutated_line": "ct2 = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = -1\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ct2 = 0",
      "mutated_line": "ct2 = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 1\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 1\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = -1\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 1\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans -= pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans -= pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 * 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 + 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 8\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 6\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 0\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 1\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + -7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 2\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 0\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 0\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = -1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p >= 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p >= 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p <= 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p <= 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p != 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p != 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return res % mod",
      "mutated_line": "return res * mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res * mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return res % mod",
      "mutated_line": "return res + mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res + mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 * 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 * 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 + 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 + 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) * mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) * mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) + mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) + mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] * 2002",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2002\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] * 2000",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2000\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] * 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 0\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] * 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 1\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [0] * -2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * -2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] * 2002",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2002\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] * 2000",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2000\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] * 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 0\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] * 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 1\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [0] * -2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * -2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] != -1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] != -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ct += 1",
      "mutated_line": "ct -= 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct -= 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(2, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(0, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(0, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(-1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n - 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n * 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 1 or lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 or lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "ct2 += 1",
      "mutated_line": "ct2 -= 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 -= 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 - 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 - 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 * 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 * 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) * combination(ct2, i) / fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) / fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) * combination(ct2, i) + fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) + fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += (pow(-1, i) * combination(ct2, i)) ** fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += (pow(-1, i) * combination(ct2, i)) ** fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 11 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 9 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 0 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 1 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = -10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 10 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 8 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 0 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 1 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** -9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 != 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 != 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 2 if n % 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 2 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 0 if n % 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 0 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 0 if n % 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 0 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return -1 if n % 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return -1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == 0 else 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 1\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == 0 else -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else -1\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == 0 else 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 1\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 1:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p > -1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > -1:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 1:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 2 != 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 != 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "p -= 1",
      "mutated_line": "p += 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p += 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=11 ** 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=11 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=9 ** 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=9 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=0 ** 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=0 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=1 ** 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=1 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=-10 ** 5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=-10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 ** 6, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 6, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 ** 4, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 4, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 ** 0, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 0, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 ** 1, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 1, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "def factrial_memo(n=10**5, mod=mod):",
      "mutated_line": "def factrial_memo(n=10 ** -5, mod=mod):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** -5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [2, 1]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [2, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [0, 1]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [0, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [0, 1]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [0, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [-1, 1]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [-1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [1, 2]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 2]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [1, 0]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 0]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [1, 0]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 0]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fact = [1, 1]",
      "mutated_line": "fact = [1, -1]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, -1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(3, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(1, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(0, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(1, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(-2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n - 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n * 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod / pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod / pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return (fact[n] * pow(fact[n - r], mod - 2) % mod + pow(fact[r], mod - 2)) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return (fact[n] * pow(fact[n - r], mod - 2) % mod + pow(fact[r], mod - 2)) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return (fact[n] * pow(fact[n - r], mod - 2) % mod) ** pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return (fact[n] * pow(fact[n - r], mod - 2) % mod) ** pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [1] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [-1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [-1] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "lst2 = [0] * 2001",
      "mutated_line": "lst2 = [1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [1] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [1] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [-1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [-1] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst3 = [0] * 2001",
      "mutated_line": "lst3 = [1] * 2001",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [1] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] == +1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == +1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ct += 1",
      "mutated_line": "ct += 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 2\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ct += 1",
      "mutated_line": "ct += 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 0\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ct += 1",
      "mutated_line": "ct += 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 0\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ct += 1",
      "mutated_line": "ct += -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += -1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 1] = 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 2\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 1] = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 0\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 1] = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 0\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 1] = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = -1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lst2[permutation[i]] = 1",
      "mutated_line": "lst2[permutation[i]] = 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 2\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lst2[permutation[i]] = 1",
      "mutated_line": "lst2[permutation[i]] = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 0\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lst2[permutation[i]] = 1",
      "mutated_line": "lst2[permutation[i]] = 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 0\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lst2[permutation[i]] = 1",
      "mutated_line": "lst2[permutation[i]] = -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = -1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 2):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 0):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 0):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + -1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] != 1 and lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] != 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 1 and lst2[i] != 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] != 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ct2 += 1",
      "mutated_line": "ct2 += 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 2\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ct2 += 1",
      "mutated_line": "ct2 += 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 0\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ct2 += 1",
      "mutated_line": "ct2 += 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 0\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ct2 += 1",
      "mutated_line": "ct2 += -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += -1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 + 2):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 2):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 0):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 0):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(ct2 + 1):",
      "mutated_line": "for i in range(ct2 + -1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + -1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) / combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) / combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += (pow(-1, i) + combination(ct2, i)) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += (pow(-1, i) + combination(ct2, i)) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) ** combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) ** combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n * 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n * 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n + 2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n + 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == 1 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 1 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == -1 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == -1 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 2 == 1 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 1 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p * 2 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p * 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p + 2 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p + 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 2 == 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 1:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 2 == -1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == -1:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 2 == 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 1:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 2 * mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 * mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 2 + mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 + mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p //= 2",
      "mutated_line": "p //= 3",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 3\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 1\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p //= 2",
      "mutated_line": "p //= 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 0\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 1\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p //= 2",
      "mutated_line": "p //= -2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= -2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = res * n % mod",
      "mutated_line": "res = res * n * mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n * mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = res * n % mod",
      "mutated_line": "res = res * n + mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n + mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p -= 1",
      "mutated_line": "p -= 2",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 2\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 0\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 0\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p -= 1",
      "mutated_line": "p -= -1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= -1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 2):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 0):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 0):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + -1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-1] * i * mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i * mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-1] * i + mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i + mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) * mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) * mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return (fact[n] * pow(fact[n - r], mod - 2) + mod) * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return (fact[n] * pow(fact[n - r], mod - 2) + mod) * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] == -2:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -2:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] == -0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -0:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] == -0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -0:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if permutation[i] == -1:",
      "mutated_line": "if permutation[i] == --1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == --1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i - 1] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i - 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i * 1] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i * 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 2 and lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 2 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 0 and lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 0 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 0 and lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 0 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == -1 and lst2[i] == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == -1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 1 and lst2[i] == 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 1:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 1 and lst2[i] == -1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == -1:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if lst3[i] == 1 and lst2[i] == 0:",
      "mutated_line": "if lst3[i] == 1 and lst2[i] == 1:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 1:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct + i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct + i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct * i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct * i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 3 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 3 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 1 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 1 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 0 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 0 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % 1 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 1 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1 if n % 2 == 0 else 0",
      "mutated_line": "return 1 if n % -2 == 0 else 0",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % -2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 3 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 3 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 1 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 1 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 0 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 0 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % 1 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 1 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if p % 2 == 0:",
      "mutated_line": "if p % -2 == 0:",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % -2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n * 2 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n * 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = (n + 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = (n + 2) % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = res * n % mod",
      "mutated_line": "res = res / n % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res / n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = res * n % mod",
      "mutated_line": "res = (res + n) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = (res + n) % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = res * n % mod",
      "mutated_line": "res = res ** n % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res ** n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-1] / i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] / i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append((fact[-1] + i) % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append((fact[-1] + i) % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-1] ** i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] ** i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] / pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] / pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return (fact[n] + pow(fact[n - r], mod - 2)) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return (fact[n] + pow(fact[n - r], mod - 2)) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] ** pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] ** pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod + 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod + 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod * 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod * 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 2] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 2] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 0] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 0] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + 0] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 0] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lst3[i + 1] = 1",
      "mutated_line": "lst3[i + -1] = 1",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + -1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(+1, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(+1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 3 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 3 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 1 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 1 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 0 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 0 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** 1 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 1 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "n = n ** 2 % mod",
      "mutated_line": "n = n ** -2 % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** -2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 3) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 3) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 1) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 1) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 0) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 0) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 1) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 1) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - -2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - -2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-2, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-2, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-0, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-0, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(-0, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-0, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]",
      "mutated_line": "ans += pow(--1, i) * combination(ct2, i) * fact[ct - i]",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(--1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[+1] * i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[+1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod + 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod + 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod * 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod * 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-2] * i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-2] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-0] * i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-0] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[-0] * i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-0] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fact.append(fact[-1] * i % mod)",
      "mutated_line": "fact.append(fact[--1] * i % mod)",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[--1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n + r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n + r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n * r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n * r], mod - 2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 3) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 3) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 1) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 1) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 0) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 0) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - 1) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - 1) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return fact[n] * pow(fact[n - r], mod - 2) % mod * pow(fact[r], mod - 2) % mod",
      "mutated_line": "return fact[n] * pow(fact[n - r], mod - -2) % mod * pow(fact[r], mod - 2) % mod",
      "code": "def count_recoverable_permutations(n, permutation):\n    mod = 10 ** 9 + 7\n\n    def even(n):\n        return 1 if n % 2 == 0 else 0\n\n    def pow(n, p, mod=mod):\n        res = 1\n        while p > 0:\n            if p % 2 == 0:\n                n = n ** 2 % mod\n                p //= 2\n            else:\n                res = res * n % mod\n                p -= 1\n        return res % mod\n\n    def factrial_memo(n=10 ** 5, mod=mod):\n        fact = [1, 1]\n        for i in range(2, n + 1):\n            fact.append(fact[-1] * i % mod)\n        return fact\n    fact = factrial_memo()\n\n    def combination(n, r):\n        return fact[n] * pow(fact[n - r], mod - -2) % mod * pow(fact[r], mod - 2) % mod\n    ct = 0\n    lst2 = [0] * 2001\n    lst3 = [0] * 2001\n    for i in range(n):\n        if permutation[i] == -1:\n            ct += 1\n            lst3[i + 1] = 1\n        else:\n            lst2[permutation[i]] = 1\n    ct2 = 0\n    for i in range(1, n + 1):\n        if lst3[i] == 1 and lst2[i] == 0:\n            ct2 += 1\n    ans = 0\n    for i in range(ct2 + 1):\n        ans += pow(-1, i) * combination(ct2, i) * fact[ct - i]\n        ans %= mod\n    return ans"
    }
  ]
}