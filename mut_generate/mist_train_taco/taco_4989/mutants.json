{
  "task_id": "taco_4989",
  "entry_point": "count_restorable_arrays",
  "mutant_count": 566,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "l -= 1",
      "mutated_line": "l += 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l += 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 - 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 * 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l -= 1",
      "mutated_line": "l -= 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 2\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 0\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 0\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l -= 1",
      "mutated_line": "l -= -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= -1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 3 != 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 != 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 3 != 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 != 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 * 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 + 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 8\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 6\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 0\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 1\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + -7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [1, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [-1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [-1, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [1, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, 1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 1, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, -1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, -1, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, 1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 1, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, 0, 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 1]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, 0, -1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, -1]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrem = [0, 0, 0]",
      "mutated_line": "lrem = [0, 0, 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 1]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [1, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [-1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [-1, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [1, 0, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [1, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, 1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 1, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, -1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, -1, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, 1, 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 1, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, 0, 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 1]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, 0, -1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, -1]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rrem = [0, 0, 0]",
      "mutated_line": "rrem = [0, 0, 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 1]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l * 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l * 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l + 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l + 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 3 == -1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == -1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l / 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l * 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l / 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l * 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l / 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l * 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 3 != 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 != 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r * 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r * 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r + 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r + 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 3 == -1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == -1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r / 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r * 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r / 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r * 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r / 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r * 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 3 != 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 != 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] + lrem[i] for i in range(3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] + lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] * lrem[i] for i in range(3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] * lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][1] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][1] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][-1] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][-1] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][1] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][1] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[1]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][0] = rem[-1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[-1]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[0][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[1]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][1] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][1] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][-1] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][-1] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][1] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][1] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[2]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[0]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[0]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[1][0] = rem[-1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[-1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][1] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][1] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][-1] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][-1] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][1] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][1] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][0] = rem[3]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[3]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[1]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[0]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[1]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[2][0] = rem[-2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[-2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(2, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(0, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(0, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(-1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) * MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) * MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1] + MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1] + MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) * MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) * MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1] + MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1] + MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) * MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) * MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2] + MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2] + MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n + 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n * 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 11 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 9 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 0 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 1 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = -10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 10 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 8 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 0 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 1 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** -9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 4 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 4 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 2 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 2 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 0 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 0 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % 1 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 1 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if l % 3 == 0:",
      "mutated_line": "if l % -3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % -3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[1] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[-1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[-1] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[1] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 4\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 2\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 0\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 1\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // -3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[2] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[2] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[0] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[0] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[0] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[0] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[-1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[-1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 4\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 2\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 0\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 1\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lrem[1] = l // 3",
      "mutated_line": "lrem[1] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // -3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[3] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[3] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[1] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[0] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[0] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[1] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[-2] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[-2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 4\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 2\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 0\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 1\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // -3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l * 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l * 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l + 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l + 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 3 == 2:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 2:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 3 == -1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == -1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l / 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l * 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 - 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 * 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l / 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l * 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l / 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l * 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 - 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 * 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 - 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 * 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 4 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 4 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 2 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 2 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 0 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 0 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % 1 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 1 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if r % 3 == 0:",
      "mutated_line": "if r % -3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % -3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[1] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[-1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[-1] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[1] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 4\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 2\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 0\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 1\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // -3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[2] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[2] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[0] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[0] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[0] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[0] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[-1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[-1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 4\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 2\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 0\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 1\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "rrem[1] = r // 3",
      "mutated_line": "rrem[1] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // -3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[3] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[3] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[1] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[0] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[0] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[1] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[-2] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[-2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 4\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 2\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 0\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 1\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // -3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r * 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r * 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r + 3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r + 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 3 == 2:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 2:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 3 == 0:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 3 == -1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == -1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r / 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r * 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 - 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 * 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r / 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r * 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r / 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r / 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r * 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r * 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 - 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 * 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 - 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 - 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 * 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 * 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[1 for _ in range(n)] for _ in range(3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[1 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[-1 for _ in range(n)] for _ in range(3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[-1 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[1 for _ in range(n)] for _ in range(3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[1 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[1][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[1][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[-1][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[-1][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[0][0] = rem[0]",
      "mutated_line": "dp[1][0] = rem[0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[1][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[2][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[2][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[0][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[0][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[0][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[0][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[1][0] = rem[1]",
      "mutated_line": "dp[-1][0] = rem[1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[-1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[3][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[3][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[1][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[1][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[0][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[0][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[1][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[1][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[2][0] = rem[2]",
      "mutated_line": "dp[-2][0] = rem[2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[-2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] - dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] - dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2]) * (dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2]) * (dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] - dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] - dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2]) * (dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2]) * (dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] - dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] - dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1]) * (dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1]) * (dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[1][n - 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[-1][n - 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[-1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[1][n - 1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n - 2]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n - 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n - 0]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return dp[0][n - 1]",
      "mutated_line": "return dp[0][n - -1]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - -1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 4 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 4 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 2 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 2 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 0 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 0 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % 1 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 1 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif l % 3 == 1:",
      "mutated_line": "elif l % -3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % -3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[-1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[-1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 4\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 2\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 0\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 1\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // -3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[2] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[0] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[0] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[0] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[0] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[-1] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[-1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l / 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l * 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 2\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 0\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 0\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + -1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[3] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[3] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[1] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[0] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[0] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[1] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[-2] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[-2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 4\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 2\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 0\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 1\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lrem[2] = l // 3",
      "mutated_line": "lrem[2] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // -3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[-1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[-1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[1] = l // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[1] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 4\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 2\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 0\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 1\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lrem[0] = l // 3",
      "mutated_line": "lrem[0] = l // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // -3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[2] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[0] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[0] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[0] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[0] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[-1] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[-1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l / 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l * 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 2\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 0\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 0\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + -1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[3] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[3] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[1] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[0] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[0] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[1] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[-2] = l // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[-2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l / 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l * 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 2\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 0\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 0\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + -1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 4 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 4 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 2 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 2 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 0 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 0 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % 1 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 1 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif r % 3 == 1:",
      "mutated_line": "elif r % -3 == 1:",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % -3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[-1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[-1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 4\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 2\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 0\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 1\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // -3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[2] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[0] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[0] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[0] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[0] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[-1] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[-1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r / 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r * 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 2\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 0\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 0\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + -1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[3] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[3] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[1] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[0] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[0] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[1] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[-2] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[-2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 4\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 2\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 0\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 1\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rrem[2] = r // 3",
      "mutated_line": "rrem[2] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // -3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[-1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[-1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[1] = r // 3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[1] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 4",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 4\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 2\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 0\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 1\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rrem[0] = r // 3",
      "mutated_line": "rrem[0] = r // -3",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // -3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[2] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[0] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[0] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[0] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[0] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[-1] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[-1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r / 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r * 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 2\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 0\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 0\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + -1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[3] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[3] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[1] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[0] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[0] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[1] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[-2] = r // 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[-2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r / 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r / 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r * 3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r * 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 + 2",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 2\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 0\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 + 0",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 0\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 3 + -1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + -1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] - lrem[i] for i in range(4)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(4)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] - lrem[i] for i in range(2)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(2)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] - lrem[i] for i in range(0)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(0)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] - lrem[i] for i in range(1)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(1)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rem = [rrem[i] - lrem[i] for i in range(3)]",
      "mutated_line": "rem = [rrem[i] - lrem[i] for i in range(-3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(-3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[0 for _ in range(n)] for _ in range(4)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(4)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[0 for _ in range(n)] for _ in range(2)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[0 for _ in range(n)] for _ in range(0)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(0)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[0 for _ in range(n)] for _ in range(1)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(1)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(3)]",
      "mutated_line": "dp = [[0 for _ in range(n)] for _ in range(-3)]",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(-3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[-1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[-1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[1][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] - dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] - dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] * (dp[1][i - 1] * rem[2]) + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] * (dp[1][i - 1] * rem[2]) + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] / rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] / rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + (dp[2][i - 1] + rem[1])) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + (dp[2][i - 1] + rem[1])) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] ** rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] ** rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[2][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[0][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[0][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[-1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[-1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] - dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] - dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] * (dp[2][i - 1] * rem[2]) + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] * (dp[2][i - 1] * rem[2]) + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] / rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] / rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + (dp[0][i - 1] + rem[1])) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + (dp[0][i - 1] + rem[1])) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] ** rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] ** rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[3][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[3][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[1][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[0][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[0][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[1][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[-2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[-2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] - dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] - dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] * (dp[1][i - 1] * rem[1]) + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] * (dp[1][i - 1] * rem[1]) + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] / rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] / rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + (dp[0][i - 1] + rem[2])) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + (dp[0][i - 1] + rem[2])) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] ** rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] ** rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 4 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 2 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 0 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 1 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // -3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 4 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 2 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 0 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 1 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lrem[1] = l // 3 + 1",
      "mutated_line": "lrem[1] = l // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // -3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 4 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 2 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 0 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 1 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lrem[2] = l // 3 + 1",
      "mutated_line": "lrem[2] = l // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // -3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 4 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 2 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 0 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 1 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // -3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 4 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 2 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 0 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 1 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "rrem[1] = r // 3 + 1",
      "mutated_line": "rrem[1] = r // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // -3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 4 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 4 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 2 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 2 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 0 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 0 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // 1 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 1 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rrem[2] = r // 3 + 1",
      "mutated_line": "rrem[2] = r // -3 + 1",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // -3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] / rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] / rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] + rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] + rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] ** rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] ** rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] / rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] / rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + (dp[1][i - 1] + rem[2]) + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + (dp[1][i - 1] + rem[2]) + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] ** rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] ** rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] / rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] / rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] + rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] + rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] ** rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] ** rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] / rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] / rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + (dp[2][i - 1] + rem[2]) + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + (dp[2][i - 1] + rem[2]) + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] ** rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] ** rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] / rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] / rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] + rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] + rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] ** rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] ** rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] / rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] / rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + (dp[1][i - 1] + rem[1]) + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + (dp[1][i - 1] + rem[1]) + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] ** rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] ** rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i + 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i + 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i * 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i * 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[2]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[0]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[0]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[0]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[0]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[-1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[-1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i + 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i + 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i * 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i * 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[2]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[0]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[0]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[0]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[0]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[-1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[-1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i + 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i + 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i * 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i * 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[3]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[3]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[0]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[0]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[-2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[-2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i + 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i + 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i * 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i * 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[-1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[-1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[1] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i + 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i + 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i * 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i * 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[3] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[3] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[-2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[-2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[3][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[3][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[-2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[-2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 2] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 2] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 0] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 0] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 0] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 0] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - -1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - -1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i + 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i + 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i * 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i * 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[-1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[-1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[1] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i + 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i + 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i * 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i * 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[3] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[3] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[-2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[-2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[-1][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[-1][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[1][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 2] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 2] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 0] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 0] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 0] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 0] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - -1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - -1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i + 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i + 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i * 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i * 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[-1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[-1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[1] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i + 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i + 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i * 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i * 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[-1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[-1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[1][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[1][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[-1][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[-1][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[1][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[1][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 2] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 2] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 0] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 0] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 0] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 0] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - -1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - -1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[-1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[-1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 2] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 2] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 0] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 0] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 0] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 0] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - -1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - -1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[-1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[-1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 2] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 2] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 0] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 0] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 0] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 0] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - -1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - -1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[2][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[2][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[0][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[-1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[-1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 2] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 2] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 0] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 0] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 0] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 0] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - -1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - -1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[3][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[3][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[0][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[-2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[-2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 2] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 2] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 0] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 0] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 0] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 0] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "mutated_line": "dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - -1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - -1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[3][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[3][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[1][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[-2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[-2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 2] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 2] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 0] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 0] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 0] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 0] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - -1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - -1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[2][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[0][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[-1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[-1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 2] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 2] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 0] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 0] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 0] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 0] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - 1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "mutated_line": "dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - -1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD",
      "code": "def count_restorable_arrays(n, l, r):\n    MOD = 10 ** 9 + 7\n    l -= 1\n    lrem = [0, 0, 0]\n    rrem = [0, 0, 0]\n    if l % 3 == 0:\n        lrem[0] = l // 3\n        lrem[1] = l // 3\n        lrem[2] = l // 3\n    elif l % 3 == 1:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3\n    else:\n        lrem[0] = l // 3\n        lrem[1] = l // 3 + 1\n        lrem[2] = l // 3 + 1\n    if r % 3 == 0:\n        rrem[0] = r // 3\n        rrem[1] = r // 3\n        rrem[2] = r // 3\n    elif r % 3 == 1:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3\n    else:\n        rrem[0] = r // 3\n        rrem[1] = r // 3 + 1\n        rrem[2] = r // 3 + 1\n    rem = [rrem[i] - lrem[i] for i in range(3)]\n    dp = [[0 for _ in range(n)] for _ in range(3)]\n    dp[0][0] = rem[0]\n    dp[1][0] = rem[1]\n    dp[2][0] = rem[2]\n    for i in range(1, n):\n        dp[0][i] = (dp[0][i - 1] * rem[0] + dp[1][i - 1] * rem[2] + dp[2][i - 1] * rem[1]) % MOD\n        dp[1][i] = (dp[1][i - 1] * rem[0] + dp[2][i - 1] * rem[2] + dp[0][i - 1] * rem[1]) % MOD\n        dp[2][i] = (dp[2][i - 1] * rem[0] + dp[1][i - -1] * rem[1] + dp[0][i - 1] * rem[2]) % MOD\n    return dp[0][n - 1]"
    }
  ]
}