{
  "task_id": "taco_4832",
  "entry_point": "find_minimum_dinner_cost",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 * 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 * 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 + 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 + 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 11 ** 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 11 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 9 ** 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 9 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 0 ** 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 0 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 1 ** 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 1 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = -10 ** 9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = -10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 ** 10",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 10\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 ** 8",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 8\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 ** 0",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 0\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 ** 1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 1\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out = 10 ** 9",
      "mutated_line": "out = 10 ** -9",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** -9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] == -1:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] == -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out <= 10 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out <= 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out >= 10 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out >= 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out != 10 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out != 10 ** 9 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 9 else +1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else +1"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "bDic = defaultdict(lambda: -1)",
      "mutated_line": "bDic = defaultdict(lambda : +1)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : +1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i + 1) not in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) not in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "cDic = defaultdict(lambda: -1)",
      "mutated_line": "cDic = defaultdict(lambda : +1)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : +1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] + 1) not in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) not in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] != +1:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != +1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 * 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 * 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 + 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 + 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 9 else -2",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 9 else -0",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 9 else -0",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 9 else --1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else --1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "bDic = defaultdict(lambda: -1)",
      "mutated_line": "bDic = defaultdict(lambda : -2)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -2)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "bDic = defaultdict(lambda: -1)",
      "mutated_line": "bDic = defaultdict(lambda : -0)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -0)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "bDic = defaultdict(lambda: -1)",
      "mutated_line": "bDic = defaultdict(lambda : -0)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -0)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "bDic = defaultdict(lambda: -1)",
      "mutated_line": "bDic = defaultdict(lambda : --1)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : --1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bDic[i] = j[0]",
      "mutated_line": "bDic[i] = j[1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[1]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bDic[i] = j[0]",
      "mutated_line": "bDic[i] = j[-1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[-1]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bDic[i] = j[0]",
      "mutated_line": "bDic[i] = j[1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[1]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cDic = defaultdict(lambda: -1)",
      "mutated_line": "cDic = defaultdict(lambda : -2)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -2)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cDic = defaultdict(lambda: -1)",
      "mutated_line": "cDic = defaultdict(lambda : -0)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -0)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cDic = defaultdict(lambda: -1)",
      "mutated_line": "cDic = defaultdict(lambda : -0)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -0)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cDic = defaultdict(lambda: -1)",
      "mutated_line": "cDic = defaultdict(lambda : --1)",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : --1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cDic[i] = j[0]",
      "mutated_line": "cDic[i] = j[1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[1]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cDic[i] = j[0]",
      "mutated_line": "cDic[i] = j[-1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[-1]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cDic[i] = j[0]",
      "mutated_line": "cDic[i] = j[1]",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[1]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] != -2:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -2:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] != -0:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -0:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] != -0:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -0:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if bDic[i] != -1:",
      "mutated_line": "if bDic[i] != --1:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != --1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] + 1) not in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) not in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 11 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 11 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 9 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 9 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 0 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 0 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 1 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 1 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < -10 ** 9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < -10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 10 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 10 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 8 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 8 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 0 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** 1 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return out if out < 10 ** 9 else -1",
      "mutated_line": "return out if out < 10 ** -9 else -1",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** -9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = sorted(enumerate(A), key=lambda x: x[1])",
      "mutated_line": "a = sorted(enumerate(A), key=lambda x: x[2])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[2])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = sorted(enumerate(A), key=lambda x: x[1])",
      "mutated_line": "a = sorted(enumerate(A), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[0])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = sorted(enumerate(A), key=lambda x: x[1])",
      "mutated_line": "a = sorted(enumerate(A), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[0])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a = sorted(enumerate(A), key=lambda x: x[1])",
      "mutated_line": "a = sorted(enumerate(A), key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[-1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = sorted(enumerate(B), key=lambda x: x[1])",
      "mutated_line": "b = sorted(enumerate(B), key=lambda x: x[2])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[2])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = sorted(enumerate(B), key=lambda x: x[1])",
      "mutated_line": "b = sorted(enumerate(B), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[0])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = sorted(enumerate(B), key=lambda x: x[1])",
      "mutated_line": "b = sorted(enumerate(B), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[0])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = sorted(enumerate(B), key=lambda x: x[1])",
      "mutated_line": "b = sorted(enumerate(B), key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[-1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = sorted(enumerate(C), key=lambda x: x[1])",
      "mutated_line": "c = sorted(enumerate(C), key=lambda x: x[2])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[2])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = sorted(enumerate(C), key=lambda x: x[1])",
      "mutated_line": "c = sorted(enumerate(C), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[0])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = sorted(enumerate(C), key=lambda x: x[1])",
      "mutated_line": "c = sorted(enumerate(C), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[0])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = sorted(enumerate(C), key=lambda x: x[1])",
      "mutated_line": "c = sorted(enumerate(C), key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[-1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = sorted(enumerate(D), key=lambda x: x[1])",
      "mutated_line": "d = sorted(enumerate(D), key=lambda x: x[2])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[2])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = sorted(enumerate(D), key=lambda x: x[1])",
      "mutated_line": "d = sorted(enumerate(D), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[0])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = sorted(enumerate(D), key=lambda x: x[1])",
      "mutated_line": "d = sorted(enumerate(D), key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[0])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = sorted(enumerate(D), key=lambda x: x[1])",
      "mutated_line": "d = sorted(enumerate(D), key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[-1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] - 1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] - 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] * 1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] * 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i - 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i - 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i * 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i * 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i - 1, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i - 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i * 1, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i * 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] - 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] - 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] * 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] * 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] - j[1]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] - j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] * j[1]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] * j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cc.sort(key=lambda x: x[1])",
      "mutated_line": "cc.sort(key=lambda x: x[2])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[2])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cc.sort(key=lambda x: x[1])",
      "mutated_line": "cc.sort(key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[0])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cc.sort(key=lambda x: x[1])",
      "mutated_line": "cc.sort(key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[0])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cc.sort(key=lambda x: x[1])",
      "mutated_line": "cc.sort(key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[-1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[1] + B[i] - A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] - A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, (j[1] + B[i]) * A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, (j[1] + B[i]) * A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 2, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 2, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 0, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 0, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 0, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 0, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + -1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + -1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i + 2) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 2) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i + 0) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 0) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i + 0) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 0) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[0] + 1, i + -1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + -1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 2, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 2, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 0, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 0, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 0, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 0, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + -1, j[0] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + -1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] + 2) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 2) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] + 0) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 0) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] + 0) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 0) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[0] + -1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + -1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i - 1, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i - 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i * 1, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i * 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] - 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] - 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] * 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] * 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[1] - B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] - B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[1] * B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] * B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[1] + 1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[1] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[-1] + 1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[-1] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (j[0] + 1, i + 1) in m1set:",
      "mutated_line": "if (j[1] + 1, i + 1) in m1set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[1] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[1] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[1] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[-1] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[-1] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (i + 1, j[0] + 1) in m3set:",
      "mutated_line": "if (i + 1, j[1] + 1) in m3set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[1] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] + j[2]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[2]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] + j[0]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[0]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] + j[0]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[0]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cc.append((i, C[i] + j[1]))",
      "mutated_line": "cc.append((i, C[i] + j[-1]))",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[-1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 2, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 2, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 0, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 0, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 0, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 0, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + -1, j[0] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + -1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] + 2) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 2) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] + 0) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 0) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] + 0) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 0) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[0] + -1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + -1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[1] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[1] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[-1] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[-1] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i + 1, j[0] + 1) in m2set:",
      "mutated_line": "if (i + 1, j[1] + 1) in m2set:",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[1] + 1) in m2set:\n                    continue\n                out = min(out, j[1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[2] + B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[2] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[0] + B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[0] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[0] + B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[0] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "out = min(out, j[1] + B[i] + A[bDic[i]])",
      "mutated_line": "out = min(out, j[-1] + B[i] + A[bDic[i]])",
      "code": "from collections import defaultdict\n\ndef find_minimum_dinner_cost(n1, n2, n3, n4, A, B, C, D, m1, m1set, m2, m2set, m3, m3set):\n    a = sorted(enumerate(A), key=lambda x: x[1])\n    b = sorted(enumerate(B), key=lambda x: x[1])\n    c = sorted(enumerate(C), key=lambda x: x[1])\n    d = sorted(enumerate(D), key=lambda x: x[1])\n    bDic = defaultdict(lambda : -1)\n    for i in range(n2):\n        for j in a:\n            if (j[0] + 1, i + 1) in m1set:\n                continue\n            bDic[i] = j[0]\n            break\n    cDic = defaultdict(lambda : -1)\n    cc = []\n    for i in range(n3):\n        for j in d:\n            if (i + 1, j[0] + 1) in m3set:\n                continue\n            cDic[i] = j[0]\n            cc.append((i, C[i] + j[1]))\n            break\n    out = 10 ** 9\n    cc.sort(key=lambda x: x[1])\n    for i in range(n2):\n        if bDic[i] != -1:\n            for j in cc:\n                if (i + 1, j[0] + 1) in m2set:\n                    continue\n                out = min(out, j[-1] + B[i] + A[bDic[i]])\n                break\n    return out if out < 10 ** 9 else -1"
    }
  ]
}