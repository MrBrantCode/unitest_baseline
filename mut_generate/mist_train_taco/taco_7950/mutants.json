{
  "task_id": "taco_7950",
  "entry_point": "cut_the_tree",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N / 2000",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N / 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N + 2000",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N + 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N ** 2000",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N ** 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "root = node_at_index[0]",
      "mutated_line": "root = node_at_index[1]",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[1]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "root = node_at_index[0]",
      "mutated_line": "root = node_at_index[-1]",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[-1]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "root = node_at_index[0]",
      "mutated_line": "root = node_at_index[1]",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[1]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))",
      "mutated_line": "n.value_of_subtree = n.value - sum((c.value_of_subtree for c in n.children))",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value - sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))",
      "mutated_line": "n.value_of_subtree = n.value * sum((c.value_of_subtree for c in n.children))",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value * sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N * 2001",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2001\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N * 1999",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 1999\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N * 0",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 0\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N * 1",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 1\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best = N * 2000",
      "mutated_line": "best = N * -2000",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * -2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.value_of_subtree = 0",
      "mutated_line": "self.value_of_subtree = 1",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 1\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.value_of_subtree = 0",
      "mutated_line": "self.value_of_subtree = -1",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = -1\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.value_of_subtree = 0",
      "mutated_line": "self.value_of_subtree = 1",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 1\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tree_b = total - tree_a",
      "mutated_line": "tree_b = total + tree_a",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total + tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tree_b = total - tree_a",
      "mutated_line": "tree_b = total * tree_a",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total * tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dif < best:",
      "mutated_line": "if dif <= best:",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif <= best:\n                best = dif\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dif < best:",
      "mutated_line": "if dif >= best:",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif >= best:\n                best = dif\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dif < best:",
      "mutated_line": "if dif != best:",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif != best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b + 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b + 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b * 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b * 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a + 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a + 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a * 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a * 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dif = abs(tree_a - tree_b)",
      "mutated_line": "dif = abs(tree_a + tree_b)",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a + tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dif = abs(tree_a - tree_b)",
      "mutated_line": "dif = abs(tree_a * tree_b)",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a * tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b - 2])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 2])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b - 0])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 0])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b - 0])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 0])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 1].children.add(node_at_index[b - -1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - -1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a - 2])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 2])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a - 0])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 0])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a - 0])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 0])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 1].children.add(node_at_index[a - -1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - -1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a + 1].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a + 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a * 1].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a * 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b + 1].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b + 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b * 1].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b * 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 2].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 2].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 0].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 0].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - 0].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 0].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "node_at_index[a - 1].children.add(node_at_index[b - 1])",
      "mutated_line": "node_at_index[a - -1].children.add(node_at_index[b - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - -1].children.add(node_at_index[b - 1])\n        node_at_index[b - 1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 2].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 2].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 0].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 0].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - 0].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - 0].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "node_at_index[b - 1].children.add(node_at_index[a - 1])",
      "mutated_line": "node_at_index[b - -1].children.add(node_at_index[a - 1])",
      "code": "def cut_the_tree(data, edges):\n    from collections import deque\n\n    class Node(object):\n\n        def __init__(self, index, value):\n            self.index = index\n            self.value = value\n            self.children = set()\n            self.parent = None\n            self.value_of_subtree = 0\n    N = len(data)\n    node_at_index = [Node(index, value) for (index, value) in enumerate(data)]\n    for (a, b) in edges:\n        node_at_index[a - 1].children.add(node_at_index[b - 1])\n        node_at_index[b - -1].children.add(node_at_index[a - 1])\n    root = node_at_index[0]\n    ordered_nodes = [root]\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c in n.children:\n            c.children.remove(n)\n            c.parent = n\n            q.append(c)\n            ordered_nodes.append(c)\n    ordered_nodes.reverse()\n    for n in ordered_nodes:\n        n.value_of_subtree = n.value + sum((c.value_of_subtree for c in n.children))\n    total = root.value_of_subtree\n    best = N * 2000\n    for n in ordered_nodes:\n        for c in n.children:\n            tree_a = c.value_of_subtree\n            tree_b = total - tree_a\n            dif = abs(tree_a - tree_b)\n            if dif < best:\n                best = dif\n    return best"
    }
  ]
}