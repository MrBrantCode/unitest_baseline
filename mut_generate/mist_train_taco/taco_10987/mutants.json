{
  "task_id": "taco_10987",
  "entry_point": "position_tree_vertices",
  "mutant_count": 197,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 2",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 2\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 0\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 0\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = -1",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = -1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] / (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] / (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] + (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] + (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] ** (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] ** (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 * 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 * 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 + 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 + 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf / 4",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf / 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf * 4",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf * 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(2, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(0, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(0, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(-1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n - 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n * 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) >= 4:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) >= 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) <= 4:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) <= 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) != 4:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) != 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n - 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n - 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n * 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n * 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (1, 0)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (1, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (-1, 0)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (-1, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (1, 0)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (1, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (0, 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 1)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (0, -1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, -1)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[root] = (0, 0)",
      "mutated_line": "ans[root] = (0, 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 1)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 11 ** 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 11 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 9 ** 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 9 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 0 ** 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 0 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 1 ** 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 1 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = -10 ** 18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = -10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 19",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 19\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 17",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 17\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 0",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 0\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 1",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 1\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** -18",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** -18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf // 5",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 5\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf // 3",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 3\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf // 0",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 0\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf // 1",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 1\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l = inf // 4",
      "mutated_line": "l = inf // -4",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // -4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return (\"YES\", ans[1:])",
      "mutated_line": "return ('', ans[1:])",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x - nx[p[i]][0] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x - nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x * (nx[p[i]][0] * l)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x * (nx[p[i]][0] * l)\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y - nx[p[i]][1] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y - nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y * (nx[p[i]][1] * l)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y * (nx[p[i]][1] * l)\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 2):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 0):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 0):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + -1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) > 5:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 5:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) > 3:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 3:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) > 0:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 0:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) > 1:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 1:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(g[i]) > 4:",
      "mutated_line": "if len(g[i]) > -4:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > -4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [1] * (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [1] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [-1] * (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [-1] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [1] * (n + 1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [1] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n + 2)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 2)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n + 0)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 0)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n + 0)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 0)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = [0] * (n + 1)",
      "mutated_line": "ans = [0] * (n + -1)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + -1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((2, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((2, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((0, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((0, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((0, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((0, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((-1, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((-1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 1), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 1), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, -1), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, -1), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 1), (0, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 1), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (1, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (1, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (-1, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (-1, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (1, -1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (1, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, +1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, +1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (+1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (+1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 1), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 1), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, -1), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, -1), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 1), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 1), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (1, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (1, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (-1, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (-1, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (1, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (1, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 2))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 2))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 0))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 0))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 0))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 0))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, -1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, -1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] / l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] / l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] + l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] + l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] ** l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] ** l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] / l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] / l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] + l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] + l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] ** l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] ** l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l / 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l / 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l * 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l * 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "g[v] = [u for u in g[v] if u != pr]",
      "mutated_line": "g[v] = [u for u in g[v] if u == pr]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u == pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + nx[p[i]][0] / l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] / l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + (nx[p[i]][0] + l)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + (nx[p[i]][0] + l)\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + nx[p[i]][0] ** l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] ** l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][1] / l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] / l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + (nx[p[i]][1] + l)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + (nx[p[i]][1] + l)\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][1] ** l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] ** l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l / 4, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l / 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l * 4, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l * 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n - 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n * 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (\"NO\",)",
      "mutated_line": "return ('',)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -2), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -2), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -0), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -0), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -0), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -0), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, --1), (-1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, --1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-2, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-2, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-0, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-0, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (-0, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-0, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "nx = ((1, 0), (0, -1), (-1, 0), (0, 1))",
      "mutated_line": "nx = ((1, 0), (0, -1), (--1, 0), (0, 1))",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (--1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 5, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 5, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 3, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 3, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 0, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 0, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 1, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 1, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // -4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // -4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return (\"YES\", ans[1:])",
      "mutated_line": "return ('YES', ans[2:])",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[2:])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return (\"YES\", ans[1:])",
      "mutated_line": "return ('YES', ans[0:])",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[0:])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return (\"YES\", ans[1:])",
      "mutated_line": "return ('YES', ans[0:])",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[0:])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return (\"YES\", ans[1:])",
      "mutated_line": "return ('YES', ans[-1:])",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[-1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(-1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(-1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(1, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 2, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 2, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 0, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 0, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 0, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 0, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, -1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, -1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 4), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 4), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 2), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 2), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 0), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 0), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 1), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 1), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, -3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, -3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (1, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (1, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (-1, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (-1, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (1, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (1, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 2, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 2, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 0, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 0, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 0, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 0, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, -1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, -1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 3), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 3), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 1), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 1), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 0), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 0), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 1), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 1), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, -2), (1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, -2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (2, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (2, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (0, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (0, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (0, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (0, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (-1, 2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (-1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 3, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 3, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 1, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 1, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 0, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 0, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 1, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 1, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, -2, 3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, -2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 4), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 4), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 2), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 2), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 0), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 0), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 1), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 1), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, -3), (0, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, -3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (1, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (1, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (-1, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (-1, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (1, 2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (1, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 3, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 3, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 1, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 1, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 0, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 0, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 1, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 1, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, -2, 3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, -2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 4)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 4)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 2)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 2)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 0)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 0)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 1)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 1)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]",
      "mutated_line": "p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, -3)][t]",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, -3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l // 5, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 5, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l // 3, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 3, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l // 0, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 0, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l // 1, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 1, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dfs(g[v][i], newx, newy, p[i], l // 4, v)",
      "mutated_line": "dfs(g[v][i], newx, newy, p[i], l // -4, v)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // -4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 2)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g = [list() for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + -1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][1] * l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][1] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][-1] * l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][-1] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][1] * l, nx[i][1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][1] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][2] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][2] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][0] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][0] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][0] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][0] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)",
      "mutated_line": "dfs(g[root][i], nx[i][0] * l, nx[i][-1] * l, i, l // 4, root)",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][-1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + nx[p[i]][1] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][1] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + nx[p[i]][-1] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][-1] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "newx = x + nx[p[i]][0] * l",
      "mutated_line": "newx = x + nx[p[i]][1] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][1] * l\n            newy = y + nx[p[i]][1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][2] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][2] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][0] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][0] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][0] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][0] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "newy = y + nx[p[i]][1] * l",
      "mutated_line": "newy = y + nx[p[i]][-1] * l",
      "code": "def position_tree_vertices(n, edges):\n\n    def dfs(v, x, y, t, l, pr):\n        ans[v] = (x, y)\n        p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n        g[v] = [u for u in g[v] if u != pr]\n        for i in range(min(len(p), len(g[v]))):\n            newx = x + nx[p[i]][0] * l\n            newy = y + nx[p[i]][-1] * l\n            dfs(g[v][i], newx, newy, p[i], l // 4, v)\n    g = [list() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    root = 1\n    for i in range(1, n + 1):\n        if len(g[i]) > 4:\n            return ('NO',)\n    ans = [0] * (n + 1)\n    ans[root] = (0, 0)\n    inf = 10 ** 18\n    l = inf // 4\n    nx = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    for i in range(len(g[root])):\n        dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\n    return ('YES', ans[1:])"
    }
  ]
}