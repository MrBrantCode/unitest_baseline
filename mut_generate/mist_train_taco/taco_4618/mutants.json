{
  "task_id": "taco_4618",
  "entry_point": "find_min_moves_to_reach_target",
  "mutant_count": 217,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, 0] = 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 1\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, 0] = -1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = -1\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, 0] = 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 1\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 2 * events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 * events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 2 + events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 + events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c == s:",
      "mutated_line": "if c != s:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c != s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 2 * events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 * events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 2 + events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 + events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t - n * i for i in range(2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t - n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t * (n * i) for i in range(2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t * (n * i) for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if node in goal:",
      "mutated_line": "if node not in goal:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node not in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = node // n",
      "mutated_line": "level = node / n",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node / n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = node // n",
      "mutated_line": "level = node * n",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node * n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n * level, 0) in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if acc == r:",
      "mutated_line": "if acc != r:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc != r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(2 * e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 * e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(2 + e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 + e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 3 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 3 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 1 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 0 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 0 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 1 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "slide[c] = 2 ** events.index((a, b, c))",
      "mutated_line": "slide[c] = -2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = -2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s - n * 2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s - n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s * (n * 2 ** events.index((a, b, c)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s * (n * 2 ** events.index((a, b, c)))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 3 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 3 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 1 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 0 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 0 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 1 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mask = 2 ** events.index((a, b, c))",
      "mutated_line": "mask = -2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = -2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(2 * e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 * e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(2 + e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 + e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if mask & j:",
      "mutated_line": "if mask | j:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask | j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n / i for i in range(2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n / i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + (n + i) for i in range(2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + (n + i) for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n ** i for i in range(2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n ** i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, 1] = 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 1] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, -1] = 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, -1] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[start, 0] = 0",
      "mutated_line": "dist[start, 1] = 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 1] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((1, 0, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((1, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((-1, 0, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((-1, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((1, 0, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((1, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((0, 1, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 1, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((0, -1, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, -1, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que.append((0, 0, start))",
      "mutated_line": "que.append((0, 1, start))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 1, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score - 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score - 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score * 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score * 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if to % n in slide:",
      "mutated_line": "if to % n not in slide:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n not in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc + 1) in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n / 2 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n / 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n + 2 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n + 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n ** 2 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n ** 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(3 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(3 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(1 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(1 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(0 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(0 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(1 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(1 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2 ** e):",
      "mutated_line": "for i in range(-2 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(-2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n * i].append(b - n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b - n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n * i].append(b * (n * i))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b * (n * i))\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n * i].append(a - n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a - n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n * i].append(a * (n * i))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a * (n * i))\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n / 2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n / 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + (n + 2 ** events.index((a, b, c)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + (n + 2 ** events.index((a, b, c)))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n ** 2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n ** 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(3 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(3 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(1 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(1 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(0 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(0 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(1 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(1 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2 ** e):",
      "mutated_line": "for j in range(-2 ** e):",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(-2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b - n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b - n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b * (n * (mask | j)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b * (n * (mask | j)))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a - n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a - n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a * (n * (mask | j)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a * (n * (mask | j)))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(2 * e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 * e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(2 + e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 + e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s - n * level, 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s - n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s * (n * level), 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s * (n * level), 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n * level, 1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 1) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n * level, -1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, -1) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n * level, 1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 1) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score + 2",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 2\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score + 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 0\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score + 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 0\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 0] = score + -1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + -1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if to % n in slide:",
      "mutated_line": "if to * n in slide:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to * n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if to % n in slide:",
      "mutated_line": "if to + n in slide:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to + n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n - n * (to // n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n - n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n * (n * (to // n | slide[to % n]))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n * (n * (to // n | slide[to % n]))\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score - 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score - 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score * 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score * 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * (2 * e))]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * (2 * e))]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * (2 + e))]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * (2 + e))]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n * i].append(b + n / i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n / i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n * i].append(b + (n + i))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + (n + i))\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n * i].append(b + n ** i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n ** i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n * i].append(a + n / i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n / i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n * i].append(a + (n + i))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + (n + i))\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n * i].append(a + n ** i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n ** i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * (2 * events.index((a, b, c)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * (2 * events.index((a, b, c)))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * (2 + events.index((a, b, c)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * (2 + events.index((a, b, c)))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b + n / (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n / (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b + (n + (mask | j)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + (n + (mask | j)))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b + n ** (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n ** (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a + n / (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n / (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a + (n + (mask | j)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + (n + (mask | j)))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a + n ** (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n ** (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(3 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(3 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(1 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(1 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(0 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(0 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(1 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(1 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "goal = {t + n * i for i in range(2 ** e)}",
      "mutated_line": "goal = {t + n * i for i in range(-2 ** e)}",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(-2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n / level, 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n / level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + (n + level), 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + (n + level), 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (s + n * level, 0) not in dist:",
      "mutated_line": "if (s + n ** level, 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n ** level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s - n * level, 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s - n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s * (n * level), 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s * (n * level), 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 1] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, -1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, -1] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n * level, 1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 1] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score - 1, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score - 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score * 1, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score * 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 1, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 1, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, -1, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, -1, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 1, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 1, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 0, s - n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s - n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 0, s * (n * level)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s * (n * level)))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to * n + n * (to // n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to * n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to + n + n * (to // n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to + n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n / (to // n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n / (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + (n + (to // n | slide[to % n]))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + (n + (to // n | slide[to % n]))\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n ** (to // n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n ** (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc - 1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc - 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc * 1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc * 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score + 2",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 2\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score + 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 0\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score + 0",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 0\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 1] = score + -1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + -1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * 3 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 3 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * 1 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 1 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * 0 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 0 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * 1 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 1 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "edges = [[] for _ in range(n * 2 ** e)]",
      "mutated_line": "edges = [[] for _ in range(n * -2 ** e)]",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * -2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a - n * i].append(b + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a - n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a * (n * i)].append(b + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a * (n * i)].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b - n * i].append(a + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b - n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b * (n * i)].append(a + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b * (n * i)].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * 3 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 3 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 1 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * 0 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 0 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * 1 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 1 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "start = s + n * 2 ** events.index((a, b, c))",
      "mutated_line": "start = s + n * -2 ** events.index((a, b, c))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * -2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a - n * (mask | j)].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a - n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a * (n * (mask | j))].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a * (n * (mask | j))].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b + n * (mask & j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask & j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask | j)].append(b + n * (mask ^ j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask ^ j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b - n * (mask | j)].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b - n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b * (n * (mask | j))].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b * (n * (mask | j))].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a + n * (mask & j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask & j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask | j)].append(a + n * (mask ^ j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask ^ j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n / level, 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n / level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + (n + level), 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + (n + level), 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[s + n * level, 0] = score + 1",
      "mutated_line": "dist[s + n ** level, 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n ** level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 2, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 2, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 0, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 0, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 0, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 0, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + -1, 0, s + n * level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + -1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 0, s + n / level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n / level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 0, s + (n + level)))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + (n + level)))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "que.append((score + 1, 0, s + n * level))",
      "mutated_line": "que.append((score + 1, 0, s + n ** level))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n ** level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to // n & slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n & slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to // n ^ slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n ^ slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc + 2) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 2) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc + 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 0) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc + 0) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 0) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if (to, acc + 1) not in dist:",
      "mutated_line": "if (to, acc + -1) not in dist:",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + -1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc - 1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc - 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc * 1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc * 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score - 1, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score - 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score * 1, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score * 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc - 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc - 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc * 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc * 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n / i].append(b + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n / i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + (n + i)].append(b + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + (n + i)].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edges[a + n * i].append(b + n * i)",
      "mutated_line": "edges[a + n ** i].append(b + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n ** i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n / i].append(a + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n / i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + (n + i)].append(a + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + (n + i)].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edges[b + n * i].append(a + n * i)",
      "mutated_line": "edges[b + n ** i].append(a + n * i)",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n ** i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n / (mask | j)].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n / (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + (n + (mask | j))].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + (n + (mask | j))].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n ** (mask | j)].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n ** (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n / (mask | j)].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n / (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + (n + (mask | j))].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + (n + (mask | j))].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n ** (mask | j)].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n ** (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to / n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to / n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to * n | slide[to % n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to * n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 2] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 2] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 0] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + 0] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 0] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist[to, acc + 1] = score + 1",
      "mutated_line": "dist[to, acc + -1] = score + 1",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + -1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 2, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 2, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 0, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 0, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 0, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 0, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + -1, acc + 1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + -1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc + 2, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 2, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc + 0, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 0, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc + 0, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 0, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "que.append((score + 1, acc + 1, to))",
      "mutated_line": "que.append((score + 1, acc + -1, to))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + -1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask & j)].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask & j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "edges[a + n * (mask | j)].append(b + n * (mask | j))",
      "mutated_line": "edges[a + n * (mask ^ j)].append(b + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask ^ j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask & j)].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask & j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "edges[b + n * (mask | j)].append(a + n * (mask | j))",
      "mutated_line": "edges[b + n * (mask ^ j)].append(a + n * (mask | j))",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask ^ j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to % n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to // n | slide[to * n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to * n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "to = to % n + n * (to // n | slide[to % n])",
      "mutated_line": "to = to % n + n * (to // n | slide[to + n])",
      "code": "from collections import deque\n\ndef find_min_moves_to_reach_target(n, m, e, s, t, r, initial_roads, events):\n    edges = [[] for _ in range(n * 2 ** e)]\n    for (a, b) in initial_roads:\n        for i in range(2 ** e):\n            edges[a + n * i].append(b + n * i)\n            edges[b + n * i].append(a + n * i)\n    start = s\n    slide = {}\n    for (a, b, c) in events:\n        slide[c] = 2 ** events.index((a, b, c))\n        if c == s:\n            start = s + n * 2 ** events.index((a, b, c))\n        mask = 2 ** events.index((a, b, c))\n        for j in range(2 ** e):\n            if mask & j:\n                continue\n            edges[a + n * (mask | j)].append(b + n * (mask | j))\n            edges[b + n * (mask | j)].append(a + n * (mask | j))\n    goal = {t + n * i for i in range(2 ** e)}\n    dist = {}\n    dist[start, 0] = 0\n    que = deque()\n    que.append((0, 0, start))\n    while que:\n        (score, acc, node) = que.popleft()\n        if node in goal:\n            return score\n        level = node // n\n        if (s + n * level, 0) not in dist:\n            dist[s + n * level, 0] = score + 1\n            que.append((score + 1, 0, s + n * level))\n        if acc == r:\n            continue\n        for to in edges[node]:\n            if to % n in slide:\n                to = to % n + n * (to // n | slide[to + n])\n            if (to, acc + 1) not in dist:\n                dist[to, acc + 1] = score + 1\n                que.append((score + 1, acc + 1, to))\n    return -1"
    }
  ]
}