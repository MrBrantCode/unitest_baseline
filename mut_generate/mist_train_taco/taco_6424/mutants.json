{
  "task_id": "taco_6424",
  "entry_point": "find_longest_harmony_substring",
  "mutant_count": 122,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ll == 0:",
      "mutated_line": "if ll != 0:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll != 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [0] / n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] / n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [0] + n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] + n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [0] ** n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] ** n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + Z[i] == n:",
      "mutated_line": "if i + Z[i] != n:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] != n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ll == 0:",
      "mutated_line": "if ll == 1:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 1:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ll == 0:",
      "mutated_line": "if ll == -1:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == -1:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ll == 0:",
      "mutated_line": "if ll == 1:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 1:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return \"Just a legend\"",
      "mutated_line": "return ''",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return ''\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif ll == 1:",
      "mutated_line": "elif ll != 1:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll != 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (1, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (-1, 0)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (-1, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (1, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 1)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (0, -1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, -1)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l, r = 0, 0",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 1)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(2, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(0, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(0, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(-1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i < r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i < r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i > r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i == r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i == r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] < n or s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n or s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "Z[i] += 1",
      "mutated_line": "Z[i] -= 1",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] -= 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 1 >= r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 >= r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 1 <= r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 <= r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 1 != r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 != r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + Z[i] == n:",
      "mutated_line": "if i - Z[i] == n:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i - Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + Z[i] == n:",
      "mutated_line": "if i * Z[i] == n:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i * Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif ll == 1:",
      "mutated_line": "elif ll == 2:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 2:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif ll == 1:",
      "mutated_line": "elif ll == 0:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 0:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif ll == 1:",
      "mutated_line": "elif ll == 0:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 0:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif ll == 1:",
      "mutated_line": "elif ll == -1:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == -1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 and max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 and max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 and max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 and max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [1] * n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [1] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [-1] * n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [-1] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Z = [0] * n",
      "mutated_line": "Z = [1] * n",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [1] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] <= n and s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] <= n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] >= n and s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] >= n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] != n and s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] != n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] < n and s[Z[i]] != s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] != s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Z[i] += 1",
      "mutated_line": "Z[i] += 2",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 2\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Z[i] += 1",
      "mutated_line": "Z[i] += 0",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 0\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Z[i] += 1",
      "mutated_line": "Z[i] += 0",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 0\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Z[i] += 1",
      "mutated_line": "Z[i] += -1",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += -1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] + 1 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] + 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if (i + Z[i]) * 1 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if (i + Z[i]) * 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) > 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) > 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) < 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) < 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) == 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) == 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) >= third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) >= third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) <= third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) <= third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) != third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) != third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"Just a legend\"",
      "mutated_line": "return ''",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return ''\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) > 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) > 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) < 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) < 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) == 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) == 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) >= third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) >= third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) <= third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) <= third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) != third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) != third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i - 1, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i - 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min((r - i) * 1, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min((r - i) * 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i - Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i - Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i * Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i * Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i - Z[i] - 1 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i - Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i * Z[i] - 1 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i * Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 2 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 2 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 0 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 0 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - 0 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 0 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i + Z[i] - 1 > r:",
      "mutated_line": "if i + Z[i] - -1 > r:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - -1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i + Z[i] + 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] + 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, (i + Z[i]) * 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, (i + Z[i]) * 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 3 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 3 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 1 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 1 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 0 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 0 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 1 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 1 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= -2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= -2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 3 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 3 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 1 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 1 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 0 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 0 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 1 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 1 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= -2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= -2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r + i + 1, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r + i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r * i + 1, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r * i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + 2, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 2, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + 0, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 0, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + 0, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 0, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + -1, Z[i - l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + -1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + 1, Z[i + l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i + l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Z[i] = min(r - i + 1, Z[i - l])",
      "mutated_line": "Z[i] = min(r - i + 1, Z[i * l])",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i * l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] < n and s[Z[i]] == s[i - Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i - Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:",
      "mutated_line": "while i + Z[i] < n and s[Z[i]] == s[i * Z[i]]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i * Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i - Z[i] - 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i - Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i * Z[i] - 1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i * Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i + Z[i] - 2)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 2)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i + Z[i] - 0)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 0)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i + Z[i] - 0)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 0)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l, r = i, i + Z[i] - 1",
      "mutated_line": "(l, r) = (i, i + Z[i] - -1)",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - -1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) > third[1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[1]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) > third[-1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[-1]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[0]) >= 2 or max(Z) > third[1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[1]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[1]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[-1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[-1]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[1]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[1]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[1]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[-1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[-1]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "if Z.count(third[1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[1]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[1]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[-1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[-1]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[1]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[1]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[-1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[-1]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif Z.count(third[0]) >= 2 or max(Z) > third[0]:",
      "mutated_line": "elif Z.count(third[1]) >= 2 or max(Z) > third[0]:",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[1]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[1]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[-1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[-1]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return s[:third[0]]",
      "mutated_line": "return s[:third[1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[1]]\n    else:\n        return s[:third[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[:third[1]]",
      "mutated_line": "return s[:third[2]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[2]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[:third[1]]",
      "mutated_line": "return s[:third[0]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[0]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[:third[1]]",
      "mutated_line": "return s[:third[0]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[0]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[:third[1]]",
      "mutated_line": "return s[:third[-1]]",
      "code": "def find_longest_harmony_substring(s: str) -> str:\n\n    def zfunction(s):\n        n = len(s)\n        Z = [0] * n\n        (l, r) = (0, 0)\n        for i in range(1, n):\n            if i <= r:\n                Z[i] = min(r - i + 1, Z[i - l])\n            while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n                Z[i] += 1\n            if i + Z[i] - 1 > r:\n                (l, r) = (i, i + Z[i] - 1)\n        return Z\n    n = len(s)\n    Z = zfunction(s)\n    third = []\n    for i in range(n):\n        if i + Z[i] == n:\n            third.append(Z[i])\n    ll = len(third)\n    if ll == 0:\n        return 'Just a legend'\n    elif ll == 1:\n        if Z.count(third[0]) >= 2 or max(Z) > third[0]:\n            return s[:third[0]]\n        else:\n            return 'Just a legend'\n    elif Z.count(third[0]) >= 2 or max(Z) > third[0]:\n        return s[:third[0]]\n    else:\n        return s[:third[-1]]"
    }
  ]
}