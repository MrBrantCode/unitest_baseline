{
  "task_id": "taco_14668",
  "entry_point": "optimize_essay",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 1\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tr = 0",
      "mutated_line": "tr = -1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = -1\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tr = 0",
      "mutated_line": "tr = 1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 1\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tl = 0",
      "mutated_line": "tl = 1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 1\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tl = 0",
      "mutated_line": "tl = -1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = -1\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tl = 0",
      "mutated_line": "tl = 1",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 1\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[2] in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if word in sti:",
      "mutated_line": "if word not in sti:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word not in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "tr += best[wid][0]",
      "mutated_line": "tr -= best[wid][0]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr -= best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "tl += best[wid][1]",
      "mutated_line": "tl -= best[wid][1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl -= best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "tr += word.count('r')",
      "mutated_line": "tr -= word.count('r')",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr -= word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "tl += len(word)",
      "mutated_line": "tl -= len(word)",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl -= len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))",
      "mutated_line": "pack = lambda word: (word.count(''), len(word), sti.setdefault(word, len(sti)))",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count(''), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-1]].append(word_packed[+1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[+1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[3] not in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[3] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[1] not in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[1] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[0] not in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[0] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[1] not in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[1] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if node[2] not in best:",
      "mutated_line": "if node[-2] not in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[-2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if top not in best:",
      "mutated_line": "if top in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tr += best[wid][0]",
      "mutated_line": "tr += best[wid][1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][1]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tr += best[wid][0]",
      "mutated_line": "tr += best[wid][-1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][-1]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tr += best[wid][0]",
      "mutated_line": "tr += best[wid][1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][1]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tl += best[wid][1]",
      "mutated_line": "tl += best[wid][2]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][2]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tl += best[wid][1]",
      "mutated_line": "tl += best[wid][0]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][0]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tl += best[wid][1]",
      "mutated_line": "tl += best[wid][0]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][0]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tl += best[wid][1]",
      "mutated_line": "tl += best[wid][-1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][-1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "tr += word.count('r')",
      "mutated_line": "tr += word.count('')",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-1]].append(word_packed[-2])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-2])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-1]].append(word_packed[-0])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-0])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-1]].append(word_packed[-0])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-0])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-1]].append(word_packed[--1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[--1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack = [node[2]]",
      "mutated_line": "stack = [node[3]]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[3]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack = [node[2]]",
      "mutated_line": "stack = [node[1]]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[1]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack = [node[2]]",
      "mutated_line": "stack = [node[0]]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[0]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack = [node[2]]",
      "mutated_line": "stack = [node[1]]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[1]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack = [node[2]]",
      "mutated_line": "stack = [node[-2]]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[-2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[+1]].append(word_packed[-1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[+1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if n not in best:",
      "mutated_line": "if n in best:",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-2]].append(word_packed[-1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-2]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-0]].append(word_packed[-1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-0]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[-0]].append(word_packed[-1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-0]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edge[synon_packed[-1]].append(word_packed[-1])",
      "mutated_line": "edge[synon_packed[--1]].append(word_packed[-1])",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[--1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best[top] = node[:2]",
      "mutated_line": "best[top] = node[:3]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:3]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best[top] = node[:2]",
      "mutated_line": "best[top] = node[:1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:1]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best[top] = node[:2]",
      "mutated_line": "best[top] = node[:0]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:0]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best[top] = node[:2]",
      "mutated_line": "best[top] = node[:1]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:1]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "best[top] = node[:2]",
      "mutated_line": "best[top] = node[:-2]",
      "code": "import collections\n\ndef optimize_essay(m, essay, n, synonyms):\n    essay = [word.lower() for word in essay]\n    synonyms = [(word1.lower(), word2.lower()) for (word1, word2) in synonyms]\n    sti = dict()\n    pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n    edge = collections.defaultdict(list)\n    nodes = list()\n    for (word, synon) in synonyms:\n        word_packed = pack(word)\n        synon_packed = pack(synon)\n        edge[synon_packed[-1]].append(word_packed[-1])\n        nodes.append(word_packed)\n        nodes.append(synon_packed)\n    nodes.sort()\n    best = dict()\n    for node in nodes:\n        if node[2] not in best:\n            stack = [node[2]]\n            while stack:\n                top = stack.pop()\n                if top not in best:\n                    best[top] = node[:-2]\n                    for n in edge[top]:\n                        if n not in best:\n                            stack.append(n)\n    tr = 0\n    tl = 0\n    for word in essay:\n        if word in sti:\n            wid = sti[word]\n            tr += best[wid][0]\n            tl += best[wid][1]\n        else:\n            tr += word.count('r')\n            tl += len(word)\n    return (tr, tl)"
    }
  ]
}