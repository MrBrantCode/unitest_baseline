{
  "task_id": "taco_13152",
  "entry_point": "maximize_cake_value",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 1\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = -1\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 1\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((2, -1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((2, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((0, -1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((0, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((0, -1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((0, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((-1, -1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((-1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, +1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, +1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -1), repeat=4)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=4)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -1), repeat=2)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=2)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -1), repeat=0)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=0)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -1), repeat=1)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=1)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -1), repeat=-3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=-3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -2), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -2), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -0), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -0), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, -0), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -0), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "P = product((1, -1), repeat=3)",
      "mutated_line": "P = product((1, --1), repeat=3)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, --1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y * py - z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py - z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append((x * px + y * py) * (z * pz))",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append((x * px + y * py) * (z * pz))\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tmp.sort(reverse=True)",
      "mutated_line": "tmp.sort(reverse=False)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z * pz)\n        tmp.sort(reverse=False)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px - y * py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px - y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px * (y * py) + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px * (y * py) + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y * py + z / pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z / pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y * py + (z + pz))",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + (z + pz))\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y * py + z ** pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y * py + z ** pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x / px + y * py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x / px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x + px + y * py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x + px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x ** px + y * py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x ** px + y * py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y / py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y / py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + (y + py) + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + (y + py) + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tmp.append(x * px + y * py + z * pz)",
      "mutated_line": "tmp.append(x * px + y ** py + z * pz)",
      "code": "from itertools import product\n\ndef maximize_cake_value(N, M, cakes):\n    P = product((1, -1), repeat=3)\n    ans = 0\n    for (px, py, pz) in P:\n        tmp = []\n        for (x, y, z) in cakes:\n            tmp.append(x * px + y ** py + z * pz)\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    return ans"
    }
  ]
}