{
  "task_id": "taco_10512",
  "entry_point": "find_minimum_moves",
  "mutant_count": 243,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "Bi = -1",
      "mutated_line": "Bi = +1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = +1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 1\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "idx = 0",
      "mutated_line": "idx = -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = -1\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 1\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi != -1:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi != -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "B = float('inf')",
      "mutated_line": "B = float('')",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Bi = -1",
      "mutated_line": "Bi = -2",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -2\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Bi = -1",
      "mutated_line": "Bi = -0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -0\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Bi = -1",
      "mutated_line": "Bi = -0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -0\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Bi = -1",
      "mutated_line": "Bi = --1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = --1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for z in range(5):",
      "mutated_line": "for z in range(6):",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(6):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for z in range(5):",
      "mutated_line": "for z in range(4):",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(4):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for z in range(5):",
      "mutated_line": "for z in range(0):",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(0):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for z in range(5):",
      "mutated_line": "for z in range(1):",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(1):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for z in range(5):",
      "mutated_line": "for z in range(-5):",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(-5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[2]] = 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 1\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[2]] = -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = -1\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[2]] = 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 1\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reached = False",
      "mutated_line": "reached = True",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = True\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "LCR",
      "lineno": 50,
      "original_line": "if reached and cst < B:",
      "mutated_line": "if reached or cst < B:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached or cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi == +1:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == +1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 'NA'",
      "mutated_line": "return ''",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return ''\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if a == '.':",
      "mutated_line": "if a != '.':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a != '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[2]][4] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][4] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[2]][2] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][2] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[2]][0] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][0] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[2]][1] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][1] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[2]][-3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][-3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] / idx for _ in range(6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] / idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] + idx for _ in range(6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] + idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] ** idx for _ in range(6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] ** idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "cst = int(cst) - int(huristicCost)",
      "mutated_line": "cst = int(cst) + int(huristicCost)",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) + int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "cst = int(cst) - int(huristicCost)",
      "mutated_line": "cst = int(cst) * int(huristicCost)",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) * int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep != 5:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep != 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst -= abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst -= abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) * 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) * 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = consequNodes[nid][3] + 1 + 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = consequNodes[nid][3] + 1 + 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if reached and cst < B:",
      "mutated_line": "if reached and cst <= B:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst <= B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if reached and cst < B:",
      "mutated_line": "if reached and cst >= B:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst >= B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if reached and cst < B:",
      "mutated_line": "if reached and cst != B:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst != B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z - 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z - 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z * 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z * 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi == -2:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -2:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi == -0:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -0:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi == -0:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -0:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if Bi == -1:",
      "mutated_line": "if Bi == --1:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == --1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "monsterNodes = [[] for _ in range(5)]",
      "mutated_line": "monsterNodes = [[] for _ in range(6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(6)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "monsterNodes = [[] for _ in range(5)]",
      "mutated_line": "monsterNodes = [[] for _ in range(4)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(4)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "monsterNodes = [[] for _ in range(5)]",
      "mutated_line": "monsterNodes = [[] for _ in range(0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(0)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "monsterNodes = [[] for _ in range(5)]",
      "mutated_line": "monsterNodes = [[] for _ in range(1)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(1)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "monsterNodes = [[] for _ in range(5)]",
      "mutated_line": "monsterNodes = [[] for _ in range(-5)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(-5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if a == '.':",
      "mutated_line": "if a == '':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif a == 'S':",
      "mutated_line": "elif a != 'S':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a != 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx -= 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[2][startNode[2]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[2][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[0][startNode[2]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[0][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[0][startNode[2]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[0][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[-1][startNode[2]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[-1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[3]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[3]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[1]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[1]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[0]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[0]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[1]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[1]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[1][startNode[2]] = 0",
      "mutated_line": "dist[1][startNode[-2]] = 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[-2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(1, 1, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(1, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(-1, 1, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(-1, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(1, 1, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(1, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 2, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 2, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 0, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 0, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 0, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 0, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, -1, startNode[2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, -1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[2], 1)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 1)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[2], -1)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], -1)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[2], 1)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 1)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep == 6:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 6:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep == 4:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 4:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep == 0:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 0:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep == 1:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 1:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if numrep == 5:",
      "mutated_line": "if numrep == -5:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == -5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "reached = True",
      "mutated_line": "reached = False",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = False\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) - abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) - abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) * abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) * abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] - 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] - 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = consequNodes[nid][3] * 1 % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = consequNodes[nid][3] * 1 % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) % 6",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 6\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) % 4",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 4\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) % 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 0\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) % 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 1\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 1) % -5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % -5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) - abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) - abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = (dist[numrep][nid] + abs(nxty - consequNodes[nid][0])) * abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = (dist[numrep][nid] + abs(nxty - consequNodes[nid][0])) * abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost <= dist[numrep + 1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost <= dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost >= dist[numrep + 1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost >= dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost != dist[numrep + 1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost != dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h /= 0.99",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h /= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z + 2",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 2\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z + 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 0\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z + 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 0\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "Bi = z + 1",
      "mutated_line": "Bi = z + -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + -1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif a == 'S':",
      "mutated_line": "elif a == '':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == '':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 2\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 0\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 0\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += -1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif a == 'G':",
      "mutated_line": "elif a != 'G':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a != 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx -= 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[3]][3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[3]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[1]][3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[1]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[0]][3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[0]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[1]][3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[1]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "consequNodes[startNode[2]][3] = z",
      "mutated_line": "consequNodes[startNode[-2]][3] = z",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[-2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] * idx for _ in range(7)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(7)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] * idx for _ in range(5)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(5)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] * idx for _ in range(0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(0)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] * idx for _ in range(1)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(1)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('inf')] * idx for _ in range(-6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(-6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[3], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[3], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[1], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[1], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[0], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[0], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[1], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[1], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "que = [(0, 1, startNode[2], 0)]",
      "mutated_line": "que = [(0, 1, startNode[-2], 0)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[-2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 2) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 2) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 0) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 0) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + 0) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 0) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][3] + -1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + -1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] - abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] - abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] * abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] * abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) - abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) - abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) * abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) * abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h *= 1.99",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 1.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h *= -0.010000000000000009",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= -0.010000000000000009\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h *= 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h *= 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 1\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "h *= 0.99",
      "mutated_line": "h *= -0.99",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= -0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "startNode = [i, j, idx, 5]",
      "mutated_line": "startNode = [i, j, idx, 6]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 6]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "startNode = [i, j, idx, 5]",
      "mutated_line": "startNode = [i, j, idx, 4]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 4]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "startNode = [i, j, idx, 5]",
      "mutated_line": "startNode = [i, j, idx, 0]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 0]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "startNode = [i, j, idx, 5]",
      "mutated_line": "startNode = [i, j, idx, 1]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 1]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "startNode = [i, j, idx, 5]",
      "mutated_line": "startNode = [i, j, idx, -5]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, -5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif a == 'G':",
      "mutated_line": "elif a == '':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == '':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 2\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 0\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 0\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += -1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif a != '.':",
      "mutated_line": "elif a == '.':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a == '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx -= 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = [[float('inf')] * idx for _ in range(6)]",
      "mutated_line": "dist = [[float('')] * idx for _ in range(6)]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] + goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] + goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] * goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] * goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] + goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] + goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] * goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] * goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][4] + 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][4] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][2] + 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][2] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][0] + 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][0] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][1] + 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][1] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "nxtmonster = (consequNodes[nid][3] + 1) % 5",
      "mutated_line": "nxtmonster = (consequNodes[nid][-3] + 1) % 5",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][-3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx + consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx + consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx * consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx * consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "consequNodes.append([i, j, idx, 5])",
      "mutated_line": "consequNodes.append([i, j, idx, 6])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 6])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "consequNodes.append([i, j, idx, 5])",
      "mutated_line": "consequNodes.append([i, j, idx, 4])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 4])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "consequNodes.append([i, j, idx, 5])",
      "mutated_line": "consequNodes.append([i, j, idx, 0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 0])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "consequNodes.append([i, j, idx, 5])",
      "mutated_line": "consequNodes.append([i, j, idx, 1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 1])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "consequNodes.append([i, j, idx, 5])",
      "mutated_line": "consequNodes.append([i, j, idx, -5])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, -5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "goalNode = [i, j, idx, 6]",
      "mutated_line": "goalNode = [i, j, idx, 7]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 7]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "goalNode = [i, j, idx, 6]",
      "mutated_line": "goalNode = [i, j, idx, 5]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 5]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "goalNode = [i, j, idx, 6]",
      "mutated_line": "goalNode = [i, j, idx, 0]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 0]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "goalNode = [i, j, idx, 6]",
      "mutated_line": "goalNode = [i, j, idx, 1]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 1]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "goalNode = [i, j, idx, 6]",
      "mutated_line": "goalNode = [i, j, idx, -6]",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, -6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a != '.':",
      "mutated_line": "elif a != '':",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 2\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 0\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 0\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += -1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty + consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty + consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty * consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty * consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep - 1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep - 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep * 1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep * 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep - 1][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep - 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep * 1][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep * 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty + goalNode[0]) + abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty + goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty * goalNode[0]) + abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty * goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx + goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx + goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx * goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx * goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost - h, numrep + 1, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost - h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost * h, numrep + 1, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost * h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep - 1, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep - 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep * 1, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep * 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consequNodes.append([i, j, idx, 6])",
      "mutated_line": "consequNodes.append([i, j, idx, 7])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 7])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consequNodes.append([i, j, idx, 6])",
      "mutated_line": "consequNodes.append([i, j, idx, 5])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 5])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consequNodes.append([i, j, idx, 6])",
      "mutated_line": "consequNodes.append([i, j, idx, 0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 0])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consequNodes.append([i, j, idx, 6])",
      "mutated_line": "consequNodes.append([i, j, idx, 1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 1])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consequNodes.append([i, j, idx, 6])",
      "mutated_line": "consequNodes.append([i, j, idx, -6])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, -6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][-1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][-1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][1] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[1]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[1]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[-1]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[-1]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[1]) + abs(consequNodes[nid][1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[1]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][2] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][2] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][0] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][0] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][0] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][0] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][-1] - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][-1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[2])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[2])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[0])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[0])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])",
      "mutated_line": "cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[-1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[-1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][2])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][2])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][0])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][0])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][-1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][-1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep + 2][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 2][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep + 0][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 0][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep + 0][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 0][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if tmpCost < dist[numrep + 1][nxtid]:",
      "mutated_line": "if tmpCost < dist[numrep + -1][nxtid]:",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + -1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep + 2][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 2][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep + 0][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 0][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep + 0][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 0][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist[numrep + 1][nxtid] = tmpCost",
      "mutated_line": "dist[numrep + -1][nxtid] = tmpCost",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + -1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep + 2, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 2, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep + 0, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 0, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep + 0, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 0, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "heappush(que, (tmpCost + h, numrep + 1, nxtid, h))",
      "mutated_line": "heappush(que, (tmpCost + h, numrep + -1, nxtid, h))",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + -1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) + 1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) + 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) * 1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) * 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][1]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][1]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][-1]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][-1]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])",
      "mutated_line": "tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][1]) + abs(nxtx - consequNodes[nid][1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][1]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[1]) + abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[1]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[-1]) + abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[-1]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[1]) + abs(nxtx - goalNode[1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[1]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[2])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[2])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[0])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[0])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])",
      "mutated_line": "h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[-1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[-1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) - 2])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 2])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) - 0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 0])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) - 0])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 0])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "consequNodes.append([i, j, idx, int(a) - 1])",
      "mutated_line": "consequNodes.append([i, j, idx, int(a) - -1])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - -1])\n                monsterNodes[int(a) - 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) + 1].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) + 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) * 1].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) * 1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) - 2].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 2].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) - 0].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 0].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) - 0].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - 0].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "monsterNodes[int(a) - 1].append([i, j, idx])",
      "mutated_line": "monsterNodes[int(a) - -1].append([i, j, idx])",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_moves(W, H, map_data):\n    B = float('inf')\n    Bi = -1\n    consequNodes = []\n    monsterNodes = [[] for _ in range(5)]\n    idx = 0\n    for i in range(H):\n        for (j, a) in enumerate(map_data[i]):\n            if a == '.':\n                continue\n            elif a == 'S':\n                consequNodes.append([i, j, idx, 5])\n                startNode = [i, j, idx, 5]\n                idx += 1\n            elif a == 'G':\n                consequNodes.append([i, j, idx, 6])\n                goalNode = [i, j, idx, 6]\n                idx += 1\n            elif a != '.':\n                consequNodes.append([i, j, idx, int(a) - 1])\n                monsterNodes[int(a) - -1].append([i, j, idx])\n                idx += 1\n    for z in range(5):\n        consequNodes[startNode[2]][3] = z\n        dist = [[float('inf')] * idx for _ in range(6)]\n        dist[1][startNode[2]] = 0\n        que = [(0, 1, startNode[2], 0)]\n        reached = False\n        while que:\n            (cst, numrep, nid, huristicCost) = heappop(que)\n            cst = int(cst) - int(huristicCost)\n            if numrep == 5:\n                reached = True\n                cst += abs(consequNodes[nid][0] - goalNode[0]) + abs(consequNodes[nid][1] - goalNode[1])\n                break\n            nxtmonster = (consequNodes[nid][3] + 1) % 5\n            for (nxty, nxtx, nxtid) in monsterNodes[nxtmonster]:\n                tmpCost = dist[numrep][nid] + abs(nxty - consequNodes[nid][0]) + abs(nxtx - consequNodes[nid][1])\n                if tmpCost < dist[numrep + 1][nxtid]:\n                    dist[numrep + 1][nxtid] = tmpCost\n                    h = abs(nxty - goalNode[0]) + abs(nxtx - goalNode[1])\n                    h *= 0.99\n                    heappush(que, (tmpCost + h, numrep + 1, nxtid, h))\n        if reached and cst < B:\n            B = cst\n            Bi = z + 1\n    if Bi == -1:\n        return 'NA'\n    else:\n        return (Bi, B)"
    }
  ]
}