{
  "task_id": "taco_852",
  "entry_point": "count_divisible_in_interval",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "numL = 0",
      "mutated_line": "numL = 1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 1\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "numL = 0",
      "mutated_line": "numL = -1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = -1\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "numL = 0",
      "mutated_line": "numL = 1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 1\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numR = 0",
      "mutated_line": "numR = 1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 1\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numR = 0",
      "mutated_line": "numR = -1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = -1\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numR = 0",
      "mutated_line": "numR = 1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 1\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sign = 1",
      "mutated_line": "sign = 2",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 2\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sign = 1",
      "mutated_line": "sign = 0",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 0\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sign = 1",
      "mutated_line": "sign = 0",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 0\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sign = 1",
      "mutated_line": "sign = -1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = -1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return numR - numL",
      "mutated_line": "return numR + numL",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR + numL"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return numR - numL",
      "mutated_line": "return numR * numL",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR * numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(2, pow(2, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(2, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(0, pow(2, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(0, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(0, pow(2, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(0, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(-1, pow(2, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(-1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "muls = [1]",
      "mutated_line": "muls = [2]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [2]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "muls = [1]",
      "mutated_line": "muls = [0]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [0]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "muls = [1]",
      "mutated_line": "muls = [0]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [0]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "muls = [1]",
      "mutated_line": "muls = [-1]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [-1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "sign = -sign",
      "mutated_line": "sign = +sign",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = +sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(1, pow(3, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(3, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(1, pow(1, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(1, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(1, pow(0, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(0, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(1, pow(1, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(1, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, pow(2, N)):",
      "mutated_line": "for i in range(1, pow(-2, N)):",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(-2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i - 1]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i - 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i * 1]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i * 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 2\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 0\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 0\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = -1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k <= R:",
      "mutated_line": "if k < R:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k < R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k <= R:",
      "mutated_line": "if k > R:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k > R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k <= R:",
      "mutated_line": "if k == R:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k == R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL -= sign * ((L - 1) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL -= sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR -= sign * (R // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR -= sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N - 1)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N - 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N * 1)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N * 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i + 2]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 2]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i + 0]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 0]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i + 0]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 0]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for num in bits[i + 1]:",
      "mutated_line": "for num in bits[i + -1]:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + -1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if num & (1 << j):",
      "mutated_line": "if num | 1 << j:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num | 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "k *= primes[j]",
      "mutated_line": "k /= primes[j]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k /= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign / ((L - 1) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign / ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign + (L - 1) // k",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign + (L - 1) // k\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign ** ((L - 1) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign ** ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR += sign / (R // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign / (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR += sign + R // k",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign + R // k\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR += sign ** (R // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign ** (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N + 2)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 2)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N + 0)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 0)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N + 0)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 0)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bits = [[] for _ in range(N + 1)]",
      "mutated_line": "bits = [[] for _ in range(N + -1)]",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + -1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - 1) / k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) / k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - 1) * k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) * k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR += sign * (R / k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R / k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "numR += sign * (R // k)",
      "mutated_line": "numR += sign * (R * k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R * k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits[bin(i).count(\"1\")].append(i)",
      "mutated_line": "bits[bin(i).count('')].append(i)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if num & (1 << j):",
      "mutated_line": "if num & 2 << j:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 2 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if num & (1 << j):",
      "mutated_line": "if num & 0 << j:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 0 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if num & (1 << j):",
      "mutated_line": "if num & 0 << j:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 0 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if num & (1 << j):",
      "mutated_line": "if num & -1 << j:",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & -1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L + 1) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L + 1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * (L * 1 // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * (L * 1 // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - 2) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 2) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - 0) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 0) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - 0) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - 0) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "numL += sign * ((L - 1) // k)",
      "mutated_line": "numL += sign * ((L - -1) // k)",
      "code": "def count_divisible_in_interval(N, L, R, primes):\n    bits = [[] for _ in range(N + 1)]\n    for i in range(1, pow(2, N)):\n        bits[bin(i).count('1')].append(i)\n    numL = 0\n    numR = 0\n    muls = [1]\n    sign = 1\n    for i in range(N):\n        for num in bits[i + 1]:\n            k = 1\n            for j in range(N):\n                if num & 1 << j:\n                    k *= primes[j]\n            if k <= R:\n                numL += sign * ((L - -1) // k)\n                numR += sign * (R // k)\n        sign = -sign\n    return numR - numL"
    }
  ]
}