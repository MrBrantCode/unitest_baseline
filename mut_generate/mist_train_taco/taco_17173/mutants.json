{
  "task_id": "taco_17173",
  "entry_point": "dfs",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[start] = True",
      "mutated_line": "visited[start] = False",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = False\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 1\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = -1\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 1\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = +1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = +1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "u = -1",
      "mutated_line": "u = +1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = +1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "v = -1",
      "mutated_line": "v = +1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = +1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = +1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = +1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "affected = 0",
      "mutated_line": "affected = 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 1\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "affected = 0",
      "mutated_line": "affected = -1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = -1\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "affected = 0",
      "mutated_line": "affected = 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 1\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [+1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [+1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [True for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [True for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = dfs(graph, 1)",
      "mutated_line": "dist = dfs(graph, 2)",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 2)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = dfs(graph, 1)",
      "mutated_line": "dist = dfs(graph, 0)",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 0)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = dfs(graph, 1)",
      "mutated_line": "dist = dfs(graph, 0)",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 0)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = dfs(graph, 1)",
      "mutated_line": "dist = dfs(graph, -1)",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, -1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -2\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -0\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -0\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = --1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = --1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "u = -1",
      "mutated_line": "u = -2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -2\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "u = -1",
      "mutated_line": "u = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -0\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "u = -1",
      "mutated_line": "u = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -0\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "u = -1",
      "mutated_line": "u = --1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = --1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v = -1",
      "mutated_line": "v = -2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -2\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v = -1",
      "mutated_line": "v = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -0\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v = -1",
      "mutated_line": "v = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -0\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v = -1",
      "mutated_line": "v = --1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = --1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dist[i] > max_distance:",
      "mutated_line": "if dist[i] >= max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] >= max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dist[i] > max_distance:",
      "mutated_line": "if dist[i] <= max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] <= max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dist[i] > max_distance:",
      "mutated_line": "if dist[i] != max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] != max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -2\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -0\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = -0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -0\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_distance = -1",
      "mutated_line": "max_distance = --1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = --1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if distu[i] > max_distance:",
      "mutated_line": "if distu[i] >= max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] >= max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if distu[i] > max_distance:",
      "mutated_line": "if distu[i] <= max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] <= max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if distu[i] > max_distance:",
      "mutated_line": "if distu[i] != max_distance:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] != max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(2, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(0, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(0, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(-1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n - 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n * 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d or 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d or 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "affected += 1",
      "mutated_line": "affected -= 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected -= 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-2 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-2 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-0 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-0 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-0 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-0 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [--1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [--1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 2):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 0):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 0):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + -1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 < distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 < distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 > distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 > distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 == distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 == distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and 0 < distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 < distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and 0 > distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 > distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and 0 == distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 == distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "affected += 1",
      "mutated_line": "affected += 2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 2\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "affected += 1",
      "mutated_line": "affected += 0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 0\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "affected += 1",
      "mutated_line": "affected += 0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 0\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "affected += 1",
      "mutated_line": "affected += -1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += -1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n - 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n - 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n * 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n * 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n - 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n - 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n * 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n * 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[v] = True",
      "mutated_line": "visited[v] = False",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = False\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] - 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] - 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] * 1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] * 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n - 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n - 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n * 1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n * 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 1 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 1 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if -1 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if -1 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 1 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 1 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and 1 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 1 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and -1 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and -1 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if 0 <= distu[i] <= d and 0 <= distv[i] <= d:",
      "mutated_line": "if 0 <= distu[i] <= d and 1 <= distv[i] <= d:",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 1 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 2)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 2)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 0)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 0)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dist = [-1 for _ in range(n + 1)]",
      "mutated_line": "dist = [-1 for _ in range(n + -1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + -1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n + 2)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 2)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 0)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 0)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False for _ in range(n + 1)]",
      "mutated_line": "visited = [False for _ in range(n + -1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + -1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 2",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 2\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 0\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 0\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + -1",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + -1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 2)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 2)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 0)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + 0)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + -1)]",
      "code": "import heapq\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-1 for _ in range(n + 1)]\n    visited = [False for _ in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n    while stack:\n        u = heapq.heappop(stack)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n    return dist\n\ndef find_possible_book_locations(n, m, d, affected_settlements, paths):\n    graph = [[] for _ in range(n + -1)]\n    for (a, b) in paths:\n        graph[a].append(b)\n        graph[b].append(a)\n    dist = dfs(graph, 1)\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in affected_settlements:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n    distu = dfs(graph, u)\n    max_distance = -1\n    for i in affected_settlements:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n    distv = dfs(graph, v)\n    affected = 0\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n    return affected"
    }
  ]
}