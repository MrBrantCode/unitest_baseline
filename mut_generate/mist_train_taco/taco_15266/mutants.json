{
  "task_id": "taco_15266",
  "entry_point": "calculate_maximum_snuuk",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u += 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v += 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 2\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 0\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 0\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= -1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 2\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 0\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 0\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= -1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = 1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 1\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = -1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = -1\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = 1",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 1\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s + 1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s + 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s * 1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s * 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t + 1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t + 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t * 1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t * 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 15 + sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 + sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 15 * sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 * sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n + 1, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n + 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n * 1, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n * 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 1, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, -1, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 1, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, +1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, +1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if D[u] < du:",
      "mutated_line": "if D[u] <= du:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] <= du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if D[u] < du:",
      "mutated_line": "if D[u] >= du:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] >= du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if D[u] < du:",
      "mutated_line": "if D[u] != du:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] != du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s - 2)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 2)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s - 0)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 0)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s - 0)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 0)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D1 = dijkstra(n, G1, s - 1)",
      "mutated_line": "D1 = dijkstra(n, G1, s - -1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - -1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t - 2)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 2)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t - 0)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 0)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t - 0)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 0)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D2 = dijkstra(n, G2, t - 1)",
      "mutated_line": "D2 = dijkstra(n, G2, t - -1)",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - -1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 * 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 * 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 + 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 + 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 2, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 2, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 0, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 0, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - -1, 0, -1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - -1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -2):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -2):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -0):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -0):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, --1):",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, --1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i + 1] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i + 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i * 1] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i * 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(1, start)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(1, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(-1, start)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(-1, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(1, start)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(1, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if D[v] > du + d:",
      "mutated_line": "if D[v] >= du + d:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] >= du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if D[v] > du + d:",
      "mutated_line": "if D[v] <= du + d:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] <= du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if D[v] > du + d:",
      "mutated_line": "if D[v] != du + d:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] != du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [11 ** 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [11 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [9 ** 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [9 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [0 ** 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [0 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [1 ** 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [1 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [-10 ** 15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [-10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 16 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 16 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 14 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 14 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 0 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 0 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** 1 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 1 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [10**15 - sum(_) for _ in zip(D1, D2)]",
      "mutated_line": "D = [10 ** -15 - sum(_) for _ in zip(D1, D2)]",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** -15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 2] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 2] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 0] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 0] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 0] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 0] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - -1] = max(D[i - 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - -1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i + 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i + 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i * 1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i * 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if D[v] > du + d:",
      "mutated_line": "if D[v] > du - d:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du - d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if D[v] > du + d:",
      "mutated_line": "if D[v] > du * d:",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du * d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "D[v] = du + d",
      "mutated_line": "D[v] = du - d",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du - d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "D[v] = du + d",
      "mutated_line": "D[v] = du * d",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du * d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 1], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i - 2], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 2], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i - 0], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 0], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i - 0], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - 0], D[i])\n    return D"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D[i - 1] = max(D[i - 1], D[i])",
      "mutated_line": "D[i - 1] = max(D[i - -1], D[i])",
      "code": "import collections\nfrom heapq import heappush, heappop\n\ndef calculate_maximum_snuuk(n, m, s, t, trains):\n    G1 = collections.defaultdict(lambda : collections.defaultdict(int))\n    G2 = collections.defaultdict(lambda : collections.defaultdict(int))\n    for (u, v, a, b) in trains:\n        u -= 1\n        v -= 1\n        G1[u][v] = G1[v][u] = a\n        G2[u][v] = G2[v][u] = b\n\n    def dijkstra(V, G, start):\n        INF = float('inf')\n        D = [INF for _ in range(V)]\n        D[start] = 0\n        H = [(0, start)]\n        while H:\n            (du, u) = heappop(H)\n            if D[u] < du:\n                continue\n            for (v, d) in G[u].items():\n                if D[v] > du + d:\n                    D[v] = du + d\n                    heappush(H, (D[v], v))\n        return D\n    D1 = dijkstra(n, G1, s - 1)\n    D2 = dijkstra(n, G2, t - 1)\n    D = [10 ** 15 - sum(_) for _ in zip(D1, D2)]\n    for i in range(n - 1, 0, -1):\n        D[i - 1] = max(D[i - -1], D[i])\n    return D"
    }
  ]
}