{
  "task_id": "taco_13141",
  "entry_point": "analyze_recursion_depth",
  "mutant_count": 40,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "PARSE = re.compile('[pP]\\\\d+|q')",
      "mutated_line": "PARSE = re.compile('')",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "def parse(it, p=''):",
      "mutated_line": "",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p='MUTATED'):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def travel(p, seen, d=1):",
      "mutated_line": "def travel(p, seen, d=2):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=2):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def travel(p, seen, d=1):",
      "mutated_line": "def travel(p, seen, d=0):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=0):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def travel(p, seen, d=1):",
      "mutated_line": "def travel(p, seen, d=0):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=0):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def travel(p, seen, d=1):",
      "mutated_line": "def travel(p, seen, d=-1):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=-1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if m[0].startswith('p'):",
      "mutated_line": "if m[0].startswith(''):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith(''):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif m[0] == 'q':",
      "mutated_line": "elif m[0] != 'q':",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] != 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield 0",
      "mutated_line": "yield 1",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 1\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield 0",
      "mutated_line": "yield -1",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield -1\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield 0",
      "mutated_line": "yield 1",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 1\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n in seen:",
      "mutated_line": "if n not in seen:",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n not in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=1), max(inf, default=0)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=1), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=-1), max(inf, default=0)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=-1), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=1), max(inf, default=0)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=1), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=0), max(inf, default=1)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=1)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=0), max(inf, default=-1)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=-1)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return [min(inf, default=0), max(inf, default=0)]",
      "mutated_line": "return [min(inf, default=0), max(inf, default=1)]",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif m[0] == 'q':",
      "mutated_line": "elif m[0] == '':",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == '':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if m[0].startswith('p'):",
      "mutated_line": "if m[1].startswith('p'):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[1].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if m[0].startswith('p'):",
      "mutated_line": "if m[-1].startswith('p'):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[-1].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if m[0].startswith('p'):",
      "mutated_line": "if m[1].startswith('p'):",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[1].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parse(it, m[0])",
      "mutated_line": "parse(it, m[1])",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[1])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parse(it, m[0])",
      "mutated_line": "parse(it, m[-1])",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[-1])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parse(it, m[0])",
      "mutated_line": "parse(it, m[1])",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[1])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif m[0] == 'q':",
      "mutated_line": "elif m[1] == 'q':",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[1] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif m[0] == 'q':",
      "mutated_line": "elif m[-1] == 'q':",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[-1] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif m[0] == 'q':",
      "mutated_line": "elif m[1] == 'q':",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[1] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))",
      "mutated_line": "inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds['MUTATED'])))",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds['MUTATED'])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen & {n}, d + 1)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen & {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen ^ {n}, d + 1)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen ^ {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d - 1)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d - 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d * 1)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d * 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d + 2)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 2)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d + 0)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 0)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d + 0)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 0)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from travel(n, seen | {n}, d + 1)",
      "mutated_line": "yield from travel(n, seen | {n}, d + -1)",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[0].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + -1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pCmds[p].append(m[0].lower())",
      "mutated_line": "pCmds[p].append(m[1].lower())",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[1].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pCmds[p].append(m[0].lower())",
      "mutated_line": "pCmds[p].append(m[-1].lower())",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[-1].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pCmds[p].append(m[0].lower())",
      "mutated_line": "pCmds[p].append(m[1].lower())",
      "code": "from collections import defaultdict\nfrom itertools import chain\nimport re\nPARSE = re.compile('[pP]\\\\d+|q')\n\ndef analyze_recursion_depth(prog):\n\n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'):\n                parse(it, m[0])\n            elif m[0] == 'q':\n                return\n            else:\n                pCmds[p].append(m[1].lower())\n\n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen:\n                    yield d\n                else:\n                    yield from travel(n, seen | {n}, d + 1)\n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable((travel(p, {p}) for p in pCmds[''])))\n    return [min(inf, default=0), max(inf, default=0)]"
    }
  ]
}