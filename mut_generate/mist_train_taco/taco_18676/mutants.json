{
  "task_id": "taco_18676",
  "entry_point": "find_longest_duplicate_substring",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 1\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "start = 0",
      "mutated_line": "start = -1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = -1\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 1\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while low < high:",
      "mutated_line": "while low <= high:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low <= high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while low < high:",
      "mutated_line": "while low >= high:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low >= high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while low < high:",
      "mutated_line": "while low != high:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low != high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in S]",
      "mutated_line": "nums = [ord(c) + ord('a') for c in S]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) + ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in S]",
      "mutated_line": "nums = [ord(c) * ord('a') for c in S]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) * ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (27, 2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (27, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (25, 2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (25, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (0, 2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (0, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (1, 2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (1, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (-26, 2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (-26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 * 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 * 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 + 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 + 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cur_hash = 0",
      "mutated_line": "cur_hash = 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 1\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cur_hash = 0",
      "mutated_line": "cur_hash = -1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = -1\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cur_hash = 0",
      "mutated_line": "cur_hash = 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 1\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "cur_hash -= nums[idx] * X",
      "mutated_line": "cur_hash += nums[idx] * X",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash += nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return +1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (2, N + 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (2, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (0, N + 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (0, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (0, N + 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (0, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (-1, N + 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (-1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N - 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N - 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N * 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N * 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) / 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) / 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) * 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) * 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx == -1:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx == -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 3 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 3 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 1 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 1 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 0 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 0 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 1 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 1 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, -2 ** 32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, -2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 ** 33)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 33)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 ** 31)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 31)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 ** 0)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 0)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 ** 1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 1)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE, MOD = 26, 2 ** 32",
      "mutated_line": "(BASE, MOD) = (26, 2 ** -32)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** -32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash * BASE + val) * MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) * MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = cur_hash * BASE + val + MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = cur_hash * BASE + val + MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L + 1, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L + 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L * 1, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L * 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cur_hash -= nums[idx] * X",
      "mutated_line": "cur_hash -= nums[idx] / X",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] / X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cur_hash -= nums[idx] * X",
      "mutated_line": "cur_hash -= nums[idx] + X",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] + X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cur_hash -= nums[idx] * X",
      "mutated_line": "cur_hash -= nums[idx] ** X",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] ** X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash * BASE + val) * MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) * MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = cur_hash * BASE + val + MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = cur_hash * BASE + val + MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cur_hash in seen:",
      "mutated_line": "if cur_hash not in seen:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash not in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -2\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -0\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -0\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return --1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N + 2)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 2)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N + 0)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 0)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N + 0)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 0)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "low, high = 1, N + 1",
      "mutated_line": "(low, high) = (1, N + -1)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + -1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low - high) // 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low - high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = low * high // 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = low * high // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 3",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 3\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 1\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 0\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 1\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // -2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // -2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx != +1:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != +1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid - 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid - 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid * 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid * 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start + low + 1]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:(start + low) * 1]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:(start + low) * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "nums = [ord(c) - ord('a') for c in S]",
      "mutated_line": "nums = [ord(c) - ord('') for c in S]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash * BASE - val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE - val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = cur_hash * BASE * val % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = cur_hash * BASE * val % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L - 2, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 2, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L - 0, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 0, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L - 0, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 0, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = pow(BASE, L - 1, MOD)",
      "mutated_line": "X = pow(BASE, L - -1, MOD)",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - -1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash * BASE - val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE - val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = cur_hash * BASE * val % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = cur_hash * BASE * val % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx - 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx - 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx * 1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx * 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx != -2:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -2:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx != -0:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -0:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx != -0:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -0:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if idx != -1:",
      "mutated_line": "if idx != --1:",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != --1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 2\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 0\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 0\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + -1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + -1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start - low - 1]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start - low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start * low - 1]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start * low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start + low - 2]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start + low - 0]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start + low - 0]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return S[start:start + low - 1]",
      "mutated_line": "return S[start:start + low - -1]",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - -1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash / BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash / BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash + BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash + BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash ** BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash ** BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash / BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash / BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash + BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash + BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_hash = (cur_hash * BASE + val) % MOD",
      "mutated_line": "cur_hash = (cur_hash ** BASE + val) % MOD",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash ** BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx + 2",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 2\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx + 0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 0\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx + 0",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + 0\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return idx + 1",
      "mutated_line": "return idx + -1",
      "code": "def find_longest_duplicate_substring(S: str) -> str:\n    nums = [ord(c) - ord('a') for c in S]\n    N = len(S)\n    (BASE, MOD) = (26, 2 ** 32)\n\n    def check(L: int) -> int:\n        cur_hash = 0\n        seen = set()\n        for val in nums[:L]:\n            cur_hash = (cur_hash * BASE + val) % MOD\n        seen.add(cur_hash)\n        X = pow(BASE, L - 1, MOD)\n        for (idx, val) in enumerate(nums[L:]):\n            cur_hash -= nums[idx] * X\n            cur_hash = (cur_hash * BASE + val) % MOD\n            if cur_hash in seen:\n                return idx + -1\n            seen.add(cur_hash)\n        return -1\n    (low, high) = (1, N + 1)\n    start = 0\n    while low < high:\n        mid = (low + high) // 2\n        idx = check(mid)\n        if idx != -1:\n            low = mid + 1\n            start = idx\n        else:\n            high = mid\n    return S[start:start + low - 1]"
    }
  ]
}