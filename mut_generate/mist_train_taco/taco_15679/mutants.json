{
  "task_id": "taco_15679",
  "entry_point": "shallowest_path",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]",
      "mutated_line": "cost = [[(float('inf'), float('inf'))] / lY for _ in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] / lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]",
      "mutated_line": "cost = [[(float('inf'), float('inf'))] + lY for _ in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] + lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]",
      "mutated_line": "cost = [[(float('inf'), float('inf'))] ** lY for _ in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] ** lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx and dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx and dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][1] = (river[x][0], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][1] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][-1] = (river[x][0], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][-1] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][1] = (river[x][0], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][1] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][0], 2)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 2)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][0], 0)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 0)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][0], 0)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 0)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][0], -1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], -1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY != 1, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY != 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 2, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 2, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 0, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 0, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 0, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 0, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, -1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, -1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[0][2]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][2]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[0][0]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][0]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[0][0]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][0]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[0][-1]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][-1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX or 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX or 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[0][+1])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][+1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::+1]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::+1]"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(+1, 2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(+1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 3) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 3) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 1) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 1) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 0) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 0) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 1) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 1) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, -2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, -2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(+1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(+1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 3) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 3) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 1) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 1) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 0) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 0) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 1) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 1) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, -2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, -2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(lX, lY) = (len(river), len(river[0]))",
      "mutated_line": "(lX, lY) = (len(river), len(river[1]))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[1]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(lX, lY) = (len(river), len(river[0]))",
      "mutated_line": "(lX, lY) = (len(river), len(river[-1]))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[-1]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(lX, lY) = (len(river), len(river[0]))",
      "mutated_line": "(lX, lY) = (len(river), len(river[1]))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[1]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][1], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][1], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][-1], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][-1], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[x][0] = (river[x][0], 1)",
      "mutated_line": "cost[x][0] = (river[x][1], 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][1], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][1], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][1], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][-1], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][-1], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][1], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][1], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 2, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 2, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 0, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 0, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 0, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 0, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == -1, 1, (x, 0)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == -1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 1, (x, 1)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 1)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 1, (x, -1)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, -1)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]",
      "mutated_line": "q = [(river[x][0], lY == 1, 1, (x, 1)) for x in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 1)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[1][1]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[1][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[-1][1]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[-1][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while not q[0][1]:",
      "mutated_line": "while not q[1][1]:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[1][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(a, b) = new = (x + dx, y + dy)",
      "mutated_line": "(a, b) = new = (x - dx, y + dy)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x - dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(a, b) = new = (x + dx, y + dy)",
      "mutated_line": "(a, b) = new = (x * dx, y + dy)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x * dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(a, b) = new = (x + dx, y + dy)",
      "mutated_line": "(a, b) = new = (x + dx, y - dy)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y - dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(a, b) = new = (x + dx, y + dy)",
      "mutated_line": "(a, b) = new = (x + dx, y * dy)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y * dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 < a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 < a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 > a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 > a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 == a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 == a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and 0 < b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 < b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and 0 > b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 > b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and 0 == b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 == b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cost[a][b] > check:",
      "mutated_line": "if cost[a][b] >= check:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] >= check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cost[a][b] > check:",
      "mutated_line": "if cost[a][b] <= check:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] <= check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cost[a][b] > check:",
      "mutated_line": "if cost[a][b] != check:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] != check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[1][-1])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[1][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[-1][-1])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[-1][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[1][-1])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[1][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[0][-2])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-2])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[0][-0])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-0])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[0][-0])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-0])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(path, pos) = ([], q[0][-1])",
      "mutated_line": "(path, pos) = ([], q[0][--1])",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][--1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-2]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-2]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::--1]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::--1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-2, 2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-2, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-0, 2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-0, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-0, 2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-0, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(--1, 2) for dy in range(-1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(--1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-2, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-2, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-0, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-0, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-0, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-0, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))",
      "mutated_line": "MOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(--1, 2) if dx or dy))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(--1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 1 <= a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 1 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if -1 <= a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if -1 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 1 <= a < lX and 0 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 1 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and 1 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 1 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and -1 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and -1 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= a < lX and 0 <= b < lY:",
      "mutated_line": "if 0 <= a < lX and 1 <= b < lY:",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 1 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps - 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps - 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps * 1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps * 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]",
      "mutated_line": "cost = [[(float(''), float('inf'))] * lY for _ in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float(''), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]",
      "mutated_line": "cost = [[(float('inf'), float(''))] * lY for _ in range(lX)]",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float(''))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 2)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 2)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 0)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 0)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 0)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 0)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check = (nC, nS) = (max(c, river[a][b]), steps + 1)",
      "mutated_line": "check = (nC, nS) = (max(c, river[a][b]), steps + -1)",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + -1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b != lY - 1, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b != lY - 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY + 1, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY + 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY * 1, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY * 1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY - 2, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 2, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY - 0, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 0, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY - 0, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - 0, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heappush(q, (nC, b == lY - 1, nS, new))",
      "mutated_line": "heappush(q, (nC, b == lY - -1, nS, new))",
      "code": "from heapq import *\nMOVES = tuple(((dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if dx or dy))\n\ndef shallowest_path(river):\n    (lX, lY) = (len(river), len(river[0]))\n    pathDct = {}\n    cost = [[(float('inf'), float('inf'))] * lY for _ in range(lX)]\n    for x in range(lX):\n        cost[x][0] = (river[x][0], 1)\n    q = [(river[x][0], lY == 1, 1, (x, 0)) for x in range(lX)]\n    heapify(q)\n    while not q[0][1]:\n        (c, _, steps, pos) = heappop(q)\n        (x, y) = pos\n        for (dx, dy) in MOVES:\n            (a, b) = new = (x + dx, y + dy)\n            if 0 <= a < lX and 0 <= b < lY:\n                check = (nC, nS) = (max(c, river[a][b]), steps + 1)\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b == lY - -1, nS, new))\n    (path, pos) = ([], q[0][-1])\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]"
    }
  ]
}