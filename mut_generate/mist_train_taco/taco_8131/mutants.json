{
  "task_id": "taco_8131",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 209,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] / 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] / 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] + 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] + 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] ** 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] ** 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c in range(4):",
      "mutated_line": "for c in range(5):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(5):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c in range(4):",
      "mutated_line": "for c in range(3):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(3):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c in range(4):",
      "mutated_line": "for c in range(0):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(0):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c in range(4):",
      "mutated_line": "for c in range(1):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(1):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c in range(4):",
      "mutated_line": "for c in range(-4):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(-4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][0] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 1\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][0] = -1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = -1\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][0] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 1\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] <= 4:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] <= 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] >= 4:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] >= 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] != 4:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] != 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 5 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 5 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 3 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 3 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 0 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 0 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 1 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 1 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * -4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * -4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(5):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(5):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(3):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(3):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(0):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(0):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(1):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(1):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(-4):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(-4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c == 0:",
      "mutated_line": "if c != 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c != 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][1] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][-1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][-1] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][0][1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][1] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w + 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w * 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w * 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] < 5:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 5:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] < 3:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 3:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] < 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 0:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] < 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 1:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if commands[y][x] < 4:",
      "mutated_line": "if commands[y][x] < -4:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < -4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "co[y][x][commands[y][x]] = 0",
      "mutated_line": "co[y][x][commands[y][x]] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 1\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "co[y][x][commands[y][x]] = 0",
      "mutated_line": "co[y][x][commands[y][x]] = -1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = -1\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "co[y][x][commands[y][x]] = 0",
      "mutated_line": "co[y][x][commands[y][x]] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 1\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[1] * 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[1] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[-1] * 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[-1] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[1] * 4 for i in range(4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[1] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 4 for i in range(5)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(5)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 4 for i in range(3)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(3)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 4 for i in range(0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(0)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 4 for i in range(1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(1)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ro = [[0] * 4 for i in range(4)]",
      "mutated_line": "ro = [[0] * 4 for i in range(-4)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(-4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c == 0:",
      "mutated_line": "if c == 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 1:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c == 0:",
      "mutated_line": "if c == -1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == -1:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c == 0:",
      "mutated_line": "if c == 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 1:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif c == 1:",
      "mutated_line": "elif c != 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c != 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] / 4 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] / 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] + 4 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] + 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] ** 4 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] ** 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][1][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][-1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][-1][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[0][1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][1][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(1, 0, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(1, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(-1, 0, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(-1, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(1, 0, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(1, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 1, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, -1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, -1, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 1, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, 1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 1, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, -1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, -1, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, 1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 1, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, 0, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 1)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, 0, -1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, -1)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "q = [(0, 0, 0, 0)]",
      "mutated_line": "q = [(0, 0, 0, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 1)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for di in range(4):",
      "mutated_line": "for di in range(5):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(5):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for di in range(4):",
      "mutated_line": "for di in range(3):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(3):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for di in range(4):",
      "mutated_line": "for di in range(0):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(0):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for di in range(4):",
      "mutated_line": "for di in range(1):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(1):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for di in range(4):",
      "mutated_line": "for di in range(-4):",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(-4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "y_ = y + d[c_][0]",
      "mutated_line": "y_ = y - d[c_][0]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y - d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "y_ = y + d[c_][0]",
      "mutated_line": "y_ = y * d[c_][0]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y * d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x - d[c_][1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x - d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x * d[c_][1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x * d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h or 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h or 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h + 1][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h + 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h * 1][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h * 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w - 2])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 2])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w - 0])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 0])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w - 0])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 0])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 1][w - -1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif c == 1:",
      "mutated_line": "elif c == 2:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 2:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif c == 1:",
      "mutated_line": "elif c == 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 0:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif c == 1:",
      "mutated_line": "elif c == 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 0:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif c == 1:",
      "mutated_line": "elif c == -1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == -1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) * 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) * 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = i + 1 + 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = i + 1 + 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c != 2:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c != 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] * 5 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 5 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] * 3 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 3 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] * 0 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 0 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] * 1 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 1 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('inf')] * -4 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * -4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[1][0][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[1][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[-1][0][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[-1][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist[0][0][0] = 0",
      "mutated_line": "dist[1][0][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[1][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 < y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 < y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 > y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 > y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 == y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 == y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and 0 < x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 < x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and 0 > x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 > x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and 0 == x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 == x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[y_][x_][c_] > dn + co[y][x][di]:",
      "mutated_line": "if dist[y_][x_][c_] >= dn + co[y][x][di]:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] >= dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[y_][x_][c_] > dn + co[y][x][di]:",
      "mutated_line": "if dist[y_][x_][c_] <= dn + co[y][x][di]:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] <= dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[y_][x_][c_] > dn + co[y][x][di]:",
      "mutated_line": "if dist[y_][x_][c_] != dn + co[y][x][di]:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] != dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 2][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 2][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 0][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 0][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - 0][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 0][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return min(dist[h - 1][w - 1])",
      "mutated_line": "return min(dist[h - -1][w - 1])",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - -1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]",
      "mutated_line": "co = [[[costs[i] for i in range(5)] for x in range(w)] for y in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(5)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]",
      "mutated_line": "co = [[[costs[i] for i in range(3)] for x in range(w)] for y in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(3)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]",
      "mutated_line": "co = [[[costs[i] for i in range(0)] for x in range(w)] for y in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(0)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]",
      "mutated_line": "co = [[[costs[i] for i in range(1)] for x in range(w)] for y in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(1)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]",
      "mutated_line": "co = [[[costs[i] for i in range(-4)] for x in range(w)] for y in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(-4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i - 1) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i - 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = i * 1 % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = i * 1 % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 5",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 5\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 3",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 3\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 0\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 1\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % -4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % -4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c == 3:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 3:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c == 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 1:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c == 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 0:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c == 1:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 1:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif c == 2:",
      "mutated_line": "elif c == -2:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == -2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) * 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) * 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = i + 2 + 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = i + 2 + 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) * 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) * 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = i + 3 + 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = i + 3 + 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "y_ = y + d[c_][0]",
      "mutated_line": "y_ = y + d[c_][1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][1]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "y_ = y + d[c_][0]",
      "mutated_line": "y_ = y + d[c_][-1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][-1]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "y_ = y + d[c_][0]",
      "mutated_line": "y_ = y + d[c_][1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][1]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x + d[c_][2]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][2]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x + d[c_][0]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][0]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x + d[c_][0]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][0]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "x_ = x + d[c_][1]",
      "mutated_line": "x_ = x + d[c_][-1]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][-1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 1 <= y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 1 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if -1 <= y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if -1 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 1 <= y_ < h and 0 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 1 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and 1 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 1 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and -1 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and -1 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= y_ < h and 0 <= x_ < w:",
      "mutated_line": "if 0 <= y_ < h and 1 <= x_ < w:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 1 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dist[y_][x_][c_] > dn + co[y][x][di]:",
      "mutated_line": "if dist[y_][x_][c_] > dn - co[y][x][di]:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn - co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dist[y_][x_][c_] > dn + co[y][x][di]:",
      "mutated_line": "if dist[y_][x_][c_] > dn * co[y][x][di]:",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn * co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dist[y_][x_][c_] = dn + co[y][x][di]",
      "mutated_line": "dist[y_][x_][c_] = dn - co[y][x][di]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn - co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dist[y_][x_][c_] = dn + co[y][x][di]",
      "mutated_line": "dist[y_][x_][c_] = dn * co[y][x][di]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn * co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 2) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 0) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 0) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + 0) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 0) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ro[c][i] = (i + 1) % 4",
      "mutated_line": "ro[c][i] = (i + -1) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + -1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i - 2) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i - 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = i * 2 % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = i * 2 % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 5",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 5\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 3",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 3\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 0\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 1\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % -4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % -4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i - 3) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i - 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = i * 3 % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = i * 3 % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % 5",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 5\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % 3",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 3\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % 0",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 0\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % 1",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 1\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % -4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % -4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]",
      "mutated_line": "dist = [[[float('')] * 4 for i in range(w)] for j in range(h)]",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 3) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 3) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 1) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 0) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 0) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 1) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ro[c][i] = (i + 2) % 4",
      "mutated_line": "ro[c][i] = (i + -2) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + -2) % 4\n            else:\n                ro[c][i] = (i + 3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 4) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 4) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 2) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 2) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 0) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 0) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + 1) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + 1) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ro[c][i] = (i + 3) % 4",
      "mutated_line": "ro[c][i] = (i + -3) % 4",
      "code": "import sys\nfrom heapq import heappush, heappop\nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\ndef calculate_minimum_cost(w, h, commands, costs):\n    co = [[[costs[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if commands[y][x] < 4:\n                co[y][x][commands[y][x]] = 0\n    ro = [[0] * 4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i + 1) % 4\n            elif c == 2:\n                ro[c][i] = (i + 2) % 4\n            else:\n                ro[c][i] = (i + -3) % 4\n\n    def bfs():\n        dist = [[[float('inf')] * 4 for i in range(w)] for j in range(h)]\n        dist[0][0][0] = 0\n        q = [(0, 0, 0, 0)]\n        while q:\n            (dn, y, x, c) = heappop(q)\n            for di in range(4):\n                c_ = ro[di][c]\n                y_ = y + d[c_][0]\n                x_ = x + d[c_][1]\n                if 0 <= y_ < h and 0 <= x_ < w:\n                    if dist[y_][x_][c_] > dn + co[y][x][di]:\n                        dist[y_][x_][c_] = dn + co[y][x][di]\n                        heappush(q, (dist[y_][x_][c_], y_, x_, c_))\n        return dist\n    dist = bfs()\n    return min(dist[h - 1][w - 1])"
    }
  ]
}