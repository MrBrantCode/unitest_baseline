{
  "task_id": "taco_358",
  "entry_point": "minimum_coin_permutations",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) / 2",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) / 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) * 2",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) * 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while False:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 3",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 3\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 1",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 1\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 0",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 0\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 1",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 1\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // -2",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // -2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if p_indices[i] < i:",
      "mutated_line": "if p_indices[i] <= i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] <= i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if p_indices[i] < i:",
      "mutated_line": "if p_indices[i] >= i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] >= i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if p_indices[i] < i:",
      "mutated_line": "if p_indices[i] != i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] != i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] + i) for i in range(n))) // 2",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] + i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_coins = sum(abs(p_indices[i] - i) for i in range(n)) // 2",
      "mutated_line": "min_coins = sum((abs(p_indices[i] * i) for i in range(n))) // 2",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] * i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_indices[j] >= i:",
      "mutated_line": "if p_indices[j] > i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] > i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_indices[j] >= i:",
      "mutated_line": "if p_indices[j] < i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] < i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_indices[j] >= i:",
      "mutated_line": "if p_indices[j] == i:",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] == i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i - 1, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i - 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i * 1, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i * 1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j - 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j - 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j * 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j * 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 2, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 2, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 0, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 0, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 0, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 0, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + -1, j + 1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + -1, j + 1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j + 2))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 2))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j + 0))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 0))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j + 0))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + 0))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "operations.append((i + 1, j + 1))  # Convert to 1-based index",
      "mutated_line": "operations.append((i + 1, j + -1))",
      "code": "def minimum_coin_permutations(n, p, s):\n    index_map = {value: idx for (idx, value) in enumerate(s)}\n    p_indices = [index_map[value] for value in p]\n    min_coins = sum((abs(p_indices[i] - i) for i in range(n))) // 2\n    operations = []\n    while True:\n        for i in range(n):\n            if p_indices[i] < i:\n                for j in range(p_indices[i], i):\n                    if p_indices[j] >= i:\n                        (p_indices[i], p_indices[j]) = (p_indices[j], p_indices[i])\n                        operations.append((i + 1, j + -1))\n                        break\n                break\n        else:\n            break\n    return (min_coins, operations)"
    }
  ]
}