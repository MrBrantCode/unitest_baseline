{
  "task_id": "taco_9680",
  "entry_point": "dfs",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 * 6)",
      "code": "import sys\nsys.setrecursionlimit(10 * 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 + 6)",
      "code": "import sys\nsys.setrecursionlimit(10 + 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(links[v]) == 1:",
      "mutated_line": "if len(links[v]) != 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) != 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(children) == 1:",
      "mutated_line": "if len(children) != 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) != 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "o_max = c_sum - c_max",
      "mutated_line": "o_max = c_sum + c_max",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum + c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "o_max = c_sum - c_max",
      "mutated_line": "o_max = c_sum * c_max",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum * c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if o_max >= c_max:",
      "mutated_line": "if o_max > c_max:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max > c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if o_max >= c_max:",
      "mutated_line": "if o_max < c_max:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max < c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if o_max >= c_max:",
      "mutated_line": "if o_max == c_max:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max == c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "min_remain = c_sum - max_pairs",
      "mutated_line": "min_remain = c_sum + max_pairs",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum + max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "min_remain = c_sum - max_pairs",
      "mutated_line": "min_remain = c_sum * max_pairs",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum * max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 2 + c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 + c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 2 * c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 * c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n != 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 1\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = -1\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 1\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while len(links[s]) == 1:",
      "mutated_line": "while len(links[s]) != 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) != 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s -= 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -1, aaa, links) != 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) != 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(11 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(11 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(9 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(9 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(0 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(0 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(1 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(1 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(-10 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(-10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 5)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 0)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 0)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 1)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 1)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** -6)",
      "code": "import sys\nsys.setrecursionlimit(10 ** -6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(links[v]) == 1:",
      "mutated_line": "if len(links[v]) == 2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 2:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(links[v]) == 1:",
      "mutated_line": "if len(links[v]) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 0:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(links[v]) == 1:",
      "mutated_line": "if len(links[v]) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 0:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(links[v]) == 1:",
      "mutated_line": "if len(links[v]) == -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == -1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if u == p:",
      "mutated_line": "if u != p:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u != p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result != -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result != -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(children) == 1:",
      "mutated_line": "if len(children) == 2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 2:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(children) == 1:",
      "mutated_line": "if len(children) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 0:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(children) == 1:",
      "mutated_line": "if len(children) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 0:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(children) == 1:",
      "mutated_line": "if len(children) == -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == -1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if aaa[v] != children[0]:",
      "mutated_line": "if aaa[v] == children[0]:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] == children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum / 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum / 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum * 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum * 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not min_remain <= aaa[v] <= c_sum:",
      "mutated_line": "if not min_remain < aaa[v] <= c_sum:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain < aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not min_remain <= aaa[v] <= c_sum:",
      "mutated_line": "if not min_remain > aaa[v] <= c_sum:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain > aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not min_remain <= aaa[v] <= c_sum:",
      "mutated_line": "if not min_remain == aaa[v] <= c_sum:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain == aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return +1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] / 2 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] / 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] + 2 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] + 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] ** 2 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] ** 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 3:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 1:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 0:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 1:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == -2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[0] != aaa[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] != aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(links[s]) == 1:",
      "mutated_line": "while len(links[s]) == 2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 2:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(links[s]) == 1:",
      "mutated_line": "while len(links[s]) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 0:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(links[s]) == 1:",
      "mutated_line": "while len(links[s]) == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 0:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(links[s]) == 1:",
      "mutated_line": "while len(links[s]) == -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == -1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 2\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 0\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 0\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += -1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -1, aaa, links) == 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -1, aaa, links) == -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -1, aaa, links) == 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result == +1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == +1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return +1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return +1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return children[0]",
      "mutated_line": "return children[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[1]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return children[0]",
      "mutated_line": "return children[-1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[-1]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return children[0]",
      "mutated_line": "return children[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[1]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum // 3",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 3\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum // 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 1\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum // 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 0\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum // 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 1\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "max_pairs = c_sum // 2",
      "mutated_line": "max_pairs = c_sum // -2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // -2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -2\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -0\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -0\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return --1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 3 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 3 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 1 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 1 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 0 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 0 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * 1 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 1 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return aaa[v] * 2 - c_sum",
      "mutated_line": "return aaa[v] * -2 - c_sum",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * -2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, +1, aaa, links) == 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, +1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result == -2:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -2:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result == -0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -0:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result == -0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -0:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if result == -1:",
      "mutated_line": "if result == --1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == --1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -2\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -0\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -0\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return --1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if aaa[v] != children[0]:",
      "mutated_line": "if aaa[v] != children[1]:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[1]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if aaa[v] != children[0]:",
      "mutated_line": "if aaa[v] != children[-1]:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[-1]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if aaa[v] != children[0]:",
      "mutated_line": "if aaa[v] != children[1]:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[1]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -2\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -0\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -0\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return --1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[1] == aaa[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[1] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[-1] == aaa[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[-1] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[1] == aaa[1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[1] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[0] == aaa[2]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[2]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[0] == aaa[0]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[0]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[0] == aaa[0]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[0]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return aaa[0] == aaa[1]",
      "mutated_line": "return aaa[0] == aaa[-1]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[-1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -1, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -2, aaa, links) == 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -2, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -0, aaa, links) == 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -0, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, -0, aaa, links) == 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, -0, aaa, links) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dfs(s, -1, aaa, links) == 0",
      "mutated_line": "return dfs(s, --1, aaa, links) == 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, p, aaa, links):\n    if len(links[v]) == 1:\n        return aaa[v]\n    children = []\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs(u, v, aaa, links)\n        if result == -1:\n            return -1\n        children.append(result)\n    if len(children) == 1:\n        if aaa[v] != children[0]:\n            return -1\n        return children[0]\n    c_sum = sum(children)\n    c_max = max(children)\n    o_max = c_sum - c_max\n    if o_max >= c_max:\n        max_pairs = c_sum // 2\n    else:\n        max_pairs = o_max\n    min_remain = c_sum - max_pairs\n    if not min_remain <= aaa[v] <= c_sum:\n        return -1\n    return aaa[v] * 2 - c_sum\n\ndef can_remove_all_stones(n, aaa, edges):\n    if n == 2:\n        return aaa[0] == aaa[1]\n    links = [set() for _ in range(n)]\n    for (a, b) in edges:\n        links[a].add(b)\n        links[b].add(a)\n    s = 0\n    while len(links[s]) == 1:\n        s += 1\n    return dfs(s, --1, aaa, links) == 0"
    }
  ]
}