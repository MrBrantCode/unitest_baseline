{
  "task_id": "taco_17348",
  "entry_point": "bigmod",
  "mutant_count": 224,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def bigmod(x, n, mod):\n    ans = 2\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def bigmod(x, n, mod):\n    ans = 0\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def bigmod(x, n, mod):\n    ans = 0\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def bigmod(x, n, mod):\n    ans = -1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n >= 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n <= 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n != 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 and x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 and x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return False\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "def MillerRabin(n, iter=1):",
      "mutated_line": "def MillerRabin(n, iter=2):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=2):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "def MillerRabin(n, iter=1):",
      "mutated_line": "def MillerRabin(n, iter=0):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=0):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "def MillerRabin(n, iter=1):",
      "mutated_line": "def MillerRabin(n, iter=0):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=0):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "def MillerRabin(n, iter=1):",
      "mutated_line": "def MillerRabin(n, iter=-1):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=-1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n <= 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n >= 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n != 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 1\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = -1\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 1\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n + 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n + 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n * 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n * 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 2 != 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 != 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "r += 1",
      "mutated_line": "r -= 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r -= 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return False\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 1:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > -1:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 1:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 != 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 2\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 0\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 0\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= -1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = x * x % mod",
      "mutated_line": "x = x * x * mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x * mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = x * x % mod",
      "mutated_line": "x = x * x + mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x + mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x != 1 or x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x != 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x != n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x != n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return True\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s + 1):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s + 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s * 1):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s * 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x = x * x % n",
      "mutated_line": "x = x * x * n",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x * n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x = x * x % n",
      "mutated_line": "x = x * x + n",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x + n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == 1:",
      "mutated_line": "if x != 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x != 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x != n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x != n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 3:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 1:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 0:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 1:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < -2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return True\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n - 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 2\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n - 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 0\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n - 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 0\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = n - 1",
      "mutated_line": "d = n - -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - -1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d * 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d * 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d + 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d + 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 1:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 2 == -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == -1:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 1:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d >>= 1",
      "mutated_line": "d >>= 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 2\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d >>= 1",
      "mutated_line": "d >>= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 0\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d >>= 1",
      "mutated_line": "d >>= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 0\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d >>= 1",
      "mutated_line": "d >>= -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= -1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r += 1",
      "mutated_line": "r += 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 2\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 0\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 0\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r += 1",
      "mutated_line": "r += -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += -1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [3, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [3, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [0, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [0, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [-2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [-2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 2, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 2, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 0, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 0, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 1, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 1, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, -3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, -3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 6, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 6, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 4, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 4, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 0, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 0, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 1, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 1, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, -5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, -5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 8, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 8, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 6, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 6, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 0, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 0, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 1, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 1, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, -7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, -7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 12, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 12, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 10, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 10, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 0, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 0, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 1, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 1, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, -11, 13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, -11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 14, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 14, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 12, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 12, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 0, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 0, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 1, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 1, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, -13, 17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, -13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 18, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 18, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 16, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 16, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 0, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 0, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 1, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 1, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, -17, 19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, -17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 20, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 20, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 18, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 18, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 0, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 0, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 1, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 1, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, -19, 23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, -19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 24, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 24, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 22, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 22, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 0, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 0, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 1, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 1, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, -23, 29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, -23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 30, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 30, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 28, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 28, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 0, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 0, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 1, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 1, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, -29, 31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, -29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 32, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 32, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 30, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 30, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 0, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 0, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 1, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 1, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, -31, 37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, -31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 38]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 38]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 36]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 36]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 0]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 0]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 1]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 1]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
      "mutated_line": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, -37]",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, -37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if n == a:",
      "mutated_line": "if n != a:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n != a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if check_composite(n, a, d, r) == True:",
      "mutated_line": "if check_composite(n, a, d, r) != True:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) != True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n != 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 != 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "n -= 1",
      "mutated_line": "n += 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n += 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n += 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n += 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n * 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n + 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 2:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 0:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 0:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == -1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = ans * x % mod",
      "mutated_line": "ans = ans * x * mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x * mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = ans * x % mod",
      "mutated_line": "ans = ans * x + mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x + mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = x * x % mod",
      "mutated_line": "x = x / x % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x / x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = x * x % mod",
      "mutated_line": "x = (x + x) % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = (x + x) % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = x * x % mod",
      "mutated_line": "x = x ** x % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x ** x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 2 or x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 2 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 0 or x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 0 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 0 or x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 0 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == -1 or x == n - 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == -1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n + 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n + 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n * 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n * 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s - 2):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 2):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s - 0):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 0):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s - 0):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 0):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for r in range(s - 1):",
      "mutated_line": "for r in range(s - -1):",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - -1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x = x * x % n",
      "mutated_line": "x = x / x % n",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x / x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x = x * x % n",
      "mutated_line": "x = (x + x) % n",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = (x + x) % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x = x * x % n",
      "mutated_line": "x = x ** x % n",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x ** x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 2:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 0:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 0:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == 1:",
      "mutated_line": "if x == -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == -1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return False\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n + 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n + 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n * 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n * 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return True\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 3 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 3 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 1 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 1 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 0 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 0 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % 1 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 1 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while d % 2 == 0:",
      "mutated_line": "while d % -2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % -2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return False\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n % a != 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a != 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if check_composite(n, a, d, r) == True:",
      "mutated_line": "if check_composite(n, a, d, r) == False:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == False:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return True\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 3:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 1:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 0:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 1:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == -2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n * 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n + 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 1:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == -1:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 1:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "n -= 1",
      "mutated_line": "n -= 2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 2\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 0\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 0\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "n -= 1",
      "mutated_line": "n -= -1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= -1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n -= 3",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 3\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n -= 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 1\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n -= 0",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 0\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n -= 1",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 1\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n -= 2",
      "mutated_line": "n -= -2",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= -2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 3 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 1 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 0 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 1 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % -2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = ans * x % mod",
      "mutated_line": "ans = ans / x % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans / x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = ans * x % mod",
      "mutated_line": "ans = (ans + x) % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = (ans + x) % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = ans * x % mod",
      "mutated_line": "ans = ans ** x % mod",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans ** x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n - 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 2:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n - 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 0:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n - 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 0:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == 1 or x == n - 1:",
      "mutated_line": "if x == 1 or x == n - -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - -1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n - 2:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 2:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n - 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 0:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n - 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 0:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x == n - 1:",
      "mutated_line": "if x == n - -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - -1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n * a == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n * a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n + a == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n + a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n % a == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 1:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n % a == -1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == -1:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif n % a == 0:",
      "mutated_line": "elif n % a == 1:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 1:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return True\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "results.append(2)",
      "mutated_line": "results.append(3)",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(3)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "results.append(2)",
      "mutated_line": "results.append(1)",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(1)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "results.append(2)",
      "mutated_line": "results.append(0)",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(0)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "results.append(2)",
      "mutated_line": "results.append(1)",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(1)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "results.append(2)",
      "mutated_line": "results.append(-2)",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(-2)\n            continue\n        if n % 2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 3 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 1 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 0 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % 1 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "def bigmod(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        n >>= 1\n        x = x * x % mod\n    return ans\n\ndef check_composite(n, a, d, s):\n    x = bigmod(a, d, n)\n    if x == 1 or x == n - 1:\n        return False\n    for r in range(s - 1):\n        x = x * x % n\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n\ndef MillerRabin(n, iter=1):\n    if n < 2:\n        return False\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        r += 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in primes:\n        if n == a:\n            return True\n        elif n % a == 0:\n            return False\n        if check_composite(n, a, d, r) == True:\n            return False\n    return True\n\ndef find_max_phi_ratio_index(T, N_list):\n    results = []\n    for n in N_list:\n        if n == 2:\n            results.append(2)\n            continue\n        if n % -2 == 0:\n            n -= 1\n        while not MillerRabin(n):\n            n -= 2\n        results.append(n)\n    return results"
    }
  ]
}