{
  "task_id": "taco_411",
  "entry_point": "max_uniform_pants",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S != S[0] * N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S != S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if K == 0:",
      "mutated_line": "if K != 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K != 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 1\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = -1\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 1\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 1\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = -1\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 1\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "while i < n and arr[i] == c:",
      "mutated_line": "while i < n or arr[i] == c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n or arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans -= 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i -= 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= n:",
      "mutated_line": "if i > n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i > n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= n:",
      "mutated_line": "if i < n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i < n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= n:",
      "mutated_line": "if i == n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i == n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n + 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n + 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n * 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n * 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while arr[j] == c:",
      "mutated_line": "while arr[j] != c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] != c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans -= 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j += 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k == 0 or ans != n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 or ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k != 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 1\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = -1\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 1\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 or len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 or len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans -= -1 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans -= -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k += 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans != 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans != 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[0] / N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] / N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[0] + N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] + N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[0] ** N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] ** N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 1:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if K == 0:",
      "mutated_line": "if K == -1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == -1:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 1:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return +1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n and arr[i] == c:",
      "mutated_line": "while i <= n and arr[i] == c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i <= n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n and arr[i] == c:",
      "mutated_line": "while i >= n and arr[i] == c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i >= n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n and arr[i] == c:",
      "mutated_line": "while i != n and arr[i] == c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i != n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n and arr[i] == c:",
      "mutated_line": "while i < n and arr[i] != c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] != c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 2\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 0\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 0\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += -1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 2\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 0\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 0\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += -1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n - 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 2\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n - 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 0\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n - 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 0\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j = n - 1",
      "mutated_line": "j = n - -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - -1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 2\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 0\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 0\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += -1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 2\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 0\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 0\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= -1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k != 0 and ans != n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k != 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k == 0 and ans == n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans == n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return +1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 2:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 0:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 0:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == -1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j - 1):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j - 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j * 1):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j * 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if arr[m] == c:",
      "mutated_line": "if arr[m] != c:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] != c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "temp += 1",
      "mutated_line": "temp -= 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp -= 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k >= 1 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k >= 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k <= 1 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k <= 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k != 1 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k != 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) >= 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) >= 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) <= 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) <= 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) != 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) != 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += -1 / heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 / heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += -1 + heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 + heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += (-1) ** heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += (-1) ** heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 2\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 0\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 0\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= -1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 1:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == -1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == -1:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 1:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return +1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -2\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -0\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -0\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return --1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k == 1 and ans != n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 1 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k == -1 and ans != n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == -1 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k == 0 and ans != n:",
      "mutated_line": "if k == 1 and ans != n:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 1 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -2\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -0\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -0\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return --1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j + 2):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 2):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j + 0):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 0):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j + 0):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 0):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for m in range(i, j + 1):",
      "mutated_line": "for m in range(i, j + -1):",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + -1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp += 1",
      "mutated_line": "temp += 2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 2\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp += 1",
      "mutated_line": "temp += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 0\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp += 1",
      "mutated_line": "temp += 0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 0\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp += 1",
      "mutated_line": "temp += -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += -1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp >= 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp >= 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp <= 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp <= 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp != 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp != 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 1\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp = 0",
      "mutated_line": "temp = -1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = -1\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 1\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 2 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 2 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 0 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 0 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 0 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 0 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > -1 and len(h) > 0:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > -1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) > 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 1:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) > -1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > -1:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while k > 1 and len(h) > 0:",
      "mutated_line": "while k > 1 and len(h) > 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 1:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += +1 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += +1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -2\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -0\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -0\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return --1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[1] * N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[1] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[-1] * N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[-1] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if S == S[0] * N:",
      "mutated_line": "if S == S[1] * N:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[1] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp > 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 1:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp > -1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > -1:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if temp > 0:",
      "mutated_line": "if temp > 1:",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 1:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += -2 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -2 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += -0 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -0 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += -0 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -0 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += -1 * heapq.heappop(h)",
      "mutated_line": "ans += --1 * heapq.heappop(h)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += --1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') - 1)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') - 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') * 1)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') * 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, -1 / temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 / temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, -1 + temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 + temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, (-1) ** temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, (-1) ** temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord(''), ord('Z') + 1)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord(''), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 2)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 2)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 0)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 0)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 0)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 0)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + -1)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + -1)])"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, +1 * temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, +1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])",
      "mutated_line": "return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('') + 1)])",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, -2 * temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -2 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, -0 * temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -0 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, -0 * temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, -0 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(h, -1 * temp)",
      "mutated_line": "heapq.heappush(h, --1 * temp)",
      "code": "import heapq\n\ndef max_uniform_pants(S, N, K):\n\n    def f(arr, n, k, c):\n        ans = 0\n        i = 0\n        while i < n and arr[i] == c:\n            ans += 1\n            i += 1\n        if i >= n:\n            return n\n        j = n - 1\n        while arr[j] == c:\n            ans += 1\n            j -= 1\n        if k == 0 and ans != n:\n            return -1\n        if k == 1:\n            return ans\n        h = []\n        heapq.heapify(h)\n        index = i\n        temp = 0\n        for m in range(i, j + 1):\n            if arr[m] == c:\n                temp += 1\n            else:\n                if temp > 0:\n                    heapq.heappush(h, --1 * temp)\n                temp = 0\n        while k > 1 and len(h) > 0:\n            ans += -1 * heapq.heappop(h)\n            k -= 1\n        if ans == 0:\n            return -1\n        else:\n            return ans\n    if S == S[0] * N:\n        return N\n    if K == 0:\n        return -1\n    return max([f(S, N, K, chr(j)) for j in range(ord('A'), ord('Z') + 1)])"
    }
  ]
}