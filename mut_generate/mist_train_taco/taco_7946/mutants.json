{
  "task_id": "taco_7946",
  "entry_point": "generate_next_hexes",
  "mutant_count": 128,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y * 2:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y * 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y + 2:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y + 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes -= [(x - 1, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes -= [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes -= [(x + 1, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes -= [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "num_updated_hexes = 0",
      "mutated_line": "num_updated_hexes = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 1\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "num_updated_hexes = 0",
      "mutated_line": "num_updated_hexes = -1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = -1\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "num_updated_hexes = 0",
      "mutated_line": "num_updated_hexes = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 1\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distance = 0",
      "mutated_line": "distance = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 1\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distance = 0",
      "mutated_line": "distance = -1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = -1\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distance = 0",
      "mutated_line": "distance = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 1\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "distance += 1",
      "mutated_line": "distance -= 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance -= 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_num_blocks = 0",
      "mutated_line": "max_num_blocks = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 1\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_num_blocks = 0",
      "mutated_line": "max_num_blocks = -1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = -1\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_num_blocks = 0",
      "mutated_line": "max_num_blocks = 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 1\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y % 3:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 3:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y % 1:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 1:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y % 0:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 0:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y % 1:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 1:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if y % 2:",
      "mutated_line": "if y % -2:",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % -2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance += 1",
      "mutated_line": "distance += 2",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 2\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance += 1",
      "mutated_line": "distance += 0",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 0\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance += 1",
      "mutated_line": "distance += 0",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 0\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance += 1",
      "mutated_line": "distance += -1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += -1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y + 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y + 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y * 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y * 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y - 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y - 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y * 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y * 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x + 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x + 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x * 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x * 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x - 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x - 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x * 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x * 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m or 1 <= y <= n or (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m or 1 <= y <= n or (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "num_updated_hexes += 1",
      "mutated_line": "num_updated_hexes -= 1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes -= 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "next_hexes += generate_next_hexes(x, y)",
      "mutated_line": "next_hexes -= generate_next_hexes(x, y)",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes -= generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 2), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 2), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 0), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 0), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 0), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 0), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - -1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - -1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 2), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 2), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 0), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 0), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 0), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 0), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + -1), (x - 1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + -1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 2, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 2, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 0, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 0, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 0, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 0, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - -1, y), (x + 1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - -1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 2, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 2, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 0, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 0, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 0, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 0, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]",
      "mutated_line": "hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + -1, y)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + -1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x + 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x * 1, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x * 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y + 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y + 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y * 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y * 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x + 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x * 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x * 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y - 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y - 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y * 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y * 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x - 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x * 1, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x * 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y + 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y + 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y * 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y * 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x - 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x * 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x * 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y - 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y - 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y * 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y * 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = pos[0]",
      "mutated_line": "x = pos[1]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[1]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = pos[0]",
      "mutated_line": "x = pos[-1]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[-1]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = pos[0]",
      "mutated_line": "x = pos[1]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[1]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = pos[1]",
      "mutated_line": "y = pos[2]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[2]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = pos[1]",
      "mutated_line": "y = pos[0]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[0]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = pos[1]",
      "mutated_line": "y = pos[0]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[0]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = pos[1]",
      "mutated_line": "y = pos[-1]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[-1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 < x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 < x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 > x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 > x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 == x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 == x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 < y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 < y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 > y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 > y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 == y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 == y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map and distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map and distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "num_updated_hexes += 1",
      "mutated_line": "num_updated_hexes += 2",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 2\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "num_updated_hexes += 1",
      "mutated_line": "num_updated_hexes += 0",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 0\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "num_updated_hexes += 1",
      "mutated_line": "num_updated_hexes += 0",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 0\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "num_updated_hexes += 1",
      "mutated_line": "num_updated_hexes += -1",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += -1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 2, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 2, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 0, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 0, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 0, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 0, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - -1, y - 1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - -1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 2), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 2), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 0), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 0), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 0), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 0), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - -1), (x - 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - -1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 2, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 2, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 0, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 0, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 0, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 0, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - -1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - -1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y + 2)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 2)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y + 0)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 0)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y + 0)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 0)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "hexes += [(x - 1, y - 1), (x - 1, y + 1)]",
      "mutated_line": "hexes += [(x - 1, y - 1), (x - 1, y + -1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + -1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 2, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 2, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 0, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 0, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 0, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 0, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + -1, y - 1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + -1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 2), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 2), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 0), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 0), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 0), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 0), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - -1), (x + 1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - -1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 2, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 2, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 0, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 0, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 0, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 0, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + -1, y + 1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + -1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y + 2)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 2)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y + 0)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 0)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y + 0)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 0)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "hexes += [(x + 1, y - 1), (x + 1, y + 1)]",
      "mutated_line": "hexes += [(x + 1, y - 1), (x + 1, y + -1)]",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + -1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 2 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 2 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 0 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 0 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 0 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 0 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if -1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if -1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 2 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 2 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 0 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 0 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 0 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 0 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and -1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and -1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 <= y <= n and (pos in hex_map or distance < hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance <= hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance <= hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance >= hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance >= hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance < hex_map[pos]):",
      "mutated_line": "if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance != hex_map[pos]):",
      "code": "def generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes, m, n):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if 1 <= x <= m and 1 <= y <= n and (pos not in hex_map or distance != hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\ndef calculate_max_coverage(m, n, existing_stores, candidate_sites):\n    hex_map = {}\n    update_map(hex_map, existing_stores, m, n)\n    max_num_blocks = 0\n    for candidate in candidate_sites:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate], m, n)\n        max_num_blocks = max(max_num_blocks, num_blocks)\n    return max_num_blocks"
    }
  ]
}