{
  "task_id": "taco_10924",
  "entry_point": "calculate_unread_notifications",
  "mutant_count": 90,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [0] / n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] / n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [0] + n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] + n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [0] ** n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] ** n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] / n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] / n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] + n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] + n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] ** n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] ** n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 1\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = -1\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 1\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 1\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n = 0",
      "mutated_line": "n = -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = -1\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 1\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if y == 1:",
      "mutated_line": "if y != 1:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y != 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x += 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "B[x] += 1",
      "mutated_line": "B[x] -= 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] -= 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "A[x] += 1",
      "mutated_line": "A[x] -= 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] -= 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s -= 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [1] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [-1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [-1] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * n",
      "mutated_line": "A = [1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [1] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [1] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [-1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [-1] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [1] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 2:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 2:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 0:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 0:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 0:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 0:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if y == 1:",
      "mutated_line": "if y == -1:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == -1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 2\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 0\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 0\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= -1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "B[x] += 1",
      "mutated_line": "B[x] += 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 2\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "B[x] += 1",
      "mutated_line": "B[x] += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 0\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "B[x] += 1",
      "mutated_line": "B[x] += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 0\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "B[x] += 1",
      "mutated_line": "B[x] += -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += -1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A[x] += 1",
      "mutated_line": "A[x] += 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 2\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A[x] += 1",
      "mutated_line": "A[x] += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 0\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A[x] += 1",
      "mutated_line": "A[x] += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 0\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A[x] += 1",
      "mutated_line": "A[x] += -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += -1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 2\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 0\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 0\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += -1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y != 2:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y != 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x += 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "s -= A[x]",
      "mutated_line": "s += A[x]",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s += A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y == 3:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 3:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y == 1:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 1:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y == 0:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 0:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y == 1:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 1:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif y == 2:",
      "mutated_line": "elif y == -2:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == -2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 2\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 0\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 0\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= -1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A[x] = 0",
      "mutated_line": "A[x] = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 1\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A[x] = 0",
      "mutated_line": "A[x] = -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = -1\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A[x] = 0",
      "mutated_line": "A[x] = 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 1\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y != 3:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y != 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y == 4:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 4:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y == 2:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 2:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y == 0:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 0:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y == 1:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 1:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif y == 3:",
      "mutated_line": "elif y == -3:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == -3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while x > n:",
      "mutated_line": "while x >= n:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x >= n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while x > n:",
      "mutated_line": "while x <= n:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x <= n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while x > n:",
      "mutated_line": "while x != n:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x != n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "n += 1",
      "mutated_line": "n -= 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n -= 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "B[y] -= 1",
      "mutated_line": "B[y] += 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] += 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "n += 1",
      "mutated_line": "n += 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 2\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 0\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 0\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "n += 1",
      "mutated_line": "n += -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += -1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "B[y] -= 1",
      "mutated_line": "B[y] -= 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 2\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "B[y] -= 1",
      "mutated_line": "B[y] -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 0\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "B[y] -= 1",
      "mutated_line": "B[y] -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 0\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "B[y] -= 1",
      "mutated_line": "B[y] -= -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= -1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if B[y] < A[y]:",
      "mutated_line": "if B[y] <= A[y]:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] <= A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if B[y] < A[y]:",
      "mutated_line": "if B[y] >= A[y]:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] >= A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if B[y] < A[y]:",
      "mutated_line": "if B[y] != A[y]:",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] != A[y]:\n                    A[y] -= 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "A[y] -= 1",
      "mutated_line": "A[y] += 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] += 1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s += 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[y] -= 1",
      "mutated_line": "A[y] -= 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 2\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[y] -= 1",
      "mutated_line": "A[y] -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 0\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[y] -= 1",
      "mutated_line": "A[y] -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 0\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[y] -= 1",
      "mutated_line": "A[y] -= -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= -1\n                    s -= 1\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 2\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 0\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= 0\n        L.append(s)\n    return L"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "import collections\n\ndef calculate_unread_notifications(n, q, events):\n    Q = collections.deque()\n    A = [0] * n\n    B = [0] * n\n    L = []\n    s = 0\n    n = 0\n    for event in events:\n        (y, x) = event\n        if y == 1:\n            x -= 1\n            Q.append(x)\n            B[x] += 1\n            A[x] += 1\n            s += 1\n        elif y == 2:\n            x -= 1\n            s -= A[x]\n            A[x] = 0\n        elif y == 3:\n            while x > n:\n                n += 1\n                y = Q.popleft()\n                B[y] -= 1\n                if B[y] < A[y]:\n                    A[y] -= 1\n                    s -= -1\n        L.append(s)\n    return L"
    }
  ]
}