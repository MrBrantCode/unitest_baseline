{
  "task_id": "taco_16434",
  "entry_point": "count_spanning_tree_paintings",
  "mutant_count": 171,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "overX = 0",
      "mutated_line": "overX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 1\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "overX = 0",
      "mutated_line": "overX = -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = -1\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "overX = 0",
      "mutated_line": "overX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 1\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "justX = 0",
      "mutated_line": "justX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 1\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "justX = 0",
      "mutated_line": "justX = -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = -1\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "justX = 0",
      "mutated_line": "justX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 1\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "underX = 0",
      "mutated_line": "underX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 1\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "underX = 0",
      "mutated_line": "underX = -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = -1\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "underX = 0",
      "mutated_line": "underX = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 1\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "h += wvu[i][0]",
      "mutated_line": "h -= wvu[i][0]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h -= wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 - 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 * 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if justX == 0:",
      "mutated_line": "if justX != 0:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX != 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return ans % mod",
      "mutated_line": "return ans * mod",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans * mod"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return ans % mod",
      "mutated_line": "return ans + mod",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans + mod"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while p[n] != n:",
      "mutated_line": "while p[n] == n:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] == n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if ap == bp:",
      "mutated_line": "if ap != bp:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap != bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [0] / N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] / N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [0] + N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] + N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [0] ** N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] ** N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 1\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "h = 0",
      "mutated_line": "h = -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = -1\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 1\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if h > X:",
      "mutated_line": "if h >= X:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h >= X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if h > X:",
      "mutated_line": "if h <= X:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h <= X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if h > X:",
      "mutated_line": "if h != X:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h != X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "overX += 1",
      "mutated_line": "overX -= 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX -= 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 * 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 + 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 8\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 6\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 0\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 1\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + -7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if justX == 0:",
      "mutated_line": "if justX == 1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 1:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if justX == 0:",
      "mutated_line": "if justX == -1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == -1:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if justX == 0:",
      "mutated_line": "if justX == 1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 1:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 1\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return -1\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 1\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX >= 0:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX >= 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX <= 0:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX <= 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX != 0:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX != 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return True\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if rank[ap] > rank[bp]:",
      "mutated_line": "if rank[ap] >= rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] >= rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if rank[ap] > rank[bp]:",
      "mutated_line": "if rank[ap] <= rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] <= rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if rank[ap] > rank[bp]:",
      "mutated_line": "if rank[ap] != rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] != rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return False\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u + 1, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u + 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u * 1, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u * 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v + 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v + 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v * 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v * 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "h += wvu[i][0]",
      "mutated_line": "h += wvu[i][1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][1]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "h += wvu[i][0]",
      "mutated_line": "h += wvu[i][-1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][-1]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "h += wvu[i][0]",
      "mutated_line": "h += wvu[i][1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][1]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "h += wvu[j][0]",
      "mutated_line": "h -= wvu[j][0]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h -= wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "overX += 1",
      "mutated_line": "overX += 2",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 2\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "overX += 1",
      "mutated_line": "overX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 0\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "overX += 1",
      "mutated_line": "overX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 0\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "overX += 1",
      "mutated_line": "overX += -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += -1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "elif h == X:",
      "mutated_line": "elif h != X:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h != X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "justX += 1",
      "mutated_line": "justX -= 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX -= 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "underX += 1",
      "mutated_line": "underX -= 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX -= 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 11 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 9 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 0 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 1 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = -10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 10 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 8 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 0 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 1 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** -9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX > 1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 1:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX > -1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > -1:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif underX > 0:",
      "mutated_line": "elif underX > 1:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 1:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) / (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) / (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) + (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) + (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = (2 * pow(2, overX, mod)) ** (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = (2 * pow(2, overX, mod)) ** (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) / (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) / (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) + (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) + (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) ** (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) ** (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif rank[ap] < rank[bp]:",
      "mutated_line": "elif rank[ap] <= rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] <= rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif rank[ap] < rank[bp]:",
      "mutated_line": "elif rank[ap] >= rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] >= rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif rank[ap] < rank[bp]:",
      "mutated_line": "elif rank[ap] != rank[bp]:",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] != rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "rank[ap] += 1",
      "mutated_line": "rank[ap] -= 1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] -= 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 2, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 2, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 0, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 0, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 0, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 0, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - -1, v - 1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - -1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v - 2) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 2) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v - 0) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 0) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v - 0) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 0) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "wvu = [(w, u - 1, v - 1) for u, v, w in edges]",
      "mutated_line": "wvu = [(w, u - 1, v - -1) for (u, v, w) in edges]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - -1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [1] * N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [1] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [-1] * N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [-1] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "rank = [0] * N",
      "mutated_line": "rank = [1] * N",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [1] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][2], wvu[i][2], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][2], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][0], wvu[i][2], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][0], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][0], wvu[i][2], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][0], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][-1], wvu[i][2], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][-1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][1], wvu[i][3], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][3], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][1], wvu[i][1], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][1], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][1], wvu[i][0], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][0], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][1], wvu[i][1], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][1], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "uf_union(wvu[i][1], wvu[i][2], p, rank)",
      "mutated_line": "uf_union(wvu[i][1], wvu[i][-2], p, rank)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][-2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "justX += 1",
      "mutated_line": "justX += 2",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 2\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "justX += 1",
      "mutated_line": "justX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 0\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "justX += 1",
      "mutated_line": "justX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 0\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "justX += 1",
      "mutated_line": "justX += -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += -1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "underX += 1",
      "mutated_line": "underX += 2",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 2\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "underX += 1",
      "mutated_line": "underX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 0\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "underX += 1",
      "mutated_line": "underX += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 0\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "underX += 1",
      "mutated_line": "underX += -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += -1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 / pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 / pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = (2 + pow(2, overX, mod)) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = (2 + pow(2, overX, mod)) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 ** pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 ** pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) + 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) + 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) * 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) * 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) + 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) + 2)\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) * 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) * 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank[ap] += 1",
      "mutated_line": "rank[ap] += 2",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 2\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank[ap] += 1",
      "mutated_line": "rank[ap] += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 0\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank[ap] += 1",
      "mutated_line": "rank[ap] += 0",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 0\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank[ap] += 1",
      "mutated_line": "rank[ap] += -1",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += -1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][2], wvu[j][2], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][2], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][0], wvu[j][2], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][0], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][0], wvu[j][2], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][0], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][-1], wvu[j][2], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][-1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][1], wvu[j][3], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][3], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][1], wvu[j][1], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][1], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][1], wvu[j][0], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][0], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][1], wvu[j][1], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][1], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if uf_union(wvu[j][1], wvu[j][2], p, rank):",
      "mutated_line": "if uf_union(wvu[j][1], wvu[j][-2], p, rank):",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][-2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "h += wvu[j][0]",
      "mutated_line": "h += wvu[j][1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][1]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "h += wvu[j][0]",
      "mutated_line": "h += wvu[j][-1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][-1]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "h += wvu[j][0]",
      "mutated_line": "h += wvu[j][1]",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][1]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 3 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 3 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 1 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 1 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 0 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 0 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 1 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 1 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = -2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = -2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 0)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 0)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 0)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 0)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - -1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - -1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(3, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(3, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(1, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(1, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(0, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(0, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(1, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(1, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(-2, overX, mod) * (pow(2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(-2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 3)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 3)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 0)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 0)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - -2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - -2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(3, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(3, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(1, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(1, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(0, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(0, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(1, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(1, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(-2, overX, mod) * (pow(2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(-2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(3, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(3, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(1, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(1, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(0, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(0, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(1, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(1, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)",
      "mutated_line": "ans = 2 * pow(2, overX, mod) * (pow(-2, justX, mod) - 1)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(-2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(3, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(3, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(1, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(1, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(0, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(0, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(1, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(1, justX, mod) - 2)\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = pow(2, overX, mod) * (pow(2, justX, mod) - 2)",
      "mutated_line": "ans = pow(2, overX, mod) * (pow(-2, justX, mod) - 2)",
      "code": "def count_spanning_tree_paintings(N, M, X, edges):\n\n    def uf_find(n, p):\n        ufl = []\n        while p[n] != n:\n            ufl.append(n)\n            n = p[n]\n        for i in ufl:\n            p[i] = n\n        return n\n\n    def uf_union(a, b, p, rank):\n        ap = uf_find(a, p)\n        bp = uf_find(b, p)\n        if ap == bp:\n            return False\n        else:\n            if rank[ap] > rank[bp]:\n                p[bp] = ap\n            elif rank[ap] < rank[bp]:\n                p[ap] = bp\n            else:\n                p[bp] = ap\n                rank[ap] += 1\n            return True\n    wvu = [(w, u - 1, v - 1) for (u, v, w) in edges]\n    wvu.sort()\n    overX = 0\n    justX = 0\n    underX = 0\n    for i in range(M):\n        p = [i for i in range(N)]\n        rank = [0] * N\n        h = 0\n        h += wvu[i][0]\n        uf_union(wvu[i][1], wvu[i][2], p, rank)\n        for j in range(M):\n            if uf_union(wvu[j][1], wvu[j][2], p, rank):\n                h += wvu[j][0]\n        if h > X:\n            overX += 1\n        elif h == X:\n            justX += 1\n        else:\n            underX += 1\n    mod = 10 ** 9 + 7\n    if justX == 0:\n        return 0\n    elif underX > 0:\n        ans = 2 * pow(2, overX, mod) * (pow(2, justX, mod) - 1)\n    else:\n        ans = pow(2, overX, mod) * (pow(-2, justX, mod) - 2)\n    return ans % mod"
    }
  ]
}