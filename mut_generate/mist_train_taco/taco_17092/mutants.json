{
  "task_id": "taco_17092",
  "entry_point": "calculate_ways_to_move",
  "mutant_count": 337,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000008",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000008\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000006",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000006\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 0\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = -1000000007",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = -1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "n = case['N']",
      "mutated_line": "n = case['']",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = case['M']",
      "mutated_line": "m = case['']",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x = case['x']",
      "mutated_line": "x = case['']",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d = case['D']",
      "mutated_line": "d = case['']",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 1] = 2",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 2\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 1] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 0\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 1] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 0\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 1] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = -1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(1, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(-1, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(1, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m - 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m * 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][0] = 2",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 2\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][0] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 0\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][0] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 0\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][0] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = -1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "comb[i][i] = 1",
      "mutated_line": "comb[i][i] = 2",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 2\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "comb[i][i] = 1",
      "mutated_line": "comb[i][i] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 0\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "comb[i][i] = 1",
      "mutated_line": "comb[i][i] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 0\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "comb[i][i] = 1",
      "mutated_line": "comb[i][i] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = -1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(2, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(2, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(0, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(0, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(-1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m - 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m * 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(1, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(-1, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(1, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m - 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m * 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(1, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(-1, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(1, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n - 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n * 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[0][i] = 2",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 2\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[0][i] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 0\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[0][i] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 0\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[0][i] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = -1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(3, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(0, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(-2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n - 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n * 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[-1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[-1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(2, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(2, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(0, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(0, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(0, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(0, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(-1, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(-1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D - 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D * 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][0] = 2",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 2\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][0] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 0\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][0] = 0",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 0\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][0] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = -1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(2, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(0, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(0, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(-1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m - 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m * 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i - 1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i - 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i * 1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i * 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(2, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(0, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(0, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(-1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m - 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m * 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[1 for i in range(m + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[1 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[-1 for i in range(m + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[-1 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[1 for i in range(m + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[1 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 2):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 0):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 0):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + -1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][1] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][-1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][-1] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "comb[i][0] = 1",
      "mutated_line": "comb[i][1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][1] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 2):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 0):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 0):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + -1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, i):",
      "mutated_line": "for j in range(2, i):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(2, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, i):",
      "mutated_line": "for j in range(0, i):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(0, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, i):",
      "mutated_line": "for j in range(0, i):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(0, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, i):",
      "mutated_line": "for j in range(-1, i):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(-1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) * mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) * mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1] + mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1] + mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[-1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[-1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[1 for i in range(n + 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[1 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 2):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 0):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 0):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(0, m + 1):",
      "mutated_line": "for i in range(0, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + -1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][2] = mat[i][1]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][2] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][0] = mat[i][1]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][0] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][0] = mat[i][1]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][0] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][-1] = mat[i][1]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][-1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][1] = mat[i][2]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][2]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][1] = mat[i][0]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][0]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][1] = mat[i][0]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][0]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res[i][1] = mat[i][1]",
      "mutated_line": "res[i][1] = mat[i][-1]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][-1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 2):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 0):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 0):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + -1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 2):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 0):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 0):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + -1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(2, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(0, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(0, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(-1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m - 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m * 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res[j][i] = 0",
      "mutated_line": "res[j][i] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 1\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res[j][i] = 0",
      "mutated_line": "res[j][i] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = -1\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res[j][i] = 0",
      "mutated_line": "res[j][i] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 1\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m - 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m - 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m * 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m * 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[1 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[1 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[-1 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[-1 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[1 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[1 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 2):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 0):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 0):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, D + 1):",
      "mutated_line": "for j in range(1, D + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + -1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][1] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][-1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][-1] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat1[j][0] = 1",
      "mutated_line": "mat1[j][1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][1] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 2):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 0):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 0):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + -1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(2, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(2, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(0, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(0, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(0, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(0, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(-1, D + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(-1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D - 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D * 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mat1[k][j] = 0",
      "mutated_line": "mat1[k][j] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 1\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mat1[k][j] = 0",
      "mutated_line": "mat1[k][j] = -1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = -1\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mat1[k][j] = 0",
      "mutated_line": "mat1[k][j] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 1\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 >= 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 >= 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 <= 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 <= 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 != 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 != 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 1 < D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 < D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 1 > D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 > D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 1 == D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 == D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[1][i + 1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[1][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[-1][i + 1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[-1][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[1][i + 1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[1][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 2] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 2] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 0] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 0] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + 0] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 0] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "mat[0][i + 1] = 1",
      "mutated_line": "mat[0][i + -1] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + -1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 2):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 0):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 0):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + -1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i - 1] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i - 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i * 1] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i * 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m - 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m - 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m * 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m * 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] - comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] - comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = comb[i - 1][j] * comb[i - 1][j - 1] % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = comb[i - 1][j] * comb[i - 1][j - 1] % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m - 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m - 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m * 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m * 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[1][i] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[1][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[-1][i] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[-1][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res[0][i] = 1",
      "mutated_line": "res[1][i] = 1",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[1][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 2):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 0):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 0):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + -1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(1, j + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(1, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(-1, j + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(-1, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(1, j + 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(1, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j - 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j - 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j * 1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j * 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) * mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) * mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod + mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod + mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n - 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n - 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n * 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n * 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 2)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 2)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 0)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 0)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 1)] for j in range(m + -1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + -1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] - 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] - 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] * 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] * 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 2):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 0):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 0):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for k in range(1, D + 1):",
      "mutated_line": "for k in range(1, D + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + -1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k + 1 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k + 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k * 1 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k * 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 > 1:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 1:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 > -1:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > -1:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 1 > 1:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 1:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) * mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) * mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = mat1[k][j] + mat1[k - 1][j - 1] + mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = mat1[k][j] + mat1[k - 1][j - 1] + mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k - 1 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k - 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k * 1 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k * 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) * mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) * mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = mat1[k][j] + mat1[k + 1][j - 1] + mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = mat1[k][j] + mat1[k + 1][j - 1] + mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i + 2] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 2] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i + 0] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 0] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i + 0] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 0] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mat[j][i + 1] = mat1[x[i]][j]",
      "mutated_line": "mat[j][i + -1] = mat1[x[i]][j]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + -1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m - 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m - 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m * 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m * 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 2)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 2)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 0)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 0)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 1)] for j in range(m + -1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + -1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n - 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n - 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n * 1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n * 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m + 2)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 2)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 0)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 0)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 1)] for j in range(m + -1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + -1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j + 2):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 2):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 0):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j + 0):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 0):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for k in range(0, j + 1):",
      "mutated_line": "for k in range(0, j + -1):",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + -1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] - comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] - comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = res[j][i] * (comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = res[j][i] * (comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 2)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 2)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 0)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 0)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mat = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "mat = [[0 for i in range(n + -1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + -1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m - 1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m - 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m * 1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m * 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 2)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 2)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 0)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 0)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 0)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + -1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + -1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 2 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 2 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 0 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 0 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - 0 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 0 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k - 1 > 0:",
      "mutated_line": "if k - -1 > 0:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - -1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] - mat1[k - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] - mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = mat1[k][j] * mat1[k - 1][j - 1] % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = mat1[k][j] * mat1[k - 1][j - 1] % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 2 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 2 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 0 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 0 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + 0 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 0 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k + 1 <= D:",
      "mutated_line": "if k + -1 <= D:",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + -1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] - mat1[k + 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] - mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = mat1[k][j] * mat1[k + 1][j - 1] % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = mat1[k][j] * mat1[k + 1][j - 1] % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 2)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 2)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 0)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 0)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "comb = [[0 for i in range(m + 1)] for j in range(m + 1)]",
      "mutated_line": "comb = [[0 for i in range(m + -1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + -1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j + 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j + 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j * 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j * 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 2)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 2)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 0)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + 0)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 0)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = [[0 for i in range(n + 1)] for j in range(m + 1)]",
      "mutated_line": "res = [[0 for i in range(n + -1)] for j in range(m + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + -1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) * mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) * mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + (comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) + mod)) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + (comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) + mod)) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 2)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 2)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 0)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 0)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + 0)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 0)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]",
      "mutated_line": "mat1 = [[0 for j in range(m + -1)] for k in range(d[i] + 1)]",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + -1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i + 1][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i + 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i * 1][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i * 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i + 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i + 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i * 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i * 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 2]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 2]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 0]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 0]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - -1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - -1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] / (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] / (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + (comb[j][j - k] + res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + (comb[j][j - k] + res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] ** (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] ** (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j + 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j + 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j * 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j * 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j + 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j + 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j * 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j * 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 2][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 2][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 0][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 0][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 0][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 0][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - -1][j] + comb[i - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - -1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 2][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 2][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 0][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 0][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod",
      "mutated_line": "comb[i][j] = (comb[i - 1][j] + comb[i - -1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - -1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] * mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] * mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] + mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] + mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k * 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k * 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 2]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 2]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 0]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 0]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - -1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - -1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k * 1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k * 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 2]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 2]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 0]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 0]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 0]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - -1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - -1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j + k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j + k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j * k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j * k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] / mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] / mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * ((res[k][i - 1] + mat[j - k][i]) % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * ((res[k][i - 1] + mat[j - k][i]) % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] ** mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] ** mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 2][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 2][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 0][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 0][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k - -1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - -1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 2][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 2][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 0][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 0][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 0][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod",
      "mutated_line": "mat1[k][j] = (mat1[k][j] + mat1[k + -1][j - 1]) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + -1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i + 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i + 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i * 1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i * 1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 2] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 2] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 0] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 0] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 0] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 0] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - -1] * mat[j - k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - -1] * mat[j - k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j + k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j + k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res[j][i] = (res[j][i] + ((comb[j][j - k] * ((res[k][i - 1] * mat[j - k][i]) % mod)) % mod)) % mod",
      "mutated_line": "res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j * k][i] % mod) % mod) % mod",
      "code": "def calculate_ways_to_move(test_cases):\n    mod = 1000000007\n    results = []\n    for case in test_cases:\n        n = case['N']\n        m = case['M']\n        x = case['x']\n        d = case['D']\n        mat = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(n):\n            mat1 = [[0 for j in range(m + 1)] for k in range(d[i] + 1)]\n            D = d[i]\n            for j in range(1, D + 1):\n                mat1[j][0] = 1\n            for j in range(1, m + 1):\n                for k in range(1, D + 1):\n                    mat1[k][j] = 0\n                    if k - 1 > 0:\n                        mat1[k][j] = (mat1[k][j] + mat1[k - 1][j - 1]) % mod\n                    if k + 1 <= D:\n                        mat1[k][j] = (mat1[k][j] + mat1[k + 1][j - 1]) % mod\n            mat[0][i + 1] = 1\n            for j in range(1, m + 1):\n                mat[j][i + 1] = mat1[x[i]][j]\n        comb = [[0 for i in range(m + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            comb[i][0] = 1\n            comb[i][i] = 1\n        for i in range(1, m + 1):\n            for j in range(1, i):\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod\n        res = [[0 for i in range(n + 1)] for j in range(m + 1)]\n        for i in range(0, m + 1):\n            res[i][1] = mat[i][1]\n        for i in range(0, n + 1):\n            res[0][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, m + 1):\n                res[j][i] = 0\n                for k in range(0, j + 1):\n                    res[j][i] = (res[j][i] + comb[j][j - k] * (res[k][i - 1] * mat[j * k][i] % mod) % mod) % mod\n        results.append(res[m][n])\n    return results"
    }
  ]
}