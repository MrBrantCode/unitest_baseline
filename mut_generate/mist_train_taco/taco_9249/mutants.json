{
  "task_id": "taco_9249",
  "entry_point": "find_longest_regular_bracket_sequence",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [0] / n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] / n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [0] + n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] + n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [0] ** n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] ** n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 1\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = -1\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 1\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx = 0",
      "mutated_line": "mx = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 1\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx = 0",
      "mutated_line": "mx = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = -1\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx = 0",
      "mutated_line": "mx = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 1\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 2\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 0\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 0\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = -1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tmp_max = 0",
      "mutated_line": "tmp_max = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 1\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tmp_max = 0",
      "mutated_line": "tmp_max = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = -1\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tmp_max = 0",
      "mutated_line": "tmp_max = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 1\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prev_join_idx = 0",
      "mutated_line": "prev_join_idx = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 1\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prev_join_idx = 0",
      "mutated_line": "prev_join_idx = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = -1\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prev_join_idx = 0",
      "mutated_line": "prev_join_idx = 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 1\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i <= n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i >= n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i != n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if char == '(':",
      "mutated_line": "if char != '(':",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char != '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i -= 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [1] * n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [1] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [-1] * n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [-1] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mapping = [0] * n",
      "mutated_line": "mapping = [1] * n",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [1] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if char == '(':",
      "mutated_line": "if char == '':",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "elif char == ')' and stack:",
      "mutated_line": "elif char == ')' or stack:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' or stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] - i - 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i - 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = (mapping[i] - i) * 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = (mapping[i] - i) * 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i != prev_join_idx + 1:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i != prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "tmp_max += curr_len",
      "mutated_line": "tmp_max -= curr_len",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max -= curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if tmp_max > mx:",
      "mutated_line": "if tmp_max >= mx:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max >= mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if tmp_max > mx:",
      "mutated_line": "if tmp_max <= mx:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max <= mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if tmp_max > mx:",
      "mutated_line": "if tmp_max != mx:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max != mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] - 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] - 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] * 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] * 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 2\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 0\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 0\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += -1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif char == ')' and stack:",
      "mutated_line": "elif char != ')' and stack:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char != ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] + i + 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] + i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] * i + 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] * i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] - i + 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 2\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] - i + 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 0\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] - i + 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 0\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr_len = mapping[i] - i + 1",
      "mutated_line": "curr_len = mapping[i] - i + -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + -1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx - 1:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx - 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx * 1:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx * 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 2\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 0\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 0\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = -1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif tmp_max == mx:",
      "mutated_line": "elif tmp_max != mx:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max != mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt -= 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] + 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 2\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] + 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 0\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] + 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 0\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = mapping[i] + 1",
      "mutated_line": "i = mapping[i] + -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + -1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif char == ')' and stack:",
      "mutated_line": "elif char == '' and stack:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == '' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx + 2:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 2:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx + 0:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 0:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx + 0:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 0:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i == prev_join_idx + 1:",
      "mutated_line": "if i == prev_join_idx + -1:",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + -1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 2\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 0\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += 0\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def find_longest_regular_bracket_sequence(bracket_string: str) -> tuple[int, int]:\n    n = len(bracket_string)\n    stack = []\n    mapping = [0] * n\n    for (idx, char) in enumerate(bracket_string):\n        if char == '(':\n            stack.append(idx)\n        elif char == ')' and stack:\n            mapping[stack.pop()] = idx\n    i = 0\n    mx = 0\n    cnt = 1\n    tmp_max = 0\n    prev_join_idx = 0\n    while i < n:\n        if mapping[i]:\n            curr_len = mapping[i] - i + 1\n            if i == prev_join_idx + 1:\n                tmp_max += curr_len\n            else:\n                tmp_max = curr_len\n            if tmp_max > mx:\n                mx = tmp_max\n                cnt = 1\n            elif tmp_max == mx:\n                cnt += -1\n            prev_join_idx = mapping[i]\n            i = mapping[i] + 1\n        else:\n            i += 1\n    return (mx, cnt)"
    }
  ]
}